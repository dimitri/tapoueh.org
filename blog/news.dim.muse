#author Dimitri Fontaine
#title tail -f /dev/dim
#desc dim's general purpose blog, which might turn into emacs specific

* 20100726-11:55 dim-switch-window.el: fixes

Thanks to amazing readers of [[http://planet.emacsen.org/][planet emacsen]], two annoyances of
[[http://www.emacswiki.org/emacs/switch-window.el][switch-window.el]] have already been fixed! The first is that handling of =C-g=
isn't exactly an option after all, and the other is that you want to avoid
the buffer creation in the simple cases (1 or 2 windows only), because it's
the usual case.

I've received code to handle the second case, that I mostly merged. Thanks a
lot guys, the new version is on [[http://wwww.emacswiki.org][emacswiki]] already!

* 20100725-13:25 dim-switch-window.el

So it's Sunday and I'm thinking I'll get into =el-get= sometime later. Now is
the time to present =dim-switch-window.el= which implements a *visual* =C-x o=. I
know of only one way to present a *visual effect*, and that's with a screenshot:

	    [[../images/emacs-switch-window.png]]

So as you can see, it's all about showing a *big* number in each window,
tweaking each window's name, and waiting till the user press one of the
expected key — or timeout and stay on the same window as before =C-x o=. When
there's only 1 or 2 windows displayed, though, the right thing happen and
you see no huge number (in the former case, nothing happens, in the latter,
focus moves to the other window).

The code for that can be found on [[http://www.emacswiki.org/][emacswiki]] under the name
[[http://www.emacswiki.org/emacs/switch-window.el][switch-window.el]]. Hope you'll find it useful!


* 20100723-22:20 ClusterSSH gets `dsh' support

If you don't know about [[cssh.html][ClusterSSH]], it's a project that builds on =M-x term=
and =ssh= to offer a nice and simple way to open remote terminals. It's
available in [[http://tromey.com/elpa/index.html][ELPA]] and developed at [[http://github.com/dimitri/cssh][github cssh]] repository.

The default binding is <code>C-=</code> and asks for the name of the server
to connect to, in the *minibuffer*, with completion. The host list used for
the completion comes from =tramp= and is pretty complete, all the more if
you've setup =~/.ssh/config= with =HashKnownHosts no=.

So the usual way to use =cssh.el= would be to just open a single remote
connection at a time. But of course you can open as many as you like, and
you get them all in a mosaic of =term= in your emacs frame, with an input
window at the bottom to control them all. There were two ways to get there,
either opening all remote hosts whose name is matching a given regexp, that
would be using <code>C-M-=</code> or getting to =IBuffer= and marking there
the existing remote =terms= you want to control all at once then use
<code>C-=</code>.

Well I've just added another mode of operation by supporting *enhanced* [[http://www.netfort.gr.jp/~dancer/software/dsh.html.en][dsh]]
group files. In such files, you're supposed to have a remote host name per
line and that's it. We've added support for line containing =@group= kind of
lines so that you can *include* another group easily. To use the facility,
either open your =~/.dsh/group= directory in =dired= and type <code>C-=</code>
when on the right line, or simply use the global <code>C-=</code> you
already know and love. Then, type =@= and complete to any existing group found
in your =cssh-dsh-path= (it defaults to the right places, so chances are you
will never have to edit this one). And that's it, [[http://www.gnu.org/software/emacs/][Emacs]] will open one =term=
per remote host you have in the =dsh= group you just picked. With a =*cssh*=
controler window, too.

Coming next, how I solved my =init.el= dependancies burden thanks to =el-get=!

* 20100304-13:33 Emacs Muse hacking

Now you know what piece of software is used to publish this blog. I really
like it, the major mode makes it a great experience to be using this tool,
and the fact that you produce the =HTML= and =rsync= it all from within Emacs
(=C-c C-p= then =C-c C-r= with some easy [[http://git.tapoueh.org/?p=tapoueh.org.git;a=blob;f=dim-muse.el;hb=HEAD][elisp code]]) is a big advantage as far
as I'm concerned. No need to resort to =shell= and =Makefile=.

What's new here is that I missed the *one page per article* trend that other
blog software propose, and the blog entries index too. I didn't want to
invest time into hacking Muse itself, that was my excuse for accepting the
situation. But I finally took a deeper look at the [[http://mwolson.org/static/doc/muse/Style-Elements.html#Style-Elements][Emacs Muse Manual]], and
found out about the =:after= and =:final= functions.

Those two function will get run while in the output buffer, the =HTML=
formatted one. With the =:after= function, it's still possible to edit the
buffer content, for example to add a mini index to previous articles,
whereas with the =:final= function the buffer is =read-only= and already written
to disk, so it's to late to edit it. Still it's possible to cut it in pieces
and write a new file per article you find in there.

The code to realize my wishes is [[http://git.tapoueh.org/?p=tapoueh.org.git;a=summary][available]] but has not been edited with
customisation in mind, so to use it you will have to edit some places rather
than just =setq= some =defcustom=. Well, if I have demand, I'll generalize the
code and share it on [[http://www.emacswiki.org/][Emacs Wiki]] and [[http://tromey.com/elpa/][ELPA]]. Meanwhile, happy hacking!

* 20091006-17:23 Emacs Muse based publishing

As you might have noticed, this little blog of mine is not compromising much
and entirely maintained from Emacs. Until today, I had to resort to =term= to
upload my publications, though, as I've been too lazy to hack up the tools
integration for simply doing a single =rsync= command line. That was one time
to many:

<src lang="emacs-lisp">
(defvar dim:muse-rsync-options "-avz"
  "rsync options")

(defvar dim:muse-rsync-source "~/dev/muse/out"
  "local path from where to rsync, with no ending /")

(defvar dim:muse-rsync-target
  "dim@tapoueh.org:/home/www/tapoueh.org/blog.tapoueh.org"
  "Remote URL to use as rsync target, with no ending /")

(defvar dim:muse-rsync-extra-subdirs
  '("../css" "../images" "../pdf")
  "static subdirs to rsync too, path from dim:muse-rsync-source, no ending /")

(defun dim:muse-project-rsync (&optional static)
  "publish tapoueh.org using rsync"
  (interactive "P")
  (let* ((rsync-command (format "rsync %s %s %s" 
				dim:muse-rsync-options
				(concat dim:muse-rsync-source "/")
				(concat dim:muse-rsync-target "/"))))
    (with-current-buffer (get-buffer-create "*muse-rsync*")
      (erase-buffer)
      (insert (concat rsync-command "\n"))
      (message "%s" rsync-command)
      (insert (shell-command-to-string rsync-command))
      (insert "\n")

      (when static
	(dolist (subdir dim:muse-rsync-extra-subdirs)
	  (let ((cmd (format "rsync %s %s %s" 
			     dim:muse-rsync-options
			     (concat dim:muse-rsync-source "/" subdir)
			     dim:muse-rsync-target)))
	    (insert (concat cmd "\n"))
	    (message "%s" cmd)
	    (insert (shell-command-to-string cmd))
	    (insert "\n")))))))

(define-key muse-mode-map (kbd "C-c R") 'dim:muse-project-rsync)
</src>

So now to publish this blog, it's just a =C-c R= away! :)

* 20090924-18:08 Emacs is Twinkling here

So you have a *rolodex* like database in your Emacs, or you have this phone
number in a mail and you want to call it. It happens you have =VoIP= setup and
you're using [[http://www.twinklephone.com/][Twinkle]] to make your calls. Maybe you'll then find this
function useful:

<src lang="emacs-lisp">
(defun twinkle-call-symbol-or-region ()
  "Call the phone number at point (symbol seems good enough), or in region"
  (interactive)
  (shell-command-to-string 
   (format "twinkle --cmd 'call %s'"
	   (replace-regexp-in-string 
	    "[^0-9+]" "" 
	    (if (use-region-p)
		(buffer-substring (region-beginning) (region-end))
	      (thing-at-point 'symbol))))))
</src>

It happens that =symbol= is better than =word= here because some phone numbers
begin with =+=. And some contains =/= or =.= as separators, or some other
variations (spaces) so as the number is easy to read for human eyes. *Twinkle*
will not like this.

* 20090922-23:04 Escreen integration

After having used [[http://www.morishima.net/~naoto/software/elscreen/][elscreen]] for a long time, I'm now a very happy user of
[[http://www.splode.com/~friedman/software/emacs-lisp/#ui][escreen]], which feels much better integrated and allows to have one ring of
recently visited buffers per screen. Which is what you need when using a
*screen* like feature, really.

At first, it seemed so good as not to require any tweaking, but soon enough
I had to adapt it to my workflow. After all that's exactly for being able to
do this that I'm using emacs :)

It began quite simple with things like =M-[= and =M-]= to navigate in screens,
and mouse wheel support to, but then I found that the =C-\ b= list of screens
could also support the =C-\ a runs the command
escreen-get-active-screen-numbers= command by just adding some *emphasis* to
the current escreen in use.

As soon as I had this, and seeing people eyes blinking when working with me
in front of my computer, I wanted to have *escreen* switching display where I
am in the minibuffer. You have to try the mouse wheel navigation to fully
appreciate it I guess. Anyway, here it is:

<src lang="emacs-lisp">
(load "escreen")
(escreen-install)

;; add C-\ l to list screens with emphase for current one
(defun escreen-get-active-screen-numbers-with-emphasis ()
  "what the name says"
  (interactive)
  (let ((escreens (escreen-get-active-screen-numbers))
	(emphased ""))

    (dolist (s escreens)
      (setq emphased
	    (concat emphased (if (= escreen-current-screen-number s)
				 (propertize (number-to-string s)
					     ;;'face 'custom-variable-tag) " ")
					     'face 'info-title-3)
					     ;;'face 'font-lock-warning-face)
					     ;;'face 'secondary-selection)
			       (number-to-string s))
		    " ")))
    (message "escreen: active screens: %s" emphased)))

(global-set-key (kbd "C-\\ l") 'escreen-get-active-screen-numbers-with-emphasis)

(defun dim:escreen-goto-last-screen ()
  (interactive)
  (escreen-goto-last-screen)
  (escreen-get-active-screen-numbers-with-emphasis))

(defun dim:escreen-goto-prev-screen (&optional n)
  (interactive "p")
  (escreen-goto-prev-screen n)
  (escreen-get-active-screen-numbers-with-emphasis))

(defun dim:escreen-goto-next-screen (&optional n)
  (interactive "p")
  (escreen-goto-next-screen n)
  (escreen-get-active-screen-numbers-with-emphasis))

(define-key escreen-map escreen-prefix-char 'dim:escreen-goto-last-screen)

(global-set-key (kbd "M-[") 'dim:escreen-goto-prev-screen)
(global-set-key (kbd "M-]") 'dim:escreen-goto-next-screen)
(global-set-key (kbd "C-\\ DEL") 'dim:escreen-goto-prev-screen)
(global-set-key (kbd "C-\\ SPC") 'dim:escreen-goto-next-screen)

(global-set-key '[s-mouse-4] 'dim:escreen-goto-prev-screen)
(global-set-key '[s-mouse-5] 'dim:escreen-goto-next-screen)
</src>

Oh, and as I'm in the *terms in emacs* part of universe (rather than using
=emacs -nw= in some terminal emulator, but loosing sync between X clipbloard
and emacs selection), I had to add this too:

<src lang="emacs-lisp">
;; add support for C-\ from terms
(require 'term)
(define-key term-raw-map escreen-prefix-char escreen-map)
(define-key term-raw-map (kbd "M-[") 'dim:escreen-goto-prev-screen)
(define-key term-raw-map (kbd "M-]") 'dim:escreen-goto-next-screen)
</src>


* 20090907-12:50 Follow-up on dim:mailrc-add-entry

The function didn't allow for using more than one =mailrc= file, which isn't a
good idea, so I've just added that. Oh and for =gnus= integration what I need
is =(add-hook 'message-mode-hook 'mail-abbrevs-setup)= it seems... so that if
I type the alias it'll get automatically expanded. And to be real lazy and
avoid having to type in the entire alias, =mail-abbrev-complete-alias= to the
rescue, assigned to some easy to reach keys.

<src lang="emacs-lisp">
(require 'message)
(define-key message-mode-map (kbd "C-'") 'mail-abbrev-complete-alias)

(defun dim:mailrc-add-entry (&optional prefix alias)
  "read email at point and add it to an ~/.mailrc file"
  (interactive "P\nMalias: ")
  (let* ((default-mailrc (file-name-nondirectory mail-personal-alias-file))
	 (mailrc (if prefix (expand-file-name
			     (read-file-name 
			      "Add alias into file: " 
			      "~/" 
			      default-mailrc
			      t
			      default-mailrc))
		   mail-personal-alias-file))
	 (address (thing-at-point 'email-address))
	 (buffer (find-file-noselect mailrc t)))
    (when address
      (with-current-buffer buffer
	;; we don't support updating existing alias in the file
	(save-excursion
	  (goto-char (point-min))
	  (if (search-forward (concat "alias " alias) nil t)
	      (error "Alias %s is already present in .mailrc" alias)))

	(save-current-buffer
	  (save-excursion
	    (goto-char (point-max))
	    (insert (format "\nalias %s \"%s <%s>\"" alias (cdr address) (car address)))))))))
</src>

* 20090907-01:29 Improving ~/.mailrc usage

So I've been adviced to use =~/.mailrc= for keeping a basic address book in
Emacs, for use within =gnus= for example. I had to resort to the manual to
find out how to use the file aliases when I need them, that is when
composing a mail. For the record, here's what I had to do:

<src lang="emacs-lisp">
;; mails and aliases
(add-hook 'mail-mode-hook 'mail-abbrevs-setup)
(global-set-key (kbd "C-c @") 'mail-abbrev-insert-alias)
</src>

That means I prefer hitting =C-c @=, then typing the alias in the minibuffer
(with completion) and there after see the full mail address in my
=message-mode= buffer. This looks like it'll change over time, but rather than
searching how to have a nice inline alias completion (=M-tab= maybe, but
already used by the *window manager*), I've tackled the problem of maintaining
the ~/.mailrc file.

Lazy as I am (or I wouldn't be using Emacs this much), having to manually
select the email region in the buffer, open or switch to the =mailrc= buffer
then paste my new entry, not forgetting to format it with =alias foo= prefix
and checking for alias usage while doing so didn't strike me as
appealing. Oh and don't forget to add quote where they belong, too.

Too much work that I wanted to automate. Here we go:

<src lang="emacs-lisp">
;; automate adding mail at point to ~/.mailrc
(defun dim:mailrc-add-entry (alias)
  "read email at point"
  (interactive "Malias: ")
  (let ((address (thing-at-point 'email-address))
	(buffer (find-file-noselect mail-personal-alias-file t)))
    (when address
      (with-current-buffer buffer
	;; we don't support updating existing alias in the file
	(save-excursion
	  (goto-char (point-min))
	  (if (search-forward (concat "alias " alias) nil t)
	      (error "Alias %s is already present in .mailrc" alias)))

	(save-current-buffer
	  (save-excursion
	    (goto-char (point-max))
	    (insert (format "\nalias %s \"%s <%s>\"" alias (cdr address) (car address)))))))))

(global-set-key (kbd "C-c C-@") 'dim:mailrc-add-entry)
</src>

Quite there, you'll notice that I'm using =thing-at-point 'email-address=, and
maybe you already know that =emacs23= does not provide this. It provides
=thing-at-point 'email= which will ignore real name and all. For example,
given a point somewhere inside the right part of =John Doe
<johndoe@email.tld>= the ='email= variant of =thing-at-point= will return
=johndoe@email.tld=. In words of one syllabe: not what I want.

So after searching around for a solution, I saw =mail-header-parse-address=
from the API oriented =mail-parse= librairy, and finaly came up with this dead simple
solution which works fine enough for me:

<src lang="emacs-lisp">
(require 'mail-parse)

(defun thing-at-point-bounds-of-email-address ()
  "return a cons of begin and end position of email address at point, including full name"
  (save-excursion
    (let* ((search-point (point))
	   (start (re-search-backward "[:,]" (line-beginning-position) 'move))
	   (dummy (goto-char search-point))
	   (end   (re-search-forward  "[:,]" (line-end-position) t)))
      (setq start (if start (+ 1 start)
		    (line-beginning-position)))
      (unless end (setq end (line-end-position)))
      (cons start end))))

(defun thing-at-point-email-address ()
  "return full email address at point"
  (let* ((bounds (thing-at-point-bounds-of-email-address))
	 (email-address-text
	  (when bounds (buffer-substring-no-properties (car bounds) (cdr bounds)))))
    (mail-header-parse-address email-address-text)))

(put 'email-address 'bounds-of-thing-at-point 'thing-at-point-bounds-of-email-address)
(put 'email-address 'thing-at-point 'thing-at-point-email-address)
</src>

Now, when I receive a mail and want to store an alias for it, I simply place
point somewhere in the mail then hit =C-c C-@=, and *voilà* my =~/.mailrc= is
uptodate.

Hope it'll be useful for someone else, but at least I'm keeping annotated
history of the files :)

* 20090803-15:15 Some emacs nifties

First, here's a way to insert at current position the last message printed
into the minibuffer... well not exactly, in =*Messages*= buffer in fact. I was
tired of doing it myself after invoking, e.g., =M-x emacs-version=.

<src lang="emacs-lisp">
;; print last message
;; current-message is already lost by the time this gets called
(defun dim:previous-message (&optional nth)
  "get last line of *Message* buffer"
  (with-current-buffer (get-buffer "*Messages*")
    (save-excursion
      (goto-char (point-max))
      (setq nth (if nth nth 1))
      (while (> nth 0)
	(previous-line)
	(setq nth (- nth 1)))
      (buffer-substring (line-beginning-position) (line-end-position)))))

(defun dim:insert-previous-message (&optional nth)
  "insert last message of *Message* to current position"
  (interactive "p")
  (insert (format "%s" (dim:previous-message nth))))

(global-set-key (kbd "C-c m") 'dim:insert-previous-message)
</src>

Now I stumbled accross [[http://planet.emacsen.org/][Planet Emacsen]] and saw this [[http://curiousprogrammer.wordpress.com/2009/07/26/emacs-utility-functions/][Emacs Utility Functions]]
post, containing a version of =duplicate-current-line= that I didn't
like... here's mine:

<src lang="emacs-lisp">
;; duplicate current line
(defun duplicate-current-line (&optional n)
  "duplicate current line, make more than 1 copy given a numeric argument"
  (interactive "p")
  (save-excursion
    (let ((nb (or n 1))
	  (current-line (thing-at-point 'line)))
      ;; when on last line, insert a newline first
      (when (or (= 1 (forward-line 1)) (eq (point) (point-max)))
	(insert "\n"))

      ;; now insert as many time as requested
      (while (> n 0)
	(insert current-line)
	(decf n)))))

(global-set-key (kbd "C-S-d") 'duplicate-current-line)  
</src>

And a last one inspired by some strange =vim= behavior for which I fail to see
a need:

<src lang="emacs-lisp">
;; on request by cyrilb, who missed it from vim
;; no global-set-key yet, still have to think I'll use it someday...
(defun copy-char-from-prev-line ()
  "Copy char at same position on previous line, when such a line and position exists"
  (interactive)
  (let ((c)
	(p (- (point) (line-beginning-position))))
    (save-excursion
      (when (eq 0 (forward-line -1))
	(when (< (+ (point) p) (line-end-position))
	  (forward-char p)
	  (setq c (thing-at-point 'char)))))
    (when c
      (insert c))))
</src>

Next time I'll try to talk about =rcirc-groups= or =cssh= which have managed to
take some of my free time recently.

* Tue,  9 Dec 2008,  0:00 Useful emacs trick

<src lang="emacs-lisp">
(defun insert-date()
  "Insert a time-stamp according to locale's date and time format."
  (interactive)
  (insert (format-time-string "%a, %e %b %Y, %k:%M" (current-time)))) 

(global-set-key "\C-cd" 'insert-date)
</src>

* Mon,  8 Dec 2008, 23:59 Predicting the next 5,000 days of the web

Watch [[http://www.ted.com/index.php/talks/kevin_kelly_on_the_next_5_000_days_of_the_web.html][Kevin Kelly's Talk]] here, it's about trying to predict what the
Internet will look like 5 thousands days from now.

* Mon,  8 Dec 2008, 16:10 emacs-snapshot

If you want to live on the bleeding edge, it's easy enough to get a non
existing release of [[http://www.gnu.org/software/emacs/][GNU Emacs]] under [[http://www.debian.org/releases/unstable/][debian sid]], thanks to
[[http://emacs.orebokech.com/]].

The problem is that [[http://mwolson.org/projects/EmacsMuse.html][Emacs Muse]] is broken on =emacs-snapshot=, partly because
of [[http://www.emacswiki.org/emacs/Htmlize][Htmlize]] which is unable to find the face fonts (I got =(error "Invalid
face")=), partly because of my configuration itself:

<src lang="emacs-lisp">
hunk ./dim-muse.el 22
-      '(("pgsql.tapoueh.org" $
-        (,@(muse-project-alist-dirs "~/dev/muse/site") $
+      '(("pgsql.tapoueh.org" ("~/dev/muse/site"
+        ;;(,@(muse-project-alist-dirs "~/dev/muse/site") $
</src>

The solution was to switch to using =Emacs 22= on sid for [[http://pgsql.tapoueh.org/site/muse/site/][pgsql.tapoueh.org]]
editing, while using [[http://www.emacswiki.org/emacs/?action=browse;oldid=EmacsCVS;id=EmacsFromCVS][EmacsCVS]] for other activities.

And I'm using the patched =Htmlize= on both the versions, by the way.

* December, 6th 2008

A new site, using new software. See [[index.html][Home Page]] to read a rant about it all.

Oh and check out the [[skytools.html][skytools]] page too. [[http://mwolson.org/projects/EmacsMuse.html][Emacs Muse]] is so great a project
that instead of just working on how to publish a website with this tool, I
found myself editing a rather large document about =londite.py=.

* 20081205 Emacs Muse powered blog

So finaly a blogging software for *geeks* exists?

<qotd>
The problem with communication is that you think it happened.
</qotd>
