#author Dimitri Fontaine
#title tail -f /dev/dim
#desc dim's general purpose blog, which might turn into emacs specific

* 20110415-21:30 Emacs Kicker

Following up on the very popular [[https://github.com/technomancy/emacs-starter-kit][emacs-starter-kit]], I'm now proposing the
[[https://github.com/dimitri/emacs-kicker][emacs-kicker]].  It's about the =.emacs= file you've seen in older posts here,
which I maintain for some colleagues.  After all, if they find it useful,
some more people might to, so I've decided to publish it.

What you'll find is a very simple =128= lines [[http://www.gnu.org/software/emacs/][Emacs]] user init file, based on
[[https://github.com/dimitri/el-get][el-get]] for external packages.  A not so *random* selection of those is used,
here's the list when you hide some details:

<src lang="emacs-lisp">
 '(el-get			; el-get is self-hosting
   escreen            		; screen for emacs, C-\ C-h
   php-mode-improved		; if you're into php...
   psvn				; M-x svn-status
   switch-window		; takes over C-x o
   auto-complete		; complete as you type with overlays
   emacs-goodies-el		; the debian addons for emacs
   yasnippet			; powerful snippet mode
   zencoding-mode		; http://www.emacswiki.org/emacs/ZenCoding
   (:name buffer-move		; move buffers around in windows
   (:name smex			; a better (ido like) M-x
   (:name magit			; git meet emacs, and a binding
   (:name goto-last-change	; move pointer back to last change
</src>

Another interresting thing to note in this =kicker= is a choice of some key
bindings that are rather unusual (yet) I guess.

<src lang="emacs-lisp">
(global-set-key (kbd "C-x C-b") 'ido-switch-buffer)
(global-set-key (kbd "C-x C-c") 'ido-switch-buffer)
(global-set-key (kbd "C-x B") 'ibuffer)
</src>

Yes, you see that I've rebound =C-x C-c= to switching buffers.  That key is
really easy to use and I don't think that =M-x kill-emacs= deserves it.  Keys
that are so easy to use should be kept for frequent actions, and quiting
emacs is a once-a-day to once-a-month action here.  And you can still quit
from the window manager button or from the menu or from =M-x=.

Also *Mac* users are not left behind, you will see some settings that either
are adapted to the system (like choosing another *font*, keep displaying the
=menu-bar= or not installing the darkish =tango-color-mode= on this system,
where it renders poorly in my opinion), as you can see here:

<src lang="emacs-lisp">
(if (string-match "apple-darwin" system-configuration)
    (set-face-font 'default "Monaco-13")
  (set-frame-font "Monospace-10"))

(when (string-match "apple-darwin" system-configuration)
  (setq mac-allow-anti-aliasing t)
  (setq mac-command-modifier 'meta)
  (setq mac-option-modifier 'none))
</src>

So all in all, I don't expect this =emacs-kicker= to please everyone, but I
expect it to be simple and rich enough (thanks to [[https://github.com/dimitri/el-get][el-get]]), and it should be
a good *kick start* that's easy to adapt.

If you want to try it without installing it it's very easy to do so.  Just
clone the =git= repository then start an =Emacs= that will use this.  For
example that could be, using the excellent [[http://emacsformacosx.com/][Emacs For MacOSX]]:

<src>
 $ /Applications/Emacs.app/Contents/MacOS/Emacs -Q -l init.el 
</src>

I hope some readers will find it useful! :)

* 20110223-16:45 desktop-mode and readahead

I'm using [[http://www.gnu.org/software/emacs/manual/html_node/elisp/Desktop-Save-Mode.html#Desktop-Save-Mode][Desktop Save Mode]] so that [[http://www.gnu.org/software/emacs/][Emacs]] knows to open again all the
buffers I've been using.  That goes quite well with how often I start =Emacs=,
that is once a week or once a month.  Now, =M-x ibuffer= last line is as
following:

<src>
    718 buffers         19838205                  668 files, 15 processes
</src>

That means that at startup, =Emacs= will load that many files.  In order not
to have to wait until it's done doing so, I've setup things this way:

<src lang="emacs-lisp">
;; and the session
(setq desktop-restore-eager 20
      desktop-lazy-verbose nil)
(desktop-save-mode 1)
(savehist-mode 1)
</src>

Problem is that it's still slow.  An idea I had was to use the [[https://fedorahosted.org/readahead/browser/README][readahead]]
tool that allows reducing some distributions boot time.  Of course this tool
is not expecting the same file format as =emacs-desktop= uses.  Still,
converting is quite easy is some =awk= magic.  Here's the result:

<src lang="emacs-lisp">
;;; dim-desktop.el --- Dimitri Fontaine
;;
;; Allows to prepare a readahead file list from desktop-save

(require 'desktop)

(defvar dim-desktop-file-readahead-list
  "~/.emacs.desktop.readahead"
  "*Where to save the emacs desktop `readahead` file list")

(defvar dim-desktop-filelist-command
  "gawk -F '[ \"]' '/desktop-.*-buffer/ {getline; if($4) print $4}' %s"
  "Command to run to prepare the readahead file list")

(defun dim-desktop-get-readahead-file-list (&optional filename dir)
  "get the file list for readahead from dekstop file in DIR, or ~"
  (with-temp-file (or filename dim-desktop-file-readahead-list)
    (insert
     (shell-command-to-string
      (format dim-desktop-filelist-command
	      (expand-file-name desktop-base-file-name (or dir "~")))))))

;; This will not work because the hook is run before to add the buffers into
;; the desktop file.
;;
;;(add-hook 'desktop-save-hook 'dim-desktop-get-readahead-file-list)

;; so instead, advise the function
(defadvice desktop-save (after desktop-save-readahead activate)
  "Prepare a readahead(8) file for the desktop file"
  (dim-desktop-get-readahead-file-list))

(provide 'dim-desktop)
</src>

The =awk= construct =getline= allows to process the next line of the input file,
which is very practical here (and in a host of other situations).  Now that
we have a file containing the list of files =Emacs= will load, we have to
tweak the system to =readahead= those disk blocks.  As I'm currently using [[http://kde.org/][KDE]]
again, I've done it thusly:

<src lang="bash">
% cat ~/.kde/Autostart/readahead.emacs.sh
#! /bin/bash

# just readahead the emacs desktop files
# this file listing is maintained directly from Emacs itself
readahead ~/.emacs.desktop.readahead
</src>

So, well, it works.  The files that =Emacs= will need are pre-read, so at the
time the desktop really gets to them, I see no more disk activity (laptops
have a led to see that happening).  But the desktop loading time has not
changed...

* 20110111-16:20 Starting afresh with el-get

It so happens that a colleague of mine wanted to start using [[http://www.gnu.org/software/emacs/][Emacs]] but
couldn't get to it. He insists on having proper color themes in all
applications and some sensible defaults full of nifty add-ons everywhere,
and didn't want to have to learn that much about *Emacs* and *Emacs Lisp* to get
started. I'm not even sure that he will [[http://www.gnu.org/software/emacs/tour/][Take the Emacs tour]].

You would tell me that there's nothing we can do for so unfriendly
users. Well, here's what I did:

<src lang="emacs-lisp">
;; emacs setup

(add-to-list 'load-path "~/.emacs.d/el-get/el-get")
(require 'el-get)
(setq
 el-get-sources 
 '(el-get
   php-mode-improved
   psvn
   auto-complete
   switch-window

   (:name buffer-move
	  :after (lambda ()
		   (global-set-key (kbd "<C-S-up>")     'buf-move-up)
		   (global-set-key (kbd "<C-S-down>")   'buf-move-down)
		   (global-set-key (kbd "<C-S-left>")   'buf-move-left)
		   (global-set-key (kbd "<C-S-right>")  'buf-move-right)))

   (:name magit
	  :after (lambda ()
		   (global-set-key (kbd "C-x C-z") 'magit-status)))

   (:name goto-last-change
	  :after (lambda ()
		   ;; azerty keyboard here, don't use C-x C-/
		   (global-set-key (kbd "C-x C-_") 'goto-last-change)))))

(when window-system
   (add-to-list 'el-get-sources  'color-theme-tango))

(el-get 'sync)

;; visual settings
(setq inhibit-splash-screen t)
(menu-bar-mode -1)
(tool-bar-mode -1)
(scroll-bar-mode -1)

(line-number-mode 1)
(column-number-mode 1)

;; Use the clipboard, pretty please, so that copy/paste "works"
(setq x-select-enable-clipboard t)

(set-frame-font "Monospace-10")

(global-hl-line-mode)

;; suivre les changements exterieurs sur les fichiers
(global-auto-revert-mode 1)

;; pour les couleurs dans M-x shell
(autoload 'ansi-color-for-comint-mode-on "ansi-color" nil t)
(add-hook 'shell-mode-hook 'ansi-color-for-comint-mode-on)

;; S-fleches pour changer de fenêtre
(windmove-default-keybindings)
(setq windmove-wrap-around t)

;; find-file-at-point quand ça a du sens
(setq ffap-machine-p-known 'accept) ; no pinging
(setq ffap-url-regexp nil) ; disable URL features in ffap
(setq ffap-ftp-regexp nil) ; disable FTP features in ffap
(define-key global-map (kbd "C-x C-f") 'find-file-at-point)

(require 'ibuffer)
(global-set-key "\C-x\C-b" 'ibuffer)

;; use iswitchb-mode for C-x b
(iswitchb-mode)

;; I can't remember having meant to use C-z as suspend-frame
(global-set-key (kbd "C-z") 'undo)

;; winner-mode pour revenir sur le layout précédent C-c <left>
(winner-mode 1)

;; dired-x pour C-x C-j
(require 'dired-x)

;; full screen
(defun fullscreen ()
  (interactive)
  (set-frame-parameter nil 'fullscreen
		       (if (frame-parameter nil 'fullscreen) nil 'fullboth)))
(global-set-key [f11] 'fullscreen)
</src>

With just this simple 87 lines (all included) of setup, my local user is
very happy to switch to using [[http://www.gnu.org/software/emacs/][our favorite editor]]. And he's not even afraid
(yet) of his =~/.emacs=. I say that's a very good sign of where we are with
[[https://github.com/dimitri/el-get][el-get]]!

* 20101220-16:45 el-get 1.1, with 174 recipes

Yes, you read it well, [[https://github.com/dimitri/el-get][el-get]] currently *features* =174= [[https://github.com/dimitri/el-get/tree/master/recipes][recipes]], and is now
reaching the =1.1= release. The reason for this release is mainly that I have
two big chunks of code to review and the current code has been very stable
for awhile. It seems better to do a release with the stable code that exists
now before to shake it this much. If you're wondering when to jump in the
water and switch to using *el-get*, now is a pretty good time.

** New source types

We now have support for the [[http://www.archlinux.org/pacman/][pacman]] package management for [[http://www.archlinux.org/][archlinux]], and a
way to handle a different package name in the recipe and in the
distribution. We also have support for [[http://mercurial.selenic.com/][mercurial]] and [[http://subversion.tigris.org/][subversion]] and [[http://darcs.net/][darcs]].

Also, [[http://wiki.debian.org/Apt][apt-get]] will sometime prompt you to validate its choices, that's the
infamous *Do you want to continue?* prompt. We now handle that smoothly.

** (el-get 'sync)

In =1.1=, that really means *synchronous*. That means we install one package
after the other, and any error will stop it all. Before that, it was an
active wait loop over a parallel install: this option is still available
through calling =(el-get 'wait)=.

** No more *failed to install*

Exactly. This error you may have encountered sometime is due to trying to
install a package over a previous failed install attempt (network outage,
disk full, bad work-in-progress recipe, etc). After awhile in the field it
was clear that no case where found where you would regret it if [[https://github.com/dimitri/el-get][el-get]] just
did removed the previous failed installation for you before to go and
install again, as aked. So that's now automatic.

** Featuring an overhauled :build facility

The =build= commands can now either be a list, as before, or some that we
*evaluate* for you. That allows for easier to maintain *recipes*, and here's an
exemple of that:

<src lang="emacs-lisp">
(:name distel
       :type svn
       :url "http://distel.googlecode.com/svn/trunk/"
       :info "doc"
       :build `,(mapcar
                 (lambda (target)
                   (concat "make " target " EMACS=" el-get-emacs))
                 '("clean" "all"))
       :load-path ("elisp")
       :features distel)
</src>

As you see that also allows for maintainance of multi-platform build
recipes, and multiple emacs versions too. It's still a little too much on
the *awkward* side of things, though, and that's one of the ongoing work that
will happen for next version.

** Misc improvements

We are now able to =byte-compile= your packages, and offer some more hooks
(=el-get-init-hooks= has been asked with a nice usage example). There's a new
=:localname= property that allows to pick where to save the local file when
using =HTTP= method for retrieval, and that in turn allows to fix some
*recipes*.

<src lang="emacs-lisp">
(:name xcscope
       :type http
       :url "http://cscope.cvs.sourceforge.net/viewvc/cscope/cscope/contrib/xcscope/xcscope.el?revision=1.14&content-type=text%2Fplain"
       :localname "xscope.el"
       :features xcscope)
</src>

Oh and you even get =:before= user function support, even if needing it often
shows that you're doing it in a strange way. More often than not it's
possible to do all you need to in the =:after= function, but this tool is
there so that you spend less time on having a working environment, not more,
right? :)

** Switch notice

All in all, if you're already using [[https://github.com/dimitri/el-get][el-get]] you should consider switching to
=1.1= (by issuing =M-x el-get-update= of course), and if you're hesitating, just
join the fun now!

* 20101007-13:30 el-get reaches 1.0

It's been a week since the last commits in the [[http://github.com/dimitri/el-get][el-get repository]], and those
were all about fixing and adding recipes, and about notifications. Nothing
like *core plumbing* you see. Also, =0.9= was released on *2010-08-24* and felt
pretty complete already, then received lots of improvements. It's high time
to cross the line and call it =1.0=!

Now existing users will certainly just be moderatly happy to see the tool
reach that version number, depending whether they think more about the bugs
they want to see fixed (ftp is supported, only called http) and the new
features they want to see in (*info* documentation) or more about what =el-get=
does for them already today...

For the new users, or the yet-to-be-convinced users, let's take some time
and talk about =el-get=. A *FAQ* like session might be best.

** How is el-get different from ELPA?

[[http://tromey.com/elpa/][ELPA]] is the *Emacs Lisp Package Archive* and is also known as =package.el=, to
be included in Emacs 24. This allows emacs list extension authors to *package*
their work. That means they have to follow some guidelines and format their
contribution, then propose it for upload.

This requires licence checks (good) and for the [[http://elpa.gnu.org/][new official ELPA mirror]] it
even requires dead-tree papers exchange and contracts and copyright
assignments, I believe.

** Why have both?

While *ELPA* is a great thing to have, it's so easy to find some high quality
Emacs extension out there that are not part of the offer. Either authors are
not interrested into uploading to ELPA, or they don't know how to properly
*package* for it (it's only simple for single file extensions, see).

So =el-get= is a pragmatic answer here. It's there because it so happens that
I don't depend only on emacs extensions that are available with Emacs
itself, in my distribution =site-lisp= and in =ELPA=. I need some more, and I
don't need it to be complex to find it, fetch it, init it and use it.

Of course I could try and package any extension I find I need and submit it
to =ELPA=, but really, to do that nicely I'd need to contact the extension
author (*upstream*) for him to accept my patch, and then consider a fork.

With =el-get= I propose distributed packaging if you will. Let's have a look
at two *recipes* here. First, the =el-get= one itself:

<src lang="emacs-lisp">
(:name el-get
       :type git
       :url "git://github.com/dimitri/el-get.git"
       :features el-get
       :compile "el-get.el")
</src>

Then a much more complex one, the [[http://bbdb.sourceforge.net/][bbdb]] one:

<src lang="emacs-lisp">
(:name bbdb
       :type git
       :url "git://github.com/barak/BBDB.git"
       :load-path ("./lisp" "./bits")
       :build ("./configure" "make autoloads" "make")
       :build/darwin ("./configure --with-emacs=/Applications/Emacs.app/Contents/MacOS/Emacs" "make autoloads" "make")
       :features bbdb
       :after (lambda () (bbdb-initialize))
       :info "texinfo")
</src>

The idea is that it's much simpler to just come up with a recipe like this
than to patch existing code and upload it to =ELPA=. And anybody can share
their *recipes* very easily, with or without proposing them to me, even if I
very much like to add some more in the official =el-get= list.

As a user, you don't even need to twiddle with recipes, mostly, because we
already have them for you. What you do instead is list them in
=el-get-sources=.

** So, show me how you use it?

Yeah, sure. Here's a sample of my =dim-packages.el= file, part of my =.emacs=
*suite*. Yeah a single =.emacs= does not suit me anymore, it's a complete
=.emacs.d= now, but that's because that's how I like it organised, you
know. So, here's the example:

<src lang="emacs-lisp">
;;; dim-packages.el --- Dimitri Fontaine
;;
;; Set el-get-sources and call el-get to init all those packages we need.
(require 'el-get)
(add-to-list 'el-get-recipe-path "~/dev/emacs/el-get/recipes")

(setq el-get-sources
      '(cssh el-get switch-window vkill google-maps yasnippet verbiste mailq sicp

	(:name magit
	       :after (lambda () (global-set-key (kbd "C-x C-z") 'magit-status)))

	(:name asciidoc
	       :type elpa
	       :after (lambda ()
			(autoload 'doc-mode "doc-mode" nil t)
			(add-to-list 'auto-mode-alist '("\\.adoc$" . doc-mode))
			(add-hook 'doc-mode-hook '(lambda ()
						    (turn-on-auto-fill)
						    (require 'asciidoc)))))

	(:name goto-last-change
	       :after (lambda ()
			(global-set-key (kbd "C-x C-/") 'goto-last-change)))

	(:name auto-dictionary :type elpa)
	(:name gist            :type elpa)
	(:name lisppaste       :type elpa)))

(el-get) ; that could/should be (el-get 'sync)
(provide 'dim-packages)
</src>

Ok that's not all of it, but it should give you a nice idea about what
problem I solve with =el-get= and how. In my emacs startup sequence, somewhere
inside my =~/.emacs.d/init.el= file, I have a line that says =(require
'dim-packages)=. This will set =el-get-sources= to the list just above, then
call =(el-get)=, the main function.

This main function will check each given package and install it if necessary
(including *build* the package, as in =make autoloads; make=), then *init*
it. What *init* means exactly depends on what the recipe says. That can
include *byte-compiling* some files, caring about *load-path*, *load* and *require*
commands, caring about *Info-directory-list* and =ginstall-info= too, and some
more.

So in short, it will make it so that your emacs instance is ready for you to
use. And you get the choice to use the given =el-get= recipes as-is, like I
did for =cssh=, =el-get=, =switch-window= and others, up to =sicp=, or to tweak them
partly, like in the =magit= example where I've added a user init function (the
=:after= property) to bind =magit-status= to =C-x C-z= here. You can even embed a
full recipe inline in the =el-get-sources= variable, that's the case for each
item that gives its =:type= property, like =asciidoc= or =gist=.

And, as you see, we're using =ELPA= a lot in this sources, so =el-get= isn't
striving to replace it at all, it's just trying to accomodate to a broader
world.

** I read that the el-get-install is asynchronous, tell me more.

Yeah, right, the example above says =(el-get)= at its end, and in the cases
when =el-get= has to install or build sources, this will be done
asynchronously. Which means that not only several sources will get processed
at once (using your multi cores, yeah) but that it will let emacs start up
as if it was ready.

It happens that's usually what I want, because I seldom add sources in my
setup, but in theory that can break your emacs. What I do is start it again
or fix by hand, what you can do instead is =(el-get 'sync)= so that emacs is
blocked waiting for =el-get= to properly install and initialize all the
sources you've setup. Your choice, just add the ='sync= parameter there.

** Now, explain me why it is better this way, again, please?

Well, before I wrote =el-get=, trying out a new extension, setting it up etc
was something quite involved, and that I had to redo on several
machines. The only way not to redo it was to include the extension's code
into my own =git= repository (my =emacs.d= is in =git=, of course).

And putting code I don't maintain into my own =git= repository is something I
frown upon. I have no business pretending I'll maintain the code, and I know
I will never think to check the =URL= where I've found it for updates. That's
when I though noting down the =URL= somewhere.

Also, what about sharing the extension with friends. Uneasy, at best.

Enters =el-get= and I can just add an entry to =el-get-sources=, based on a file
somewhere in my own =el-get-recipe-path=. When I'm happy with this file, I can
contribute it to =el-get= proper or just send it over to any interested
recipient. Adding it to your sources is easy. Copy the file in your
=el-get-recipe-path= somewhere, add its name to your =el-get-sources=, then =M-x
el-get-install= it. Done. If you were given the =:after= function, it's all
setup already.

If you contribute the recipe to =el-get=, then =M-x el-get-update RET el-get
RET= and you get it on this other machine where you also use Emacs. Or you
can tell your friend to do the same and benefit from your *packaging*.

** Well, sounds good. What recipes do you have already?

I count =67= of them already. One of them is just a book in *info* format, with
no *elisp* at all, can you spot it?

<src lang="emacs-lisp">
ELISP> (directory-files "~/dev/emacs/el-get/recipes/" nil "el$")

("auctex.el" "auto-complete-etags.el" "auto-complete-extension.el"
"auto-complete.el" "auto-install.el" "autopair.el" "bbdb.el"
"blender-python-mode.el" "color-theme-twilight.el" "color-theme.el"
"cssh.el" "django-mode.el" "el-get.el" "emacs-w3m.el" "emacschrome.el"
"emms.el" "ensime.el" "erc-highlight-nicknames.el" "erc-track-score.el"
"escreen.el" "filladapt.el" "flyguess.el" "gist.el" "google-maps.el"
"google-weather.el" "goto-last-change.el" "haskell-mode.el"
"highlight-parentheses.el" "hl-sexp.el" "levenshtein.el" "magit.el"
"mailq.el" "maxframe.el" "multi-term.el" "muse-blog.el" "nognus.el"
"nterm.el" "nxhtml.el" "offlineimap.el" "package.el" "popup-kill-ring.el"
"pos-tip.el" "pov-mode.el" "psvn.el" "pymacs.el" "rainbow-mode.el"
"rcirc-groups.el" "rinari.el" "ropemacs.el" "rt-liberation.el" "scratch.el"
"session.el" "sicp.el" "smex.el" "switch-window.el" "textile-mode.el"
"todochiku.el" "twitter.el" "twittering-mode.el" "undo-tree.el"
"verbiste.el" "vimpulse-surround.el" "vimpulse.el" "vkill.el" "xcscope.el"
"xml-rpc-el.el" "yasnippet.el")
</src>

** Ok, I want to try it, what's next?

Visit the following =URL= [[http://github.com/dimitri/el-get]] and follow the
install instructions. You're given a *scratch installer* there, that's some
*elisp* code you copy paste into =*scratch*= then execute there, and you have
=el-get= ready to serve.

An excellent idea I stole at =ELPA=!

** Hey, I already know what el-get is, what's new in 1.0?

The *changelog* is quite full of good stuff, really:

 - Implement el-get recipes so that el-get-sources can be a simple list
   of symbols. Now that there's an authoritative git repository, where
   to share the recipes is easy.

 - Add support for emacswiki directly, save from having to enter the URL

 - Implement package status on-disk saving so that installing over a
   previously failed install is in theory possible. Currently `el-get'
   will refrain from removing your package automatically, though.

 - Fix ELPA remove method, adding a "removed" state too.

 - Implement CVS login support.

 - Add lots of recipes

 - Add support for `system-type' specific build commands

 - Byte compile files from the load-path entries or :compile files

 - Implement support for git submodules with the command
   `git submodule update --init --recursive`

 - Add catch-all post-install and post-update hooks

 - Add desktop notification on install/update.

** I'm still using the deprecated emacswiki version, what now?

That version didn't have recipes, and the new version should be perfectly
happy with your current =el-get-sources=, so that I recommend using the
*scratch installer* too. Don't forget to add =el-get= itself into your
=el-get-sources= list, of course!

* 20100923-14:30 Postfix sender_dependent_relayhost_maps

The previous article about [[http://tapoueh.org/articles/news/_Scratch_that_itch:_M-x_mailq.html][M-x mailq]] has raised several mails asking me
details about the [[http://www.postfix.com/][Postfix]] setup I'm talking about. The problem we're trying
to solve is having a local =MTA= to send mails, so that any old-style Unix
tool just works, instead of only the =MUA= you've spent time setting up.

Postfix makes it possible to do that quite easily, but it gets a little more
involved if you have more than one *relayhost* that you want to use depending
on your current *From* address. Think personal email against work email, or
avoiding your =ISP= network when sending your private mails, *hoping* directly
on a server you own or trust.

So how do you do just that? Let's see the relevant parts of =main.cf=.

<src>
relayhost = your.default.relay.host.here
relay_domains = domain.org, work-domain.com, other-domain.info
smtp_sender_dependent_authentication = yes
sender_dependent_relayhost_maps = hash:/etc/postfix/relaymap
</src>

The =relaymap= looks like this:

<src lang="conf-unix">
# comments
user@domain.org         mail.domain.org
local@work-domain.com   smtp.work-domain.com
# that requires a local tunnel started with ssh, see ~/.ssh/config
me@other-domain.info    [127.0.0.1]:10025
</src>

You need to use [[http://www.postfix.org/postmap.1.html][postmap]] on this file before to reload or restart your local
instance of Postfix.

Also, you should want to crypt your communication to your preferred relay
host, using =TLS= goes like this:

<src>
smtp_sasl_auth_enable=yes
smtp_sasl_password_maps=hash:/etc/postfix/sasl-passwords
smtp_sasl_mechanism_filter = digest-md5
smtp_sasl_security_options = noanonymous
smtp_sasl_mechanism_filter = login, plain
smtp_sasl_type = cyrus

smtp_tls_session_cache_database = btree:${queue_directory}/smtp_scache
smtp_tls_loglevel = 2
smtp_use_tls = yes
smtp_tls_security_level = may
</src>

The password file will need to get parsed by =postmap= too, and would better
be set with limited read access, and looks like this:

<src lang="conf-unix">
mail.domain.org        user@domain.org:password
smtp.work-domain.com   local@work-domain.com:h4ckm3
[127.0.0.1]:10025      me@other-domain.info:guess
</src>

Hope this help you get started, at least that's a document I would have
enjoyed reading when I first started to setup my local relaying =MTA=.

Oh, and now that you have this, I hope you will enjoy my =M-x mailq= tool for
occasions when you're wondering why you're not receiving an answer back yet,
then start the ssh tunnel…

* 20100923-09:30 Scratch that itch: M-x mailq

Nowadays, most people would think that email is something simple, you just
setup your preferred client (that's called a =MUA=) with some information such
as the =smtp= host you want it to talk to (that's call a =MTA= and this one is
your =relayhost=). Then there's all the receiving mails part, and that's =smtp=
again on the server side. Then there's how to get those mail, read them,
flag them, manage them, and that's better served by =IMAP=. Let's talk about
sending mails in =smtp= for this entry.

The traditional way to handle mail sending is to have your own =MTA= on each
system you use — there used to be a *sysadmin* team caring about all those
systems, but we're lost in the personal computer era now — that only means
***you*** are the sysadmin. So about any Unix tool that wants to send a mail will
do so with the command =/usr/bin/sendmail= to queue the outgoing message.

My typical *workstation* setup includes a full-blown =MTA= (my choice is
[[http://www.postfix.com/][Postfix]]) that will choose the next relay host depending on the message *From*
field: I don't want to trust any local default relayhost. Note that the next
relay is connected to with authentication and over an encrypted protocol.

<quote>
We're getting there, really. But I don't know a better way to present a
software, little as it be, other than talking about the need that leads to
its development.
</quote>

Some relaying I do atop an =ssh= tunnel, and it happens that I send mail and
have forgotten about setting up the aforementioned tunnel. In this case, the
advantage is that it will not block my =MUA= ([[http://gnus.org/][gnus]], in quite good shape those
days, receiving lots of love), as the queueing happens as usual. The
drawback is that [[http://www.postfix.com/][Postfix]] will *silently* queue the mail until it's able to
deliver it, which can take days.

Enters =M-x mailq=! Ok, I could be doing =M-! mailq= and see *Mail queue is empty*
in the message area, but then as soon as the queue's not empty I need to
resort to some *shell* or *terminal* in order to *flush* the queue — that's after
setting up the tunnel, as easy as <code>C-= remote</code> in my case, see
[[http://github.com/dimitri/cssh][cssh]]. Scratching that itch, I now only have to hit =f= here, to flush the
queue. And from the *gnus* =*Group*= and =*Summary*= buffers, it's =M-q= to see the
mail queue.

Thanks to [[http://forum.ubuntu-fr.org/viewtopic.php?id=218883]] here's a visual
sample of the =mailq= mode, where you see the mail queue in colors and the
*keymap* you're offered.

	    [[../images/mailq-el.png]]

So you could even *flush* only a given =queue id= or a given =site=, or just *kill*
the current =id= or the current =site= so that it's a =C-y= away. I hope it's
useful for you too — oh, and it's already in the [[http://github.com/dimitri/el-get][el-get]] recipes, of course!

* 20100913-17:45 switch-window reaches 0.8

I wanted to play with the idea of using the whole keyboard for my
[[http://github.com/dimitri/switch-window][switch-window]] utility, but wondered how to get those keys in the right order
and all. Finally found =quail-keyboard-layout= which seems to exists for such
uses, as you can see:

<src lang="emacs-lisp">
ELISP> (loop with layout = (split-string quail-keyboard-layout "") 
         for row from 1 to 4
         collect (loop for col from 1 to 12
                       collect (nth (+ 1 (* 2 col) (* 30 row)) layout)))
(("1" "2" "3" "4" "5" "6" "7" "8" "9" "0" "-" "=")
 ("q" "w" "e" "r" "t" "y" "u" "i" "o" "p" "[" "]")
 ("a" "s" "d" "f" "g" "h" "j" "k" "l" ";" "'" "\\")
 ("z" "x" "c" "v" "b" "n" "m" "," "." "/" " " " "))
</src>

So now =switch-window= will use that (but only the first =10= letters) instead
of *hard-coding* numbers from 1 to 9 as labels and direct switches. That makes
it more suitable to [[http://github.com/dimitri/cssh][cssh]] users too, I guess.

In other news, I think [[http://github.com/dimitri/el-get][el-get]] is about ready for its =1.0= release. Please
test it and report any problem very soon before the release!

* 20100831-14:15 Want to share your recipes?

Yes, that's another [[http://github.com/dimitri/el-get/][el-get]] related entry. It seems to take a lot of my
attention these days. After having setup the =git= repository so that you can
update =el-get= from within itself (so that it's *self-contained*), the next
logical step is providing *recipes*.

By that I mean that =el-get-sources= entries will certainly look a lot alike
between a user and another. Let's take the =el-get= entry itself:

<src lang="emacs-lisp">
(:name el-get
       :type git
       :url "git://github.com/dimitri/el-get.git"
       :features "el-get")
</src>

I guess all =el-get= users will have just the same 4 lines in their
=el-get-sources=. So let's call that a *recipe*, and have =el-get= look for yours
into the =el-get-recipe-path= directories. A recipe is found looking in those
directories in order, and must be named =package.el=. Now, =el-get= already
contains a handful of them, as you can see:

<src lang="emacs-lisp">
ELISP> (directory-files "~/dev/emacs/el-get/recipes/" nil "[^.]$")
("auctex.el" "bbdb.el" "cssh.el" "el-get.el" "emms.el" "erc-track-score.el"
 "escreen.el" "google-maps.el" "haskell-mode.el" "hl-sexp.el" "magit.el"
 "muse-blog.el" "nxhtml.el" "psvn.el" "rainbow-mode.el" "rcirc-groups.el"
 "vkill.el" "xcscope.el" "xml-rpc-el.el" "yasnippet.el")
</src>

Please note that you can have your own local recipes by adding directories
to =el-get-recipe-path=. So now your minimalistic =el-get-sources= list will
look like ='(el-get cssh screen)=, say. And if you want to override a recipe,
for instance to use the default one but still have a personal =:after=
function containing your own setup, then simply have your =el-get-source=
entry a partial entry. Missing =:type= and =el-get= will merge your local
overrides atop the default one.

Finally, the way to share your recipes is by sending me an email with the
file, or to do the same over the =github= interface, I guess I'll still
receive a mail then.

* 20100827-14:15 welcome el-get scratch installer

A very good remark from some users: installing and managing =el-get= should be
simpler. They wanted both an easy install of the thing, and a way to be able
to manage it afterwards (like, update the local copy against the
authoritative source). So I decided it was high time for getting the code
out of my =~/.emacs.d= git repository and up to a public place:
[[http://github.com/dimitri/el-get]].

Then, I added some documentation (a =README=), and then, a =*scratch*
installer=, following great ideas from =ELPA=. So have at it, it's a copy paste
away! 

Don't forget to setup your =el-get-sources= and include there the =el-get=
source for updates, there's nothing magic about it so it's up to you. You
may notice that it's not yet possible to init =el-get= from =el-get-sources=,
though, that's the drawback of the lack of magic. So you will have to still
add an explicit =(require 'el-get)= before to go and define you own
=el-get-sources= then finally =(el-get)=. I don't think that's a problem I need
to solve, though.


* 20100826-16:30 el-get news

I've been receiving some requests for [[http://www.emacswiki.org/emacs/el-get.el][el-get]], some of them even included a
patch. So now there's support for =bzr=, =CSV= and =http-tar=, augmenting the
existing support for =git=, =git-svn=, =apt-get=, =fink= and =ELPA= formats.

Also, as the =install= and even the =build= are completely *asynchronous* —
there's a pending bugfix for the building, which is now using
[[http://www.gnu.org/software/emacs/elisp/html_node/Asynchronous-Processes.html][start-process-shell-command]]. The advantage of doing so is that you're free
to use Emacs as usual while =el-get= is having your piece of =elisp= code
compiled, which can take time.

The drawback is that it's uneasy to to do the associated setup at the right
time without support from =el-get=, so you have the new option =:after= which
takes a =functionp= object: please consider using that to give your own
special setup for the external emacs bits and pieces you're using.

Let's see some examples of the new features:

<src lang="emacs-lisp">
  (:name xml-rpc-el
	 :type bzr
	 :url "lp:xml-rpc-el")

  (:name haskell-mode
	 :type http-tar
	 :options ("xzf")
	 :url "http://projects.haskell.org/haskellmode-emacs/haskell-mode-2.8.0.tar.gz"
	 :load "haskell-site-file.el"
	 :after (lambda ()
		  (add-hook 'haskell-mode-hook 'turn-on-haskell-doc-mode)
		  (add-hook 'haskell-mode-hook 'turn-on-haskell-indentation)))

  (:name auctex
	 :type cvs
	 :module "auctex"
	 :url ":pserver:anonymous@cvs.sv.gnu.org:/sources/auctex"
	 :build ("./autogen.sh" "./configure" "make")
	 :load  ("auctex.el" "preview/preview-latex.el")
	 :info "doc")
</src>

As you can see, there are also the new options =:module= (only used by =CVS= so
far) and =:options= (only used by =http-tar= so far). With this later method,
the =:options= key allows you to have support for virtually any kind of =tar=
compression (=.tar.bz2=, etc). 

The =CVS= support currently does not include authentication against the
anonymous =pserver=, because the only repository I've been asked support for
isn't using that, and the couple of servers that I know of are either
wanting no password at the prompt, or a dummy one. That's for another day,
if needed at all.

That pushes the little local hack to more than a thousand lines of =elisp=
code, and the next steps include proposing it to [[http://tromey.com/elpa/][ELPA]] so that getting to use
it is easier than ever. You'd just have to choose whether to install =ELPA=
from =el-get= or the other way around.

* 20100809-15:35 el-get and dim-switch-window status update

Thanks to you readers of [[http://planet.emacsen.org/][Planet Emacsen]] taking the time to try those pieces
of emacs lisp found in my blog, and also the time to comment on them, some
bugs have been fixed, and new releases appeared.

[[http://tapoueh.org/projects.html#sec20][el-get]] had some typo kind of bug in its support for =apt-get= and =fink=
packages, and I managed to break the =elpa= and =http= support when going *all
asynchronous* by forgetting to update the call convention I'm using. Fixing
that, I also switched to using =url-retrieve= so that the =http= support also is
*asynchronous*. That makes the version =0.5=, available on [[http://www.emacswiki.org/emacs/el-get.el][emacswiki el-get]]
page.

Meanwhile [[http://tapoueh.org/projects.html#sec19][dim-switch-window.el]] got some testers too and got updated with a
nice fix, or so I think. If you're using it with a small enough emacs frame,
or some very little windows in there, you'd have noticed that the number get
so big they don't fit anymore, and all you see while it's waiting for your
window number choice is... blank windows. Not very helpful. Thanks to the
following piece of code, that's no longer the case as of the current
version, available on [[http://www.emacswiki.org/emacs/switch-window.el][emacswiki switch-window]] page.

In short, where I used to blindly apply =dim:switch-window-increase= on the
big numbers to display, the code now checks that there's enough room for it
to get there, and adjust the *increase* level scaling it down if
necessary. Very simple, and effective too:

<src lang="emacs-lisp">
    (with-current-buffer buf
      (text-scale-increase 
       (if (> (/ (float (window-body-height win)) 
		 dim:switch-window-increase)
	      1)
	   dim:switch-window-increase
	 (window-body-height win)))
      (insert "\n\n    " (number-to-string num)))
</src>

Centering the text in the window's width is another story entirely, as the
=text-scale-increase= ain't linear on this axis. I'd take any good idea,
here's what I'm currently at, but it's not there yet:

<src lang="emacs-lisp">
    (with-current-buffer buf
      (let* ((w (window-width win))
	     (h (window-body-height win))
	     (increased-lines (/ (float h) dim:switch-window-increase))
	     (scale (if (> increased-lines 1) dim:switch-window-increase h))
	     (lines-before (/ increased-lines 2))
	     (margin-left (/ w h) ))
	;; increase to maximum dim:switch-window-increase
	(text-scale-increase scale)
	;; make it so that the hyuge number appears centered
	(dotimes (i lines-before) (insert "\n"))
	(dotimes (i margin-left)  (insert " "))
	(insert (number-to-string num))))
</src>

So, if you're using one or the other (both?) of those utilities, update your
local version of them!

Note: I also fixed a but in [[http://github.com/dimitri/rcirc-groups][rcirc-groups]] this week-end, but I'll talk about
it in another entry, if I may.

* 20100804-22:30 el-get

I've been using emacs for a long time, and a long time it took me to
consider learning [[http://www.gnu.org/software/emacs/emacs-lisp-intro/html_node/index.html][Emacs Lisp]]. Before that, I didn't trust my level of
understanding enough to be comfortable in managing my setup efficiently.

One of the main problems of setting up [[http://www.gnu.org/software/emacs/][Emacs]] is that not only you tend to
accumulate so many tricks from [[http://www.emacswiki.org/][EmacsWiki]] and [[http://planet.emacsen.org/][blog posts]] that your =.emacs= has
to grow to a full =~/.emacs.d/= directory (starting at =~/.emacs.d/init.el=),
but also you finally depend on several *librairies* of code you're not
authoring nor maintaining. Let's call them *packages*.

Some of them will typically be available on [[http://tromey.com/elpa/index.html][ELPA]], which allows you to
breathe and keep cool. But most of them, let's face it, are not there. Most
of the packages I use I tend to get them either from [[http://www.debian.org/][debian]] (see
[[http://packages.debian.org/sid/apt-rdepends][apt-rdepends]] for having the complete list of packages that depends on emacs,
unfortunately I'm not finding an online version of the tool to link too), or
from =ELPA=, or from their own =git= repository somewhere. Some of them even I
get directly from an [[http://www.splode.com/~friedman/software/emacs-lisp][obscure website]] not maintained anymore, but always
there when you need them.

Of course, my emacs setup is managed in a private =git= repository. Some
people on =#emacs= are using [[http://www.kernel.org/pub/software/scm/git/docs/git-submodule.html][git submodules]] (or was it straight *import*) for
managing external repositories in there, but all I can say is that I frown
on this idea. I want an easy canonical list of packages I depend on to run
emacs, and I want this documentation to be usable as-is. Enters [[http://www.emacswiki.org/emacs/el-get.el][el-get]]!

As we're all damn lazy, here's a *visual* introduction to =el-get=:

<src lang="emacs-lisp">
(setq el-get-sources
      '((:name bbdb
	       :type git
	       :url "git://github.com/barak/BBDB.git"
	       :load-path ("./lisp" "./bits")
	       :info "texinfo"
	       :build ("./configure" "make"))
	
	(:name magit
	       :type git
	       :url "http://github.com/philjackson/magit.git"
	       :info "."
	       :build ("./autogen.sh" "./configure" "make"))
	
	(:name vkill
	       :type http
	       :url "http://www.splode.com/~friedman/software/emacs-lisp/src/vkill.el"
	       :features vkill)
	
	(:name yasnippet
	       :type git-svn
	       :url "http://yasnippet.googlecode.com/svn/trunk/")
	
	(:name asciidoc         :type elpa)
	(:name dictionary-el    :type apt-get)
	(:name emacs-goodies-el :type apt-get)))

(el-get)
</src>

So now you have a pretty good documentation of the packages you want
installed, where to get them, and how to install them. For the *advanced*
methods (such as =elpa= or =apt-get=), you basically just need the package
name. When relying on a bare =git= repository, you need to give some more
information, such as the =URL= to *clone* and the =build= steps if any. Then also
what *features* to =require= and maybe where to find the *texinfo* documentation
of the package, for automatic inclusion into your local *Info* menu.

The good news is that not only you now have a solid readable description of
all that in a central place, but this very description is all =(el-get)= needs
to do its magic. This command will check that each and every package is
installed on your system (in =el-get-dir=) and if that's not the case, it will
actually install it. Then, it will =init= the packages: that means caring
about the =load-path=, the =Info-directory-list= (and *dir* texinfo menu
building), the *loading* of the =emacs-lisp= files, and finally it will =require=
the *features*.

Here's a prettyfied =ielm= session that will serve as a demo:

<src lang="emacs-lisp">
ELISP> (el-get)
("aspell-en" "aspell-fr" "muse" "dictionary" "htmlize" "bbdb" "google-maps"
"magit" "emms" "nxhtml" "vkill" "xcscope" "yasnippet" "asciidoc"
"auto-dictionary" "css-mode" "gist" "lua-mode" "lisppaste") 
</src>

All the packages being already installed, it's running fast enough that I
won't bother measuring the run time, that seems to be somewhere around one
second.


* 20100726-11:55 dim-switch-window.el: fixes

Thanks to amazing readers of [[http://planet.emacsen.org/][planet emacsen]], two annoyances of
[[http://www.emacswiki.org/emacs/switch-window.el][switch-window.el]] have already been fixed! The first is that handling of =C-g=
isn't exactly an option after all, and the other is that you want to avoid
the buffer creation in the simple cases (1 or 2 windows only), because it's
the usual case.

I've received code to handle the second case, that I mostly merged. Thanks a
lot guys, the new version is on [[http://wwww.emacswiki.org][emacswiki]] already!

* 20100725-13:25 dim-switch-window.el

So it's Sunday and I'm thinking I'll get into =el-get= sometime later. Now is
the time to present =dim-switch-window.el= which implements a *visual* =C-x o=. I
know of only one way to present a *visual effect*, and that's with a screenshot:

	    [[../images/emacs-switch-window.png]]

So as you can see, it's all about showing a *big* number in each window,
tweaking each window's name, and waiting till the user press one of the
expected key — or timeout and stay on the same window as before =C-x o=. When
there's only 1 or 2 windows displayed, though, the right thing happen and
you see no huge number (in the former case, nothing happens, in the latter,
focus moves to the other window).

The code for that can be found on [[http://www.emacswiki.org/][emacswiki]] under the name
[[http://www.emacswiki.org/emacs/switch-window.el][switch-window.el]]. Hope you'll find it useful!


* 20100723-22:20 ClusterSSH gets `dsh' support

If you don't know about [[cssh.html][ClusterSSH]], it's a project that builds on =M-x term=
and =ssh= to offer a nice and simple way to open remote terminals. It's
available in [[http://tromey.com/elpa/index.html][ELPA]] and developed at [[http://github.com/dimitri/cssh][github cssh]] repository.

The default binding is <code>C-=</code> and asks for the name of the server
to connect to, in the *minibuffer*, with completion. The host list used for
the completion comes from =tramp= and is pretty complete, all the more if
you've setup =~/.ssh/config= with =HashKnownHosts no=.

So the usual way to use =cssh.el= would be to just open a single remote
connection at a time. But of course you can open as many as you like, and
you get them all in a mosaic of =term= in your emacs frame, with an input
window at the bottom to control them all. There were two ways to get there,
either opening all remote hosts whose name is matching a given regexp, that
would be using <code>C-M-=</code> or getting to =IBuffer= and marking there
the existing remote =terms= you want to control all at once then use
<code>C-=</code>.

Well I've just added another mode of operation by supporting *enhanced* [[http://www.netfort.gr.jp/~dancer/software/dsh.html.en][dsh]]
group files. In such files, you're supposed to have a remote host name per
line and that's it. We've added support for line containing =@group= kind of
lines so that you can *include* another group easily. To use the facility,
either open your =~/.dsh/group= directory in =dired= and type <code>C-=</code>
when on the right line, or simply use the global <code>C-=</code> you
already know and love. Then, type =@= and complete to any existing group found
in your =cssh-dsh-path= (it defaults to the right places, so chances are you
will never have to edit this one). And that's it, [[http://www.gnu.org/software/emacs/][Emacs]] will open one =term=
per remote host you have in the =dsh= group you just picked. With a =*cssh*=
controler window, too.

Coming next, how I solved my =init.el= dependancies burden thanks to =el-get=!

* 20100304-13:33 Emacs Muse hacking

Now you know what piece of software is used to publish this blog. I really
like it, the major mode makes it a great experience to be using this tool,
and the fact that you produce the =HTML= and =rsync= it all from within Emacs
(=C-c C-p= then =C-c C-r= with some easy [[http://git.tapoueh.org/?p=tapoueh.org.git;a=blob;f=dim-muse.el;hb=HEAD][elisp code]]) is a big advantage as far
as I'm concerned. No need to resort to =shell= and =Makefile=.

What's new here is that I missed the *one page per article* trend that other
blog software propose, and the blog entries index too. I didn't want to
invest time into hacking Muse itself, that was my excuse for accepting the
situation. But I finally took a deeper look at the [[http://mwolson.org/static/doc/muse/Style-Elements.html#Style-Elements][Emacs Muse Manual]], and
found out about the =:after= and =:final= functions.

Those two function will get run while in the output buffer, the =HTML=
formatted one. With the =:after= function, it's still possible to edit the
buffer content, for example to add a mini index to previous articles,
whereas with the =:final= function the buffer is =read-only= and already written
to disk, so it's to late to edit it. Still it's possible to cut it in pieces
and write a new file per article you find in there.

The code to realize my wishes is [[http://git.tapoueh.org/?p=tapoueh.org.git;a=summary][available]] but has not been edited with
customisation in mind, so to use it you will have to edit some places rather
than just =setq= some =defcustom=. Well, if I have demand, I'll generalize the
code and share it on [[http://www.emacswiki.org/][Emacs Wiki]] and [[http://tromey.com/elpa/][ELPA]]. Meanwhile, happy hacking!

* 20091006-17:23 Emacs Muse based publishing

As you might have noticed, this little blog of mine is not compromising much
and entirely maintained from Emacs. Until today, I had to resort to =term= to
upload my publications, though, as I've been too lazy to hack up the tools
integration for simply doing a single =rsync= command line. That was one time
to many:

<src lang="emacs-lisp">
(defvar dim:muse-rsync-options "-avz"
  "rsync options")

(defvar dim:muse-rsync-source "~/dev/muse/out"
  "local path from where to rsync, with no ending /")

(defvar dim:muse-rsync-target
  "dim@tapoueh.org:/home/www/tapoueh.org/blog.tapoueh.org"
  "Remote URL to use as rsync target, with no ending /")

(defvar dim:muse-rsync-extra-subdirs
  '("../css" "../images" "../pdf")
  "static subdirs to rsync too, path from dim:muse-rsync-source, no ending /")

(defun dim:muse-project-rsync (&optional static)
  "publish tapoueh.org using rsync"
  (interactive "P")
  (let* ((rsync-command (format "rsync %s %s %s" 
				dim:muse-rsync-options
				(concat dim:muse-rsync-source "/")
				(concat dim:muse-rsync-target "/"))))
    (with-current-buffer (get-buffer-create "*muse-rsync*")
      (erase-buffer)
      (insert (concat rsync-command "\n"))
      (message "%s" rsync-command)
      (insert (shell-command-to-string rsync-command))
      (insert "\n")

      (when static
	(dolist (subdir dim:muse-rsync-extra-subdirs)
	  (let ((cmd (format "rsync %s %s %s" 
			     dim:muse-rsync-options
			     (concat dim:muse-rsync-source "/" subdir)
			     dim:muse-rsync-target)))
	    (insert (concat cmd "\n"))
	    (message "%s" cmd)
	    (insert (shell-command-to-string cmd))
	    (insert "\n")))))))

(define-key muse-mode-map (kbd "C-c R") 'dim:muse-project-rsync)
</src>

So now to publish this blog, it's just a =C-c R= away! :)

* 20090924-18:08 Emacs is Twinkling here

So you have a *rolodex* like database in your Emacs, or you have this phone
number in a mail and you want to call it. It happens you have =VoIP= setup and
you're using [[http://www.twinklephone.com/][Twinkle]] to make your calls. Maybe you'll then find this
function useful:

<src lang="emacs-lisp">
(defun twinkle-call-symbol-or-region ()
  "Call the phone number at point (symbol seems good enough), or in region"
  (interactive)
  (shell-command-to-string 
   (format "twinkle --cmd 'call %s'"
	   (replace-regexp-in-string 
	    "[^0-9+]" "" 
	    (if (use-region-p)
		(buffer-substring (region-beginning) (region-end))
	      (thing-at-point 'symbol))))))
</src>

It happens that =symbol= is better than =word= here because some phone numbers
begin with =+=. And some contains =/= or =.= as separators, or some other
variations (spaces) so as the number is easy to read for human eyes. *Twinkle*
will not like this.

* 20090922-23:04 Escreen integration

After having used [[http://www.morishima.net/~naoto/software/elscreen/][elscreen]] for a long time, I'm now a very happy user of
[[http://www.splode.com/~friedman/software/emacs-lisp/#ui][escreen]], which feels much better integrated and allows to have one ring of
recently visited buffers per screen. Which is what you need when using a
*screen* like feature, really.

At first, it seemed so good as not to require any tweaking, but soon enough
I had to adapt it to my workflow. After all that's exactly for being able to
do this that I'm using emacs :)

It began quite simple with things like =M-[= and =M-]= to navigate in screens,
and mouse wheel support to, but then I found that the =C-\ b= list of screens
could also support the =C-\ a runs the command
escreen-get-active-screen-numbers= command by just adding some *emphasis* to
the current escreen in use.

As soon as I had this, and seeing people eyes blinking when working with me
in front of my computer, I wanted to have *escreen* switching display where I
am in the minibuffer. You have to try the mouse wheel navigation to fully
appreciate it I guess. Anyway, here it is:

<src lang="emacs-lisp">
(load "escreen")
(escreen-install)

;; add C-\ l to list screens with emphase for current one
(defun escreen-get-active-screen-numbers-with-emphasis ()
  "what the name says"
  (interactive)
  (let ((escreens (escreen-get-active-screen-numbers))
	(emphased ""))

    (dolist (s escreens)
      (setq emphased
	    (concat emphased (if (= escreen-current-screen-number s)
				 (propertize (number-to-string s)
					     ;;'face 'custom-variable-tag) " ")
					     'face 'info-title-3)
					     ;;'face 'font-lock-warning-face)
					     ;;'face 'secondary-selection)
			       (number-to-string s))
		    " ")))
    (message "escreen: active screens: %s" emphased)))

(global-set-key (kbd "C-\\ l") 'escreen-get-active-screen-numbers-with-emphasis)

(defun dim:escreen-goto-last-screen ()
  (interactive)
  (escreen-goto-last-screen)
  (escreen-get-active-screen-numbers-with-emphasis))

(defun dim:escreen-goto-prev-screen (&optional n)
  (interactive "p")
  (escreen-goto-prev-screen n)
  (escreen-get-active-screen-numbers-with-emphasis))

(defun dim:escreen-goto-next-screen (&optional n)
  (interactive "p")
  (escreen-goto-next-screen n)
  (escreen-get-active-screen-numbers-with-emphasis))

(define-key escreen-map escreen-prefix-char 'dim:escreen-goto-last-screen)

(global-set-key (kbd "M-[") 'dim:escreen-goto-prev-screen)
(global-set-key (kbd "M-]") 'dim:escreen-goto-next-screen)
(global-set-key (kbd "C-\\ DEL") 'dim:escreen-goto-prev-screen)
(global-set-key (kbd "C-\\ SPC") 'dim:escreen-goto-next-screen)

(global-set-key '[s-mouse-4] 'dim:escreen-goto-prev-screen)
(global-set-key '[s-mouse-5] 'dim:escreen-goto-next-screen)
</src>

Oh, and as I'm in the *terms in emacs* part of universe (rather than using
=emacs -nw= in some terminal emulator, but loosing sync between X clipbloard
and emacs selection), I had to add this too:

<src lang="emacs-lisp">
;; add support for C-\ from terms
(require 'term)
(define-key term-raw-map escreen-prefix-char escreen-map)
(define-key term-raw-map (kbd "M-[") 'dim:escreen-goto-prev-screen)
(define-key term-raw-map (kbd "M-]") 'dim:escreen-goto-next-screen)
</src>


* 20090907-12:50 Follow-up on dim:mailrc-add-entry

The function didn't allow for using more than one =mailrc= file, which isn't a
good idea, so I've just added that. Oh and for =gnus= integration what I need
is =(add-hook 'message-mode-hook 'mail-abbrevs-setup)= it seems... so that if
I type the alias it'll get automatically expanded. And to be real lazy and
avoid having to type in the entire alias, =mail-abbrev-complete-alias= to the
rescue, assigned to some easy to reach keys.

<src lang="emacs-lisp">
(require 'message)
(define-key message-mode-map (kbd "C-'") 'mail-abbrev-complete-alias)

(defun dim:mailrc-add-entry (&optional prefix alias)
  "read email at point and add it to an ~/.mailrc file"
  (interactive "P\nMalias: ")
  (let* ((default-mailrc (file-name-nondirectory mail-personal-alias-file))
	 (mailrc (if prefix (expand-file-name
			     (read-file-name 
			      "Add alias into file: " 
			      "~/" 
			      default-mailrc
			      t
			      default-mailrc))
		   mail-personal-alias-file))
	 (address (thing-at-point 'email-address))
	 (buffer (find-file-noselect mailrc t)))
    (when address
      (with-current-buffer buffer
	;; we don't support updating existing alias in the file
	(save-excursion
	  (goto-char (point-min))
	  (if (search-forward (concat "alias " alias) nil t)
	      (error "Alias %s is already present in .mailrc" alias)))

	(save-current-buffer
	  (save-excursion
	    (goto-char (point-max))
	    (insert (format "\nalias %s \"%s <%s>\"" alias (cdr address) (car address)))))))))
</src>

* 20090907-01:29 Improving ~/.mailrc usage

So I've been adviced to use =~/.mailrc= for keeping a basic address book in
Emacs, for use within =gnus= for example. I had to resort to the manual to
find out how to use the file aliases when I need them, that is when
composing a mail. For the record, here's what I had to do:

<src lang="emacs-lisp">
;; mails and aliases
(add-hook 'mail-mode-hook 'mail-abbrevs-setup)
(global-set-key (kbd "C-c @") 'mail-abbrev-insert-alias)
</src>

That means I prefer hitting =C-c @=, then typing the alias in the minibuffer
(with completion) and there after see the full mail address in my
=message-mode= buffer. This looks like it'll change over time, but rather than
searching how to have a nice inline alias completion (=M-tab= maybe, but
already used by the *window manager*), I've tackled the problem of maintaining
the ~/.mailrc file.

Lazy as I am (or I wouldn't be using Emacs this much), having to manually
select the email region in the buffer, open or switch to the =mailrc= buffer
then paste my new entry, not forgetting to format it with =alias foo= prefix
and checking for alias usage while doing so didn't strike me as
appealing. Oh and don't forget to add quote where they belong, too.

Too much work that I wanted to automate. Here we go:

<src lang="emacs-lisp">
;; automate adding mail at point to ~/.mailrc
(defun dim:mailrc-add-entry (alias)
  "read email at point"
  (interactive "Malias: ")
  (let ((address (thing-at-point 'email-address))
	(buffer (find-file-noselect mail-personal-alias-file t)))
    (when address
      (with-current-buffer buffer
	;; we don't support updating existing alias in the file
	(save-excursion
	  (goto-char (point-min))
	  (if (search-forward (concat "alias " alias) nil t)
	      (error "Alias %s is already present in .mailrc" alias)))

	(save-current-buffer
	  (save-excursion
	    (goto-char (point-max))
	    (insert (format "\nalias %s \"%s <%s>\"" alias (cdr address) (car address)))))))))

(global-set-key (kbd "C-c C-@") 'dim:mailrc-add-entry)
</src>

Quite there, you'll notice that I'm using =thing-at-point 'email-address=, and
maybe you already know that =emacs23= does not provide this. It provides
=thing-at-point 'email= which will ignore real name and all. For example,
given a point somewhere inside the right part of =John Doe
<johndoe@email.tld>= the ='email= variant of =thing-at-point= will return
=johndoe@email.tld=. In words of one syllabe: not what I want.

So after searching around for a solution, I saw =mail-header-parse-address=
from the API oriented =mail-parse= librairy, and finaly came up with this dead simple
solution which works fine enough for me:

<src lang="emacs-lisp">
(require 'mail-parse)

(defun thing-at-point-bounds-of-email-address ()
  "return a cons of begin and end position of email address at point, including full name"
  (save-excursion
    (let* ((search-point (point))
	   (start (re-search-backward "[:,]" (line-beginning-position) 'move))
	   (dummy (goto-char search-point))
	   (end   (re-search-forward  "[:,]" (line-end-position) t)))
      (setq start (if start (+ 1 start)
		    (line-beginning-position)))
      (unless end (setq end (line-end-position)))
      (cons start end))))

(defun thing-at-point-email-address ()
  "return full email address at point"
  (let* ((bounds (thing-at-point-bounds-of-email-address))
	 (email-address-text
	  (when bounds (buffer-substring-no-properties (car bounds) (cdr bounds)))))
    (mail-header-parse-address email-address-text)))

(put 'email-address 'bounds-of-thing-at-point 'thing-at-point-bounds-of-email-address)
(put 'email-address 'thing-at-point 'thing-at-point-email-address)
</src>

Now, when I receive a mail and want to store an alias for it, I simply place
point somewhere in the mail then hit =C-c C-@=, and *voilà* my =~/.mailrc= is
uptodate.

Hope it'll be useful for someone else, but at least I'm keeping annotated
history of the files :)

* 20090803-15:15 Some emacs nifties

First, here's a way to insert at current position the last message printed
into the minibuffer... well not exactly, in =*Messages*= buffer in fact. I was
tired of doing it myself after invoking, e.g., =M-x emacs-version=.

<src lang="emacs-lisp">
;; print last message
;; current-message is already lost by the time this gets called
(defun dim:previous-message (&optional nth)
  "get last line of *Message* buffer"
  (with-current-buffer (get-buffer "*Messages*")
    (save-excursion
      (goto-char (point-max))
      (setq nth (if nth nth 1))
      (while (> nth 0)
	(previous-line)
	(setq nth (- nth 1)))
      (buffer-substring (line-beginning-position) (line-end-position)))))

(defun dim:insert-previous-message (&optional nth)
  "insert last message of *Message* to current position"
  (interactive "p")
  (insert (format "%s" (dim:previous-message nth))))

(global-set-key (kbd "C-c m") 'dim:insert-previous-message)
</src>

Now I stumbled accross [[http://planet.emacsen.org/][Planet Emacsen]] and saw this [[http://curiousprogrammer.wordpress.com/2009/07/26/emacs-utility-functions/][Emacs Utility Functions]]
post, containing a version of =duplicate-current-line= that I didn't
like... here's mine:

<src lang="emacs-lisp">
;; duplicate current line
(defun duplicate-current-line (&optional n)
  "duplicate current line, make more than 1 copy given a numeric argument"
  (interactive "p")
  (save-excursion
    (let ((nb (or n 1))
	  (current-line (thing-at-point 'line)))
      ;; when on last line, insert a newline first
      (when (or (= 1 (forward-line 1)) (eq (point) (point-max)))
	(insert "\n"))

      ;; now insert as many time as requested
      (while (> n 0)
	(insert current-line)
	(decf n)))))

(global-set-key (kbd "C-S-d") 'duplicate-current-line)  
</src>

And a last one inspired by some strange =vim= behavior for which I fail to see
a need:

<src lang="emacs-lisp">
;; on request by cyrilb, who missed it from vim
;; no global-set-key yet, still have to think I'll use it someday...
(defun copy-char-from-prev-line ()
  "Copy char at same position on previous line, when such a line and position exists"
  (interactive)
  (let ((c)
	(p (- (point) (line-beginning-position))))
    (save-excursion
      (when (eq 0 (forward-line -1))
	(when (< (+ (point) p) (line-end-position))
	  (forward-char p)
	  (setq c (thing-at-point 'char)))))
    (when c
      (insert c))))
</src>

Next time I'll try to talk about =rcirc-groups= or =cssh= which have managed to
take some of my free time recently.

* Tue,  9 Dec 2008,  0:00 Useful emacs trick

<src lang="emacs-lisp">
(defun insert-date()
  "Insert a time-stamp according to locale's date and time format."
  (interactive)
  (insert (format-time-string "%a, %e %b %Y, %k:%M" (current-time)))) 

(global-set-key "\C-cd" 'insert-date)
</src>

* Mon,  8 Dec 2008, 23:59 Predicting the next 5,000 days of the web

Watch [[http://www.ted.com/index.php/talks/kevin_kelly_on_the_next_5_000_days_of_the_web.html][Kevin Kelly's Talk]] here, it's about trying to predict what the
Internet will look like 5 thousands days from now.

* Mon,  8 Dec 2008, 16:10 emacs-snapshot

If you want to live on the bleeding edge, it's easy enough to get a non
existing release of [[http://www.gnu.org/software/emacs/][GNU Emacs]] under [[http://www.debian.org/releases/unstable/][debian sid]], thanks to
[[http://emacs.orebokech.com/]].

The problem is that [[http://mwolson.org/projects/EmacsMuse.html][Emacs Muse]] is broken on =emacs-snapshot=, partly because
of [[http://www.emacswiki.org/emacs/Htmlize][Htmlize]] which is unable to find the face fonts (I got =(error "Invalid
face")=), partly because of my configuration itself:

<src lang="emacs-lisp">
hunk ./dim-muse.el 22
-      '(("pgsql.tapoueh.org" $
-        (,@(muse-project-alist-dirs "~/dev/muse/site") $
+      '(("pgsql.tapoueh.org" ("~/dev/muse/site"
+        ;;(,@(muse-project-alist-dirs "~/dev/muse/site") $
</src>

The solution was to switch to using =Emacs 22= on sid for [[http://pgsql.tapoueh.org/site/muse/site/][pgsql.tapoueh.org]]
editing, while using [[http://www.emacswiki.org/emacs/?action=browse;oldid=EmacsCVS;id=EmacsFromCVS][EmacsCVS]] for other activities.

And I'm using the patched =Htmlize= on both the versions, by the way.

* December, 6th 2008

A new site, using new software. See [[index.html][Home Page]] to read a rant about it all.

Oh and check out the [[skytools.html][skytools]] page too. [[http://mwolson.org/projects/EmacsMuse.html][Emacs Muse]] is so great a project
that instead of just working on how to publish a website with this tool, I
found myself editing a rather large document about =londite.py=.

* 20081205 Emacs Muse powered blog

So finaly a blogging software for *geeks* exists?

<qotd>
The problem with communication is that you think it happened.
</qotd>
