#author Dimitri Fontaine
#title tail -f /dev/dim
#desc dim's general purpose blog, which might turn into emacs specific

* 20090924-18:08 Emacs is Twinkling here

So you have a *rolodex* like database in your Emacs, or you have this phone
number in a mail and you want to call it. It happens you have =VoIP= setup and
you're using [[http://www.twinklephone.com/][Twinkle]] to make your calls. Maybe you'll then find this
function useful:

<src lang="emacs-lisp">
(defun twinkle-call-symbol-or-region ()
  "Call the phone number at point (symbol seems good enough), or in region"
  (interactive)
  (shell-command-to-string 
   (format "twinkle --cmd 'call %s'"
	   (replace-regexp-in-string 
	    "[^0-9+]" "" 
	    (if (use-region-p)
		(buffer-substring (region-beginning) (region-end))
	      (thing-at-point 'symbol))))))
</src>

It happens that =symbol= is better than =word= here because some phone numbers
begin with =+=. And some contains =/= or =.= as separators, or some other
variations (spaces) so as the number is easy to read for human eyes. *Twinkle*
will not like this.

* 20090922-23:04 Escreen integration

After having used [[http://www.morishima.net/~naoto/software/elscreen/][elscreen]] for a long time, I'm now a very happy user of
[[http://www.splode.com/~friedman/software/emacs-lisp/#ui][escreen]], which feels much better integrated and allows to have one ring of
recently visited buffers per screen. Which is what you need when using a
*screen* like feature, really.

At first, it seemed so good as not to require any tweaking, but soon enough
I had to adapt it to my workflow. After all that's exactly for being able to
do this that I'm using emacs :)

It began quite simple with things like =M-[= and =M-]= to navigate in screens,
and mouse wheel support to, but then I found that the =C-\ b= list of screens
could also support the =C-\ a runs the command
escreen-get-active-screen-numbers= command by just adding some *emphasis* to
the current escreen in use.

As soon as I had this, and seeing people eyes blinking when working with me
in front of my computer, I wanted to have *escreen* switching display where I
am in the minibuffer. You have to try the mouse wheel navigation to fully
appreciate it I guess. Anyway, here it is:

<src lang="emacs-lisp">
(load "escreen")
(escreen-install)

;; add C-\ l to list screens with emphase for current one
(defun escreen-get-active-screen-numbers-with-emphasis ()
  "what the name says"
  (interactive)
  (let ((escreens (escreen-get-active-screen-numbers))
	(emphased ""))

    (dolist (s escreens)
      (setq emphased
	    (concat emphased (if (= escreen-current-screen-number s)
				 (propertize (number-to-string s)
					     ;;'face 'custom-variable-tag) " ")
					     'face 'info-title-3)
					     ;;'face 'font-lock-warning-face)
					     ;;'face 'secondary-selection)
			       (number-to-string s))
		    " ")))
    (message "escreen: active screens: %s" emphased)))

(global-set-key (kbd "C-\\ l") 'escreen-get-active-screen-numbers-with-emphasis)

(defun dim:escreen-goto-last-screen ()
  (interactive)
  (escreen-goto-last-screen)
  (escreen-get-active-screen-numbers-with-emphasis))

(defun dim:escreen-goto-prev-screen (&optional n)
  (interactive "p")
  (escreen-goto-prev-screen n)
  (escreen-get-active-screen-numbers-with-emphasis))

(defun dim:escreen-goto-next-screen (&optional n)
  (interactive "p")
  (escreen-goto-next-screen n)
  (escreen-get-active-screen-numbers-with-emphasis))

(define-key escreen-map escreen-prefix-char 'dim:escreen-goto-last-screen)

(global-set-key (kbd "M-[") 'dim:escreen-goto-prev-screen)
(global-set-key (kbd "M-]") 'dim:escreen-goto-next-screen)
(global-set-key (kbd "C-\\ DEL") 'dim:escreen-goto-prev-screen)
(global-set-key (kbd "C-\\ SPC") 'dim:escreen-goto-next-screen)

(global-set-key '[s-mouse-4] 'dim:escreen-goto-prev-screen)
(global-set-key '[s-mouse-5] 'dim:escreen-goto-next-screen)
</src>

Oh, and as I'm in the *terms in emacs* part of universe (rather than using
=emacs -nw= in some terminal emulator, but loosing sync between X clipbloard
and emacs selection), I had to add this too:

<src lang="emacs-lisp">
;; add support for C-\ from terms
(require 'term)
(define-key term-raw-map escreen-prefix-char escreen-map)
(define-key term-raw-map (kbd "M-[") 'dim:escreen-goto-prev-screen)
(define-key term-raw-map (kbd "M-]") 'dim:escreen-goto-next-screen)
</src>


* 20090907-12:50 Follow-up on dim:mailrc-add-entry

The function didn't allow for using more than one =mailrc= file, which isn't a
good idea, so I've just added that. Oh and for =gnus= integration what I need
is =(add-hook 'message-mode-hook 'mail-abbrevs-setup)= it seems... so that if
I type the alias it'll get automatically expanded. And to be real lazy and
avoid having to type in the entire alias, =mail-abbrev-complete-alias= to the
rescue, assigned to some easy to reach keys.

<src lang="emacs-lisp">
(require 'message)
(define-key message-mode-map (kbd "C-'") 'mail-abbrev-complete-alias)

(defun dim:mailrc-add-entry (&optional prefix alias)
  "read email at point and add it to an ~/.mailrc file"
  (interactive "P\nMalias: ")
  (let* ((default-mailrc (file-name-nondirectory mail-personal-alias-file))
	 (mailrc (if prefix (expand-file-name
			     (read-file-name 
			      "Add alias into file: " 
			      "~/" 
			      default-mailrc
			      t
			      default-mailrc))
		   mail-personal-alias-file))
	 (address (thing-at-point 'email-address))
	 (buffer (find-file-noselect mailrc t)))
    (when address
      (with-current-buffer buffer
	;; we don't support updating existing alias in the file
	(save-excursion
	  (goto-char (point-min))
	  (if (search-forward (concat "alias " alias) nil t)
	      (error "Alias %s is already present in .mailrc" alias)))

	(save-current-buffer
	  (save-excursion
	    (goto-char (point-max))
	    (insert (format "\nalias %s \"%s <%s>\"" alias (cdr address) (car address)))))))))
</src>

* 20090907-01:29 Improving ~/.mailrc usage

So I've been adviced to use =~/.mailrc= for keeping a basic address book in
Emacs, for use within =gnus= for example. I had to resort to the manual to
find out how to use the file aliases when I need them, that is when
composing a mail. For the record, here's what I had to do:

<src lang="emacs-lisp">
;; mails and aliases
(add-hook 'mail-mode-hook 'mail-abbrevs-setup)
(global-set-key (kbd "C-c @") 'mail-abbrev-insert-alias)
</src>

That means I prefer hitting =C-c @=, then typing the alias in the minibuffer
(with completion) and there after see the full mail address in my
=message-mode= buffer. This looks like it'll change over time, but rather than
searching how to have a nice inline alias completion (=M-tab= maybe, but
already used by the *window manager*), I've tackled the problem of maintaining
the ~/.mailrc file.

Lazy as I am (or I wouldn't be using Emacs this much), having to manually
select the email region in the buffer, open or switch to the =mailrc= buffer
then paste my new entry, not forgetting to format it with =alias foo= prefix
and checking for alias usage while doing so didn't strike me as
appealing. Oh and don't forget to add quote where they belong, too.

Too much work that I wanted to automate. Here we go:

<src lang="emacs-lisp">
;; automate adding mail at point to ~/.mailrc
(defun dim:mailrc-add-entry (alias)
  "read email at point"
  (interactive "Malias: ")
  (let ((address (thing-at-point 'email-address))
	(buffer (find-file-noselect mail-personal-alias-file t)))
    (when address
      (with-current-buffer buffer
	;; we don't support updating existing alias in the file
	(save-excursion
	  (goto-char (point-min))
	  (if (search-forward (concat "alias " alias) nil t)
	      (error "Alias %s is already present in .mailrc" alias)))

	(save-current-buffer
	  (save-excursion
	    (goto-char (point-max))
	    (insert (format "\nalias %s \"%s <%s>\"" alias (cdr address) (car address)))))))))

(global-set-key (kbd "C-c C-@") 'dim:mailrc-add-entry)
</src>

Quite there, you'll notice that I'm using =thing-at-point 'email-address=, and
maybe you already know that =emacs23= does not provide this. It provides
=thing-at-point 'email= which will ignore real name and all. For example,
given a point somewhere inside the right part of =John Doe
<johndoe@email.tld>= the ='email= variant of =thing-at-point= will return
=johndoe@email.tld=. In words of one syllabe: not what I want.

So after searching around for a solution, I saw =mail-header-parse-address=
from the API oriented =mail-parse= librairy, and finaly came up with this dead simple
solution which works fine enough for me:

<src lang="emacs-lisp">
(require 'mail-parse)

(defun thing-at-point-bounds-of-email-address ()
  "return a cons of begin and end position of email address at point, including full name"
  (save-excursion
    (let* ((search-point (point))
	   (start (re-search-backward "[:,]" (line-beginning-position) 'move))
	   (dummy (goto-char search-point))
	   (end   (re-search-forward  "[:,]" (line-end-position) t)))
      (setq start (if start (+ 1 start)
		    (line-beginning-position)))
      (unless end (setq end (line-end-position)))
      (cons start end))))

(defun thing-at-point-email-address ()
  "return full email address at point"
  (let* ((bounds (thing-at-point-bounds-of-email-address))
	 (email-address-text
	  (when bounds (buffer-substring-no-properties (car bounds) (cdr bounds)))))
    (mail-header-parse-address email-address-text)))

(put 'email-address 'bounds-of-thing-at-point 'thing-at-point-bounds-of-email-address)
(put 'email-address 'thing-at-point 'thing-at-point-email-address)
</src>

Now, when I receive a mail and want to store an alias for it, I simply place
point somewhere in the mail then hit =C-c C-@=, and *voil√†* my =~/.mailrc= is
uptodate.

Hope it'll be useful for someone else, but at least I'm keeping annotated
history of the files :)

* 20090803-15:15 Some emacs nifties

First, here's a way to insert at current position the last message printed
into the minibuffer... well not exactly, in =*Messages*= buffer in fact. I was
tired of doing it myself after invoking, e.g., =M-x emacs-version=.

<src lang="emacs-lisp">
;; print last message
;; current-message is already lost by the time this gets called
(defun dim:previous-message (&optional nth)
  "get last line of *Message* buffer"
  (with-current-buffer (get-buffer "*Messages*")
    (save-excursion
      (goto-char (point-max))
      (setq nth (if nth nth 1))
      (while (> nth 0)
	(previous-line)
	(setq nth (- nth 1)))
      (buffer-substring (line-beginning-position) (line-end-position)))))

(defun dim:insert-previous-message (&optional nth)
  "insert last message of *Message* to current position"
  (interactive "p")
  (insert (format "%s" (dim:previous-message nth))))

(global-set-key (kbd "C-c m") 'dim:insert-previous-message)
</src>

Now I stumbled accross [[http://planet.emacsen.org/][Planet Emacsen]] and saw this [[http://curiousprogrammer.wordpress.com/2009/07/26/emacs-utility-functions/][Emacs Utility Functions]]
post, containing a version of =duplicate-current-line= that I didn't
like... here's mine:

<src lang="emacs-lisp">
;; duplicate current line
(defun duplicate-current-line (&optional n)
  "duplicate current line, make more than 1 copy given a numeric argument"
  (interactive "p")
  (save-excursion
    (let ((nb (or n 1))
	  (current-line (thing-at-point 'line)))
      ;; when on last line, insert a newline first
      (when (or (= 1 (forward-line 1)) (eq (point) (point-max)))
	(insert "\n"))

      ;; now insert as many time as requested
      (while (> n 0)
	(insert current-line)
	(decf n)))))

(global-set-key (kbd "C-S-d") 'duplicate-current-line)  
</src>

And a last one inspired by some strange =vim= behavior for which I fail to see
a need:

<src lang="emacs-lisp">
;; on request by cyrilb, who missed it from vim
;; no global-set-key yet, still have to think I'll use it someday...
(defun copy-char-from-prev-line ()
  "Copy char at same position on previous line, when such a line and position exists"
  (interactive)
  (let ((c)
	(p (- (point) (line-beginning-position))))
    (save-excursion
      (when (eq 0 (forward-line -1))
	(when (< (+ (point) p) (line-end-position))
	  (forward-char p)
	  (setq c (thing-at-point 'char)))))
    (when c
      (insert c))))
</src>

Next time I'll try to talk about =rcirc-groups= or =cssh= which have managed to
take some of my free time recently.

* Tue,  9 Dec 2008,  0:00 Useful emacs trick

<src lang="emacs-lisp">
(defun insert-date()
  "Insert a time-stamp according to locale's date and time format."
  (interactive)
  (insert (format-time-string "%a, %e %b %Y, %k:%M" (current-time)))) 

(global-set-key "\C-cd" 'insert-date)
</src>

* Mon,  8 Dec 2008, 23:59 Predicting the next 5,000 days of the web

Watch [[http://www.ted.com/index.php/talks/kevin_kelly_on_the_next_5_000_days_of_the_web.html][Kevin Kelly's Talk]] here, it's about trying to predict what the
Internet will look like 5 thousands days from now.

* Mon,  8 Dec 2008, 16:10 emacs-snapshot

If you want to live on the bleeding edge, it's easy enough to get a non
existing release of [[http://www.gnu.org/software/emacs/][GNU Emacs]] under [[http://www.debian.org/releases/unstable/][debian sid]], thanks to
[[http://emacs.orebokech.com/]].

The problem is that [[http://mwolson.org/projects/EmacsMuse.html][Emacs Muse]] is broken on =emacs-snapshot=, partly because
of [[http://www.emacswiki.org/emacs/Htmlize][Htmlize]] which is unable to find the face fonts (I got =(error "Invalid
face")=), partly because of my configuration itself:

<src lang="emacs-lisp">
hunk ./dim-muse.el 22
-      '(("pgsql.tapoueh.org" $
-        (,@(muse-project-alist-dirs "~/dev/muse/site") $
+      '(("pgsql.tapoueh.org" ("~/dev/muse/site"
+        ;;(,@(muse-project-alist-dirs "~/dev/muse/site") $
</src>

The solution was to switch to using =Emacs 22= on sid for [[http://pgsql.tapoueh.org/site/muse/site/][pgsql.tapoueh.org]]
editing, while using [[http://www.emacswiki.org/emacs/?action=browse;oldid=EmacsCVS;id=EmacsFromCVS][EmacsCVS]] for other activities.

And I'm using the patched =Htmlize= on both the versions, by the way.

* December, 6th 2008

A new site, using new software. See [[index.html][Home Page]] to read a rant about it all.

Oh and check out the [[skytools.html][skytools]] page too. [[http://mwolson.org/projects/EmacsMuse.html][Emacs Muse]] is so great a project
that instead of just working on how to publish a website with this tool, I
found myself editing a rather large document about =londite.py=.

* 20081205 Emacs Muse powered blog

So finaly a blogging software for *geeks* exists?

<qotd>
The problem with communication is that you think it happened.
</qotd>
