

  
    
  


  




  


  

<!DOCTYPE html>
<html lang="en-us">
  <head>
    
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="Hugo 0.50">
    <meta name="theme" content="Tranquilpeak 0.3.1-BETA">
    <title>PostgreSQL LISTEN/NOTIFY</title>
    <meta name="author" content="Dimitri Fontaine">
    <meta name="keywords" content="">

    <link rel="icon" href="/favicon.ico">
    

    
    <meta name="description" content="This article fits in the PostgreSQL Concurrency series,
where we installed a tweeter like application schema and had all the
characters from Shakespeare&rsquo;s A Midsummer Night&rsquo;s Dream tweet their own
lines in our database in PostgreSQL Concurrency: Data Modification
Language.

A previous article in the series covered how to manage concurrent retweets
in an efficient way: Computing and
Caching, where we learn how to
maintain a cache right in your PostgreSQL database, thanks for materialized
views.

Today&rsquo;s article shows how to maintain an external cache in another
application layer. In this article we are going to maintain an in-memory
cache in a Golang service, using PostgreSQL
LISTEN and
NOTIFY
features.">
    <meta property="og:description" content="This article fits in the PostgreSQL Concurrency series,
where we installed a tweeter like application schema and had all the
characters from Shakespeare&rsquo;s A Midsummer Night&rsquo;s Dream tweet their own
lines in our database in PostgreSQL Concurrency: Data Modification
Language.

A previous article in the series covered how to manage concurrent retweets
in an efficient way: Computing and
Caching, where we learn how to
maintain a cache right in your PostgreSQL database, thanks for materialized
views.

Today&rsquo;s article shows how to maintain an external cache in another
application layer. In this article we are going to maintain an in-memory
cache in a Golang service, using PostgreSQL
LISTEN and
NOTIFY
features.">
    <meta property="og:type" content="blog">
    <meta property="og:title" content="PostgreSQL LISTEN/NOTIFY">
    <meta property="og:url" content="/blog/2018/07/postgresql-listen-notify/">
    <meta property="og:site_name" content="The Art of PostgreSQL">
    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="PostgreSQL LISTEN/NOTIFY">
    <meta name="twitter:description" content="This article fits in the PostgreSQL Concurrency series,
where we installed a tweeter like application schema and had all the
characters from Shakespeare&rsquo;s A Midsummer Night&rsquo;s Dream tweet their own
lines in our database in PostgreSQL Concurrency: Data Modification
Language.

A previous article in the series covered how to manage concurrent retweets
in an efficient way: Computing and
Caching, where we learn how to
maintain a cache right in your PostgreSQL database, thanks for materialized
views.

Today&rsquo;s article shows how to maintain an external cache in another
application layer. In this article we are going to maintain an in-memory
cache in a Golang service, using PostgreSQL
LISTEN and
NOTIFY
features.">
    
      <meta name="twitter:creator" content="@tapoueh">
    
    

    
    

    
      <meta property="og:image" content="//www.gravatar.com/avatar/7b615d104c506aa0a49e17151fa94d9f?s=640">
    

    
      <meta property="og:image" content="https://tapoueh.org/img/siren_alarm_bell_signal_alert-512.png">
    
    
      <meta property="og:image" content="https://tapoueh.org/img/elephant.png">
    
    

    

    
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" />
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/fancybox/2.1.4/jquery.fancybox.css" />
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/fancybox/2.1.4/helpers/jquery.fancybox-thumbs.min.css" />
    
    
    <link rel="stylesheet" href="/css/style-jsjn0006wyhpyzivf6yceb31gvpjatbcs3qzjvlumobfnugccvobqwxnnaj8.min.css" />
    
    
      <link rel="stylesheet" href="https://tapoueh.org/css/dim.css">
    
      <link rel="stylesheet" href="https://tapoueh.org/css/nav.css">
    

    
      
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-47059482-1', 'auto');
	
	ga('send', 'pageview');
}
</script>

    
    
  </head>

  <body>
    <div id="blog">
      <header id="header" data-behavior="5">
  <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
  <div class="navbar-collapse collapse header-title" id="navigation">
    <ul class="nav navbar-nav navbar-right">
      
      <li class="dropdown">
        
        <a style="color: black;" href="/" alt="blog"><i class="sidebar-button-icon fa fa-lg fa-home"></i></a>
        
      </li>
      
      <li class="dropdown">
        
        <a style="color: black;" href="/conf/" alt="talks"><i class="sidebar-button-icon fa fa-lg fa-microphone"></i></a>
        
      </li>
      
      <li class="dropdown">
        
        <a style="color: black;" href="https://twitter.com/tapoueh" alt="Twitter"><i class="sidebar-button-icon fa fa-lg fa-twitter"></i></a>
        
      </li>
      
      <li class="dropdown">
        
        <a style="color: black;" href="http://theartofpostgresql.com" alt="The Art Of PostgreSQL"><i class="sidebar-button-icon fa fa-lg fa-book"></i></a>
        
      </li>
      
    </ul>
  </div>

  
    
      <a class="header-right-icon "
         href="https://theartofpostgresql.com/" target="_blank">
    
    
      <i class="fa fa-lg fa-book"></i>
    
    
    </a>
  
</header>

      <nav id="sidebar" data-behavior="5">
  <div class="sidebar-container">
    
      <div class="sidebar-profile">
        <a href="/#about">
          <img class="sidebar-profile-picture" src="//www.gravatar.com/avatar/7b615d104c506aa0a49e17151fa94d9f?s=110" alt="" />
        </a>
        <h4 class="sidebar-profile-name">Dimitri Fontaine</h4>
        
          <h5 class="sidebar-profile-bio">PostgreSQL Major Contributor</h5>
        
      </div>
    
    <ul class="sidebar-buttons">
      
  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="/">
    
      <i class="sidebar-button-icon fa fa-lg fa-pagelines"></i>
      
      <span class="sidebar-button-desc">Blog</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="/about/">
    
      <i class="sidebar-button-icon fa fa-lg fa-beer"></i>
      
      <span class="sidebar-button-desc">About</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="/categories/yesql/">
    
      <i class="sidebar-button-icon fa fa-lg fa-database"></i>
      
      <span class="sidebar-button-desc">YeSQL</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="http://masteringpostgresql.com" target="_blank" rel="noopener">
    
      <i class="sidebar-button-icon fa fa-lg fa-book"></i>
      
      <span class="sidebar-button-desc">Mastering PostgreSQL</span>
    </a>
  </li>


    </ul>
    <ul class="sidebar-buttons">
      
  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://github.com/dimitri" target="_blank" rel="noopener">
    
      <i class="sidebar-button-icon fa fa-lg fa-github"></i>
      
      <span class="sidebar-button-desc">GitHub</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://twitter.com/tapoueh" target="_blank" rel="noopener">
    
      <i class="sidebar-button-icon fa fa-lg fa-twitter"></i>
      
      <span class="sidebar-button-desc">Twitter</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="/categories">
    
      <i class="sidebar-button-icon fa fa-lg fa-bookmark"></i>
      
      <span class="sidebar-button-desc">Categories</span>
    </a>
  </li>


    </ul>
    <ul class="sidebar-buttons">
      
  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="/index.xml">
    
      <i class="sidebar-button-icon fa fa-lg fa-rss"></i>
      
      <span class="sidebar-button-desc">RSS</span>
    </a>
  </li>


    </ul>
  </div>
</nav>

      
  <div class="post-header-cover
              text-left
              post-header-cover--partial"
       style="background-image:url('/img/elephant.png')"
       data-behavior="5">
    
      <div class="post-header main-content-wrap text-left">
  
    <h1 class="post-title" itemprop="headline">
      PostgreSQL LISTEN/NOTIFY
    </h1>
  
  
  <div class="postShorten-meta post-meta">
    
      <time itemprop="datePublished" datetime="2018-07-19T12:58:21&#43;02:00">
        <span style="float: left; width: 35%">
          <i class="fa fa-calendar"></i> 
  
  
  
  
    Thursday 19 Jul 2018
  

        </span>
      </time>
    
    <span style="float: right; width: 65%">
      <i class="fa fa-clock-o"></i> 15 mins read
      
    </span>
    <span style="float: left; width: 35%">
      <i class="fa fa-bookmark"></i> 
  
  
    <span></span>
    
      <a class="category-link" href="/categories/postgresql">PostgreSQL</a>, 
    
      <a class="category-link" href="/categories/yesql">YeSQL</a>
    
  

    </span>
    <div>
      <p>
        
        
        
        
        
        
        <a href="/tags/concurrency/">
          <i class="fa fa-tag"></i> Concurrency
        </a>
        
        
        
        <a href="/tags/listen/">
          <i class="fa fa-tag"></i> LISTEN
        </a>
        
        
        
        <a href="/tags/notify/">
          <i class="fa fa-tag"></i> NOTIFY
        </a>
        
        
        
        <a href="/tags/golang/">
          <i class="fa fa-tag"></i> GoLang
        </a>
        
        
        
        <a href="/tags/json/">
          <i class="fa fa-tag"></i> JSON
        </a>
        
        
      </p>
    </div>
  </div>


</div>
    
  </div>


      <div id="main" data-behavior="5"
        class="hasCover
               hasCoverMetaIn
               ">
        <article class="post" itemscope itemType="http://schema.org/BlogPosting">
          
          
          <div class="post-content markdown" itemprop="articleBody">
            <div class="main-content-wrap">
              <p>This article fits in the <a href="/tags/concurrency">PostgreSQL Concurrency</a> series,
where we installed a tweeter like application schema and had all the
characters from Shakespeare&rsquo;s <em>A Midsummer Night&rsquo;s Dream</em> tweet their own
lines in our database in <a href="/blog/2018/06/PostgreSQL-DML.md">PostgreSQL Concurrency: Data Modification
Language</a>.</p>

<p>A previous article in the series covered how to manage concurrent retweets
in an efficient way: <a href="/blog/2018/07/computing-and-caching/">Computing and
Caching</a>, where we learn how to
maintain a cache right in your PostgreSQL database, thanks for materialized
views.</p>

<p>Today&rsquo;s article shows how to maintain an <em>external</em> cache in another
application layer. In this article we are going to maintain an in-memory
cache in a Golang service, using PostgreSQL
<a href="https://www.postgresql.org/docs/current/static/sql-listen.html">LISTEN</a> and
<a href="https://www.postgresql.org/docs/current/static/sql-notify.html">NOTIFY</a>
features.</p>

<p>
 




<div class="table-of-contents toc bd-callout">
    
    <h4 class="text-muted">Table of Contents</h4>
    
        
        
            
                
                
                
                    <ul class="toc-h1">
                
                
                
                
                <li>
                  <a href="/blog/2018/07/postgresql-listen-notify/#listen-and-notify">
                    Listen and Notify
                  </a>
                </li>
                
                
                    </ul>
                
            
        
    
        
        
            
                
                
                
                    <ul class="toc-h1">
                
                
                
                
                <li>
                  <a href="/blog/2018/07/postgresql-listen-notify/#postgresql-notifications">
                    PostgreSQL Notifications
                  </a>
                </li>
                
                
                    </ul>
                
            
        
    
        
        
            
                
                
                
                    <ul class="toc-h1">
                
                
                
                
                <li>
                  <a href="/blog/2018/07/postgresql-listen-notify/#postgresql-event-publication-system">
                    PostgreSQL Event Publication System
                  </a>
                </li>
                
                
                    </ul>
                
            
        
    
        
        
            
                
                
                
                    <ul class="toc-h1">
                
                
                
                
                <li>
                  <a href="/blog/2018/07/postgresql-listen-notify/#notifications-and-cache-maintenance">
                    Notifications and Cache Maintenance
                  </a>
                </li>
                
                
                    </ul>
                
            
        
    
        
        
            
                
                
                
                    <ul class="toc-h1">
                
                
                
                
                <li>
                  <a href="/blog/2018/07/postgresql-listen-notify/#limitations-of-listen-and-notify">
                    Limitations of Listen and Notify
                  </a>
                </li>
                
                
                    </ul>
                
            
        
    
        
        
            
                
                
                
                    <ul class="toc-h1">
                
                
                
                
                <li>
                  <a href="/blog/2018/07/postgresql-listen-notify/#listen-and-notify-support-in-drivers">
                    Listen and Notify Support in Drivers
                  </a>
                </li>
                
                
                    </ul>
                
            
        
    
        
        
            
                
                
                
                    <ul class="toc-h1">
                
                
                
                
                <li>
                  <a href="/blog/2018/07/postgresql-listen-notify/#conclusion">
                    Conclusion
                  </a>
                </li>
                
                
                    </ul>
                
            
        
    
</div>

</p>

<h2 id="listen-and-notify">Listen and Notify</h2>

<p>The PostgreSQL protocol includes a streaming protocol with <em>COPY</em> and also
implements asynchronous messages and notifications. This means that as soon
as a connection is established with PostgreSQL, the server can send messages
to the client even when the client is idle.</p>

<h2 id="postgresql-notifications">PostgreSQL Notifications</h2>

<p>Messages that flow from the server to the connected client should be
processed by the client. It could be that the server is being restarted, or
an application message is being delivered.</p>

<p>Here&rsquo;s an example of doing this:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql">yesql# <span style="color:#00a">listen</span> channel;
<span style="color:#00a">LISTEN</span>

yesql# <span style="color:#00a">notify</span> channel, <span style="color:#a50">&#39;foo&#39;</span>;
<span style="color:#00a">NOTIFY</span>
Asynchronous notification <span style="color:#a50">&#34;channel&#34;</span> <span style="color:#00a">with</span> payload <span style="color:#a50">&#34;foo&#34;</span>  <span style="color:#f00;background-color:#faa">⏎</span>
received <span style="color:#00a">from</span> server process <span style="color:#00a">with</span> PID <span style="color:#099">40430</span>.</code></pre></div>
<p>Note that the message could be sent from another connection, so try it and
see with several <em>psql</em> instances. The <em>payload</em> from the message can be any
text, up to 8kB in length. This allows for rich messages to flow, such as
JSON encoded values.</p>

<h2 id="postgresql-event-publication-system">PostgreSQL Event Publication System</h2>

<p>In the <a href="#triggers">Triggers</a> section we saw that in order to maintain a
cache of the action counters either by day or by messageid, we can write a
trigger. This implements event driven processing but kills our concurrency
and scalability properties.</p>

<p>It&rsquo;s possible for our trigger to <em>notify</em> an external client. This client
must be a daemon program, which uses <em>listen</em> to register our messages. Each
time a notification is sent, the daemon program processes it as necessary,
possibly updating our <em>twcache.counters</em> table. As we have a single daemon
program listening to notifications and updating the cache, we now bypass the
concurrency issues.</p>

<p>Before implementing the client application, we can implement the trigger for
notification, and use <em>psql</em> as a testing client:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#00a">begin</span>;

<span style="color:#00a">create</span> <span style="color:#00a">or</span> <span style="color:#00a">replace</span> <span style="color:#00a">function</span> twcache.tg_notify_counters ()
 <span style="color:#00a">returns</span> <span style="color:#00a">trigger</span>
 <span style="color:#00a">language</span> plpgsql
<span style="color:#00a">as</span> <span style="color:#f00;background-color:#faa">$$</span>
<span style="color:#00a">declare</span>
  channel <span style="color:#0aa">text</span> := TG_ARGV[<span style="color:#099">0</span>];
<span style="color:#00a">begin</span>
  PERFORM (
     <span style="color:#00a">with</span> payload(messageid, rts, favs) <span style="color:#00a">as</span>
     (
       <span style="color:#00a">select</span> <span style="color:#00a">NEW</span>.messageid,
              coalesce(
                 <span style="color:#00a">case</span> <span style="color:#00a">NEW</span>.action
                   <span style="color:#00a">when</span> <span style="color:#a50">&#39;rt&#39;</span>    <span style="color:#00a">then</span>  <span style="color:#099">1</span>
                   <span style="color:#00a">when</span> <span style="color:#a50">&#39;de-rt&#39;</span> <span style="color:#00a">then</span> -<span style="color:#099">1</span>
                  <span style="color:#00a">end</span>,
                 <span style="color:#099">0</span>
              ) <span style="color:#00a">as</span> rts,
              coalesce(
                <span style="color:#00a">case</span> <span style="color:#00a">NEW</span>.action
                  <span style="color:#00a">when</span> <span style="color:#a50">&#39;fav&#39;</span>    <span style="color:#00a">then</span>  <span style="color:#099">1</span>
                  <span style="color:#00a">when</span> <span style="color:#a50">&#39;de-fav&#39;</span> <span style="color:#00a">then</span> -<span style="color:#099">1</span>
                 <span style="color:#00a">end</span>,
                <span style="color:#099">0</span>
              ) <span style="color:#00a">as</span> favs
     )
     <span style="color:#00a">select</span> pg_notify(channel, row_to_json(payload)::<span style="color:#0aa">text</span>)
       <span style="color:#00a">from</span> payload
  );
  <span style="color:#00a">RETURN</span> <span style="color:#00a">NULL</span>;
<span style="color:#00a">end</span>;
<span style="color:#f00;background-color:#faa">$$</span>;

<span style="color:#00a">CREATE</span> <span style="color:#00a">TRIGGER</span> notify_counters
         <span style="color:#00a">AFTER</span> <span style="color:#00a">INSERT</span>
            <span style="color:#00a">ON</span> tweet.activity
      <span style="color:#00a">FOR</span> <span style="color:#00a">EACH</span> <span style="color:#00a">ROW</span>
       <span style="color:#00a">EXECUTE</span> <span style="color:#00a">PROCEDURE</span> twcache.tg_notify_counters(<span style="color:#a50">&#39;tweet.activity&#39;</span>);

<span style="color:#00a">commit</span>;</code></pre></div>
<p>Then to test the trigger, we can issue the following statements at a <em>psql</em>
prompt:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-psql" data-lang="psql">listen &#34;tweet.activity&#34;;

insert into tweet.activity(messageid, action)
     values (33, &#39;rt&#39;),
            (33, &#39;rt&#39;),
            (33, &#39;de-rt&#39;),
            (33, &#39;fav&#39;),
            (33, &#39;de-fav&#39;),
            (33, &#39;rt&#39;),
            (33, &#39;fav&#39;);</code></pre></div>
<p>We get then the following output from the console:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-psql" data-lang="psql">INSERT 0 7
Asynchronous notification &#34;tweet.activity&#34; with payload        ⏎
&#34;{&#34;messageid&#34;:33,&#34;rts&#34;:1,&#34;favs&#34;:0}&#34; received from              ⏎
server process with PID 73216.
Asynchronous notification &#34;tweet.activity&#34; with payload        ⏎
&#34;{&#34;messageid&#34;:33,&#34;rts&#34;:-1,&#34;favs&#34;:0}&#34; received from             ⏎
server process with PID 73216.
Asynchronous notification &#34;tweet.activity&#34; with payload        ⏎
&#34;{&#34;messageid&#34;:33,&#34;rts&#34;:0,&#34;favs&#34;:1}&#34; received from              ⏎
server process with PID 73216.
Asynchronous notification &#34;tweet.activity&#34; with payload        ⏎
&#34;{&#34;messageid&#34;:33,&#34;rts&#34;:0,&#34;favs&#34;:-1}&#34; received from             ⏎
server process with PID 73216.</code></pre></div>
<p>So we made seven inserts, and we have four notifications. This behavior
might be surprising, yet it is fully documented on the PostgreSQL manual
page for the
<a href="https://www.postgresql.org/docs/current/static/sql-notify.html">NOTIFY</a>
command:</p>

<blockquote>
<p>If the same channel name is signaled multiple times from the same
transaction with identical payload strings, the database server can decide
to deliver a single notification only. On the other hand, notifications
with distinct payload strings will always be delivered as distinct
notifications. Similarly, notifications from different transactions will
never get folded into one notification. Except for dropping later
instances of duplicate notifications, NOTIFY guarantees that notifications
from the same transaction get delivered in the order they were sent. It is
also guaranteed that messages from different transactions are delivered in
the order in which the transactions committed.</p>
</blockquote>

<p>Our test case isn&rsquo;t very good, so let&rsquo;s write another one, and keep in mind
that our implementation of the cache server with <em>notify</em> can only be
correct if the main application issues only distinct <em>tweet.activity</em>
actions in a single transaction. For our usage, this is not a deal-breaker,
so we can fix our tests.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#00a">insert</span> <span style="color:#00a">into</span> tweet.activity(messageid, action) <span style="color:#00a">values</span> (<span style="color:#099">33</span>, <span style="color:#a50">&#39;rt&#39;</span>);
<span style="color:#00a">insert</span> <span style="color:#00a">into</span> tweet.activity(messageid, action) <span style="color:#00a">values</span> (<span style="color:#099">33</span>, <span style="color:#a50">&#39;de-rt&#39;</span>);
<span style="color:#00a">insert</span> <span style="color:#00a">into</span> tweet.activity(messageid, action) <span style="color:#00a">values</span> (<span style="color:#099">33</span>, <span style="color:#a50">&#39;fav&#39;</span>);
<span style="color:#00a">insert</span> <span style="color:#00a">into</span> tweet.activity(messageid, action) <span style="color:#00a">values</span> (<span style="color:#099">33</span>, <span style="color:#a50">&#39;de-rt&#39;</span>);</code></pre></div>
<p>And this time we get the expected notifications:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-psql" data-lang="psql">Asynchronous notification &#34;tweet.activity&#34; with payload        ⏎
&#34;{&#34;messageid&#34;:33,&#34;rts&#34;:1,&#34;favs&#34;:0}&#34; received from              ⏎
server process with PID 73216.
Asynchronous notification &#34;tweet.activity&#34; with payload        ⏎
&#34;{&#34;messageid&#34;:33,&#34;rts&#34;:-1,&#34;favs&#34;:0}&#34; received from             ⏎
server process with PID 73216.
Asynchronous notification &#34;tweet.activity&#34; with payload        ⏎
&#34;{&#34;messageid&#34;:33,&#34;rts&#34;:0,&#34;favs&#34;:1}&#34; received from              ⏎
server process with PID 73216.
Asynchronous notification &#34;tweet.activity&#34; with payload        ⏎
&#34;{&#34;messageid&#34;:33,&#34;rts&#34;:-1,&#34;favs&#34;:0}&#34; received from             ⏎
server process with PID 73216.</code></pre></div>
<hr />

<figure class="right"><a href="https://theartofpostgresql.com">
    <img src="/img/TAOP_Book_Cover_200x260.png"/> </a>
</figure>


<p>This article is extracted from my book <a href="https://theartofpostgresql.com">The Art of
PostgreSQL</a>, which teaches SQL to developers
so that they may replace thousands of lines of code with very simple
queries. The book has a full chapter about <em>Data Manipulation and
Concurrency Control</em> in PostgreSQL, including caching with materialized
views, check it out!</p>

<hr />

<h2 id="notifications-and-cache-maintenance">Notifications and Cache Maintenance</h2>

<p>Now that we have the basic server-side infrastructure in place, where
PostgreSQL is the server and a backend application the client, we can look
into about maintaining our <em>twcache.counters</em> cache in an event driven
fashion.</p>

<p>PostgreSQL LISTEN and NOTIFY support is perfect for maintaining a cache.
Because notifications are only delivered to client connections that are
listening at the moment of the notify call, our cache maintenance service
must implement the following behavior, in this exact order:</p>

<ol>
<li><p>Connect to the PostgreSQL database we expect notifications from and
 issue the <em>listen</em> command.</p></li>

<li><p>Fetch the current values from their <em>single source of truth</em> and reset
 the cache with those computed values.</p></li>

<li><p>Process notifications as they come and update the in-memory cache, and
 once in a while synchronize the in-memory cache to its materialized
 location, as per the cache invalidation policy.</p></li>
</ol>

<p>The cache service can be implemented within the cache maintenance service.
As an example, a cache server application might both process notifications
and serve the current cache from memory over an HTTP API. The cache service
might also be one of the popular cache solutions such as
<a href="https://memcached.org">Memcached</a> or <a href="https://redis.io">Redis</a>.</p>

<p>In our example, we implement a cache maintenance service in Go and the cache
itself is maintained as a PostgreSQL table:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#00a">begin</span>;

<span style="color:#00a">create</span> <span style="color:#00a">schema</span> <span style="color:#00a">if</span> <span style="color:#00a">not</span> <span style="color:#00a">exists</span> twcache;

<span style="color:#00a">create</span> <span style="color:#00a">table</span> twcache.counters
 (
   messageid   <span style="color:#0aa">bigint</span> <span style="color:#00a">not</span> <span style="color:#00a">null</span> <span style="color:#00a">primary</span> <span style="color:#00a">key</span>,
   rts         <span style="color:#0aa">bigint</span>,
   favs        <span style="color:#0aa">bigint</span>
 );

<span style="color:#00a">commit</span>;</code></pre></div>
<p>With this table, implementing a NOTIFY client service that maintains the
cache is easy enough to do, and here&rsquo;s what happens when the service runs
and we do some testing:</p>

<pre><code>2017/09/21 22:00:36 Connecting to postgres:///yesql?sslmode=disable… 
2017/09/21 22:00:36 Listening to notifications on channel &quot;tweet.activity&quot;
2017/09/21 22:00:37 Cache initialized with 6 entries.
2017/09/21 22:00:37 Start processing notifications, waiting for events…
2017/09/21 22:00:42 Received event: {&quot;messageid&quot;:33,&quot;rts&quot;:1,&quot;favs&quot;:0}
2017/09/21 22:00:42 Received event: {&quot;messageid&quot;:33,&quot;rts&quot;:-1,&quot;favs&quot;:0}
2017/09/21 22:00:42 Received event: {&quot;messageid&quot;:33,&quot;rts&quot;:0,&quot;favs&quot;:1}
2017/09/21 22:00:42 Received event: {&quot;messageid&quot;:33,&quot;rts&quot;:-1,&quot;favs&quot;:0}
2017/09/21 22:00:47 Materializing 6 events from memory
</code></pre>

<p>The client code is written in Go, and is included in full in this article.
One of the main bits of interest is the <em>materialize</em> function, which is an
interesting implementation of pushing the in-memory cache data structure
down to our PostgreSQL table <em>twcache.counters</em>.</p>

<p>The in-memory cache structure looks like the following:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#00a">type</span> Counter <span style="color:#00a">struct</span> {
	MessageId <span style="color:#0aa">int</span> <span style="color:#a50">`json:&#34;messageid&#34;`</span>
	Rts       <span style="color:#0aa">int</span> <span style="color:#a50">`json:&#34;rts&#34;`</span>
	Favs      <span style="color:#0aa">int</span> <span style="color:#a50">`json:&#34;favs&#34;`</span>
}

<span style="color:#00a">type</span> Cache <span style="color:#00a">map</span>[<span style="color:#0aa">int</span>]*Counter</code></pre></div>
<p>And given such a data structure, we use the efficient Go default JSON
marshaling facility to transform the cache elements and pass them all down
to PostgreSQL as a single JSON object.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#00a">func</span> materialize(db *sql.DB, cache Cache) <span style="color:#0aa">error</span> {
    ...
    
	js, err := json.Marshal(cache)

	<span style="color:#00a">if</span> err != <span style="color:#00a">nil</span> {
		log.Printf(<span style="color:#a50">&#34;Error while materializing cache: %s&#34;</span>, err)
		<span style="color:#00a">return</span> err
	}
    
	_, err = db.Query(q, js)
    
    ...
    <span style="color:#00a">return</span> <span style="color:#00a">nil</span>
}</code></pre></div>
<p>The JSON object is then processed in a SQL query, that we find embedded in
the Go code — it&rsquo;s the <em>q</em> string variable that is used in the snippet above
in the expression <em>db.Query(q, js)</em>, where <em>js</em> is the JSON representation
of the entirety of the cache data.</p>

<p>Here&rsquo;s the SQL query we use:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#00a">with</span> rec <span style="color:#00a">as</span>
 (
   <span style="color:#00a">select</span> rec.*
     <span style="color:#00a">from</span> json_each(<span style="color:#f00;background-color:#faa">$</span><span style="color:#099">1</span>) <span style="color:#00a">as</span> t,
          json_populate_record(<span style="color:#00a">null</span>::twcache.counters, value) <span style="color:#00a">as</span> rec
 )
 <span style="color:#00a">insert</span> <span style="color:#00a">into</span> twcache.counters(messageid, rts, favs)
      <span style="color:#00a">select</span> messageid, rts, favs
        <span style="color:#00a">from</span> rec
 <span style="color:#00a">on</span> conflict (messageid)
   <span style="color:#00a">do</span> <span style="color:#00a">update</span>
         <span style="color:#00a">set</span> rts  = counters.rts + excluded.rts,
             favs = counters.favs + excluded.favs
       <span style="color:#00a">where</span> counters.messageid = excluded.messageid</code></pre></div>
<p>In this query, we use the PostgreSQL
<a href="https://www.postgresql.org/docs/9.6/static/functions-json.html#FUNCTIONS-JSON-PROCESSING-TABLE">json_populate_record</a>
function. This function is almost magical and it is described as such in the
documentation:</p>

<blockquote>
<p>Expands the object in from_json to a row whose columns match the record
type defined by base (see note below).</p>

<p>Note: In <em>json_populate_record</em>, <em>json_populate_recordset</em>,
<em>json_to_record</em> and <em>json_to_recordset</em>, type coercion from the JSON is
&ldquo;best effort&rdquo; and may not result in desired values for some types. JSON
keys are matched to identical column names in the target row type. JSON
fields that do not appear in the target row type will be omitted from the
output, and target columns that do not match any JSON field will simply be
NULL.</p>
</blockquote>

<p>The function allows transforming a JSON document into a full-blown
relational tuple to process as usual in PostgreSQL. Here we use an implicit
<em>lateral</em> construct that feeds the <em>json_populate_record()</em> function from
the output of the <em>json_each()</em> function. We could have used the <em>recordset</em>
variant, but we&rsquo;re discarding the Go cache key that repeats the <em>MessageId</em>
here.</p>

<p>Then our SQL query uses the <em>insert into &hellip; select &hellip; on conflict do
update</em> variant that we&rsquo;re used to by now.</p>

<p>So, here&rsquo;s the full Go script we&rsquo;re using here:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#00a">package</span> main

<span style="color:#00a">import</span> (
	<span style="color:#a50">&#34;database/sql&#34;</span>
	<span style="color:#a50">&#34;encoding/json&#34;</span>
	<span style="color:#a50">&#34;flag&#34;</span>
	<span style="color:#a50">&#34;time&#34;</span>
	<span style="color:#a50">&#34;log&#34;</span>
	<span style="color:#a50">&#34;os&#34;</span>

	<span style="color:#a50">&#34;github.com/lib/pq&#34;</span>
)

<span style="color:#00a">type</span> Config <span style="color:#00a">struct</span> {
	PGuri   <span style="color:#0aa">string</span>
	Channel <span style="color:#0aa">string</span>
	Sync    time.Duration
	Idle    time.Duration
}

<span style="color:#00a">type</span> Counter <span style="color:#00a">struct</span> {
	MessageId <span style="color:#0aa">int</span> <span style="color:#a50">`json:&#34;messageid&#34;`</span>
	Rts       <span style="color:#0aa">int</span> <span style="color:#a50">`json:&#34;rts&#34;`</span>
	Favs      <span style="color:#0aa">int</span> <span style="color:#a50">`json:&#34;favs&#34;`</span>
}

<span style="color:#00a">type</span> Cache <span style="color:#00a">map</span>[<span style="color:#0aa">int</span>]*Counter

<span style="color:#00a">const</span> sync_delay = <span style="color:#099">10</span> * time.Second
<span style="color:#00a">const</span> idle_delay = <span style="color:#099">30</span> * time.Second
<span style="color:#00a">const</span> scrn_width = <span style="color:#099">65</span>
<span style="color:#00a">const</span> min_reconn = <span style="color:#099">10</span> * time.Second
<span style="color:#00a">const</span> max_reconn = time.Minute

<span style="color:#00a">func</span> main() {
	conf := processFlags()
	log.SetOutput(os.Stdout)

	log.Printf(<span style="color:#a50">&#34;Connecting to %s… &#34;</span>, conf.PGuri)
	db, err := sql.Open(<span style="color:#a50">&#34;postgres&#34;</span>, conf.PGuri)
	<span style="color:#00a">if</span> err != <span style="color:#00a">nil</span> {
		log.Printf(<span style="color:#a50">&#34;Failed to connect to &#39;%s&#39;: %s&#34;</span>, conf.PGuri, err)
		os.Exit(<span style="color:#099">1</span>)
	}
	<span style="color:#00a">defer</span> db.Close()

	reportErr := <span style="color:#00a">func</span>(ev pq.ListenerEventType, err <span style="color:#0aa">error</span>) {
		<span style="color:#00a">if</span> err != <span style="color:#00a">nil</span> {
			log.Printf(<span style="color:#a50">&#34;Failed to start listener: %s&#34;</span>, err)
			os.Exit(<span style="color:#099">1</span>)
		}
	}

	<span style="color:#aaa;font-style:italic">//
</span><span style="color:#aaa;font-style:italic"></span>	<span style="color:#aaa;font-style:italic">// First, LISTEN to incoming events
</span><span style="color:#aaa;font-style:italic"></span>	<span style="color:#aaa;font-style:italic">//
</span><span style="color:#aaa;font-style:italic"></span>	listener := pq.NewListener(conf.PGuri, min_reconn, max_reconn, reportErr)
	err = listener.Listen(conf.Channel)
	<span style="color:#00a">if</span> err != <span style="color:#00a">nil</span> {
		log.Printf(
			<span style="color:#a50">&#34;Failed to LISTEN to channel &#39;%s&#39;: %s&#34;</span>,
			conf.Channel, err)
		<span style="color:#0aa">panic</span>(err)
	}
	log.Printf(
		<span style="color:#a50">&#34;Listening to notifications on channel \&#34;%s\&#34;&#34;</span>,
		conf.Channel)

	<span style="color:#aaa;font-style:italic">//
</span><span style="color:#aaa;font-style:italic"></span>	<span style="color:#aaa;font-style:italic">// Second, initialize the cache with the current values from the
</span><span style="color:#aaa;font-style:italic"></span>	<span style="color:#aaa;font-style:italic">// base table, only then proceed to process the notifications.
</span><span style="color:#aaa;font-style:italic"></span>	<span style="color:#aaa;font-style:italic">//
</span><span style="color:#aaa;font-style:italic"></span>	cache, err := initCache(db)

	<span style="color:#00a">if</span> err != <span style="color:#00a">nil</span> {
		log.Printf(<span style="color:#a50">&#34;Error initializing cache&#34;</span>)
		<span style="color:#0aa">panic</span>(err)
	}
	log.Printf(
		<span style="color:#a50">&#34;Cache initialized with %d entries.&#34;</span>,
		<span style="color:#0aa">len</span>(cache))

	<span style="color:#aaa;font-style:italic">//
</span><span style="color:#aaa;font-style:italic"></span>	<span style="color:#aaa;font-style:italic">// Third, grab notifications and process them by updating the
</span><span style="color:#aaa;font-style:italic"></span>	<span style="color:#aaa;font-style:italic">// counters that changed.
</span><span style="color:#aaa;font-style:italic"></span>	<span style="color:#aaa;font-style:italic">//
</span><span style="color:#aaa;font-style:italic"></span>	log.Println(<span style="color:#a50">&#34;Start processing notifications, waiting for events…&#34;</span>)

	reset := time.Now()
	<span style="color:#00a">for</span> {
		waitForNotification(listener, cache, conf.Idle)

		<span style="color:#00a">if</span> time.Since(reset) &gt;= conf.Sync {
			err := materialize(db, cache)

			<span style="color:#aaa;font-style:italic">// reset the cache *unless* there was an error!
</span><span style="color:#aaa;font-style:italic"></span>			<span style="color:#00a">if</span> err == <span style="color:#00a">nil</span> {
				cache = <span style="color:#0aa">make</span>(Cache)
				reset = time.Now()
			}
		}
	}
}

<span style="color:#00a">func</span> processFlags() *Config {
	<span style="color:#00a">var</span> conninfo <span style="color:#0aa">string</span> = <span style="color:#a50">&#34;postgres:///yesql?sslmode=disable&#34;</span>
	<span style="color:#00a">var</span> channel <span style="color:#0aa">string</span> = <span style="color:#a50">&#34;tweet.activity&#34;</span>

	syncPtr := flag.Int(<span style="color:#a50">&#34;sync&#34;</span>, <span style="color:#0aa">int</span>(sync_delay.Seconds()),
		<span style="color:#a50">&#34;Sync cache every SYNC seconds&#34;</span>)
	flag.StringVar(&amp;conninfo, <span style="color:#a50">&#34;pguri&#34;</span>, conninfo,
		<span style="color:#a50">&#34;PostgreSQL connection string&#34;</span>)
	flag.StringVar(&amp;channel, <span style="color:#a50">&#34;channel&#34;</span>, channel,
		<span style="color:#a50">&#34;LISTEN to this channel&#34;</span>)

	flag.Parse()

	sync := time.Duration(*syncPtr) * time.Second
	idle := sync / <span style="color:#099">4</span>

	<span style="color:#00a">return</span> &amp;Config{conninfo, channel, sync, idle}
}

<span style="color:#00a">func</span> waitForNotification(l *pq.Listener, cache Cache, timeout time.Duration) {
	<span style="color:#00a">select</span> {
	<span style="color:#00a">case</span> n := &lt;-l.Notify:
		<span style="color:#00a">var</span> c Counter
		err := json.Unmarshal([]<span style="color:#0aa">byte</span>(n.Extra), &amp;c)

		<span style="color:#00a">if</span> err != <span style="color:#00a">nil</span> {
			log.Printf(<span style="color:#a50">&#34;Failed to parse &#39;%s&#39;: %s&#34;</span>, n.Extra, err)
		} <span style="color:#00a">else</span> {
			log.Printf(<span style="color:#a50">&#34;Received event: %s&#34;</span>, n.Extra)
			updateCounter(cache, c)
		}

	<span style="color:#00a">case</span> &lt;-time.After(timeout):
		<span style="color:#00a">return</span>
	}
}

<span style="color:#00a">func</span> initCache(db *sql.DB) (Cache, <span style="color:#0aa">error</span>) {
	q := <span style="color:#a50">&#34;select messageid, rts, favs from tweet.message_with_counters;&#34;</span>

	rows, err := db.Query(q)
	<span style="color:#00a">if</span> err != <span style="color:#00a">nil</span> {
		<span style="color:#00a">return</span> <span style="color:#00a">nil</span>, err
	}
	cache := <span style="color:#0aa">make</span>(Cache)

	<span style="color:#00a">for</span> rows.Next() {
		c := Counter{}
		err := rows.Scan(&amp;c.MessageId, &amp;c.Rts, &amp;c.Favs)

		<span style="color:#00a">if</span> err != <span style="color:#00a">nil</span> {
			<span style="color:#00a">return</span> <span style="color:#00a">nil</span>, err
		}
		cache[c.MessageId] = &amp;c
	}
	err = rows.Err()
	<span style="color:#00a">if</span> err != <span style="color:#00a">nil</span> {
		<span style="color:#00a">return</span> <span style="color:#00a">nil</span>, err
	}
	<span style="color:#00a">return</span> cache, <span style="color:#00a">nil</span>
}

<span style="color:#00a">func</span> materialize(db *sql.DB, cache Cache) <span style="color:#0aa">error</span> {
	<span style="color:#00a">if</span> <span style="color:#0aa">len</span>(cache) == <span style="color:#099">0</span> {
		<span style="color:#00a">return</span> <span style="color:#00a">nil</span>
	}
	log.Printf(<span style="color:#a50">&#34;Materializing %d events from memory&#34;</span>, <span style="color:#0aa">len</span>(cache))

	q := <span style="color:#a50">`
</span><span style="color:#a50">with rec as
</span><span style="color:#a50"> (
</span><span style="color:#a50">   select rec.*
</span><span style="color:#a50">     from json_each($1) as t,
</span><span style="color:#a50">          json_populate_record(null::twcache.counters, value) as rec
</span><span style="color:#a50"> )
</span><span style="color:#a50"> insert into twcache.counters(messageid, rts, favs)
</span><span style="color:#a50">      select messageid, rts, favs
</span><span style="color:#a50">        from rec
</span><span style="color:#a50"> on conflict (messageid)
</span><span style="color:#a50">   do update
</span><span style="color:#a50">         set rts  = counters.rts + excluded.rts,
</span><span style="color:#a50">             favs = counters.favs + excluded.favs
</span><span style="color:#a50">       where counters.messageid = excluded.messageid
</span><span style="color:#a50">`</span>
	js, err := json.Marshal(cache)
	<span style="color:#00a">if</span> err != <span style="color:#00a">nil</span> {
		log.Printf(<span style="color:#a50">&#34;Error while materializing cache: %s&#34;</span>, err)
		<span style="color:#00a">return</span> err
	}

	_, err = db.Query(q, js)
	<span style="color:#00a">if</span> err != <span style="color:#00a">nil</span> {
		log.Printf(<span style="color:#a50">&#34;Error materliazing cache: %s&#34;</span>, err)
		<span style="color:#00a">return</span> err
	}
	<span style="color:#00a">return</span> <span style="color:#00a">nil</span>
}

<span style="color:#00a">func</span> updateCounter(cache Cache, c Counter) {
	_, found := cache[c.MessageId]

	<span style="color:#00a">if</span> found {
		cache[c.MessageId].Rts += c.Rts
		cache[c.MessageId].Favs += c.Favs
	} <span style="color:#00a">else</span> {
		cache[c.MessageId] = &amp;c
	}
}</code></pre></div>
<p>It&rsquo;s important to note that coded as such, we can use the function to both
materialize a full cache as fetched at startup, and to materialize the cache
we build in-memory while receiving notifications.</p>

<p>The query used to fetch the initial value of the cache and set it again at
startup is the following:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#00a">select</span> messageid, rts, favs
  <span style="color:#00a">from</span> tweet.message_with_counters;</code></pre></div>
<p>We use the view definition that we saw earlier to do the computations for
us, and fill in our in-memory cache data structure from the result of the
query.</p>

<p>The trigger processing has a cost of course, as we can see in the following
test:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-lisp" data-lang="lisp"><span style="color:#a00">CL-USER&gt;</span> (<span style="color:#a00">concurrency::concurrency-test</span> <span style="color:#099">100</span> <span style="color:#099">100</span> <span style="color:#099">35</span>)
<span style="color:#a00">Starting</span> <span style="color:#a00">benchmark</span> <span style="color:#a00">for</span> <span style="color:#a00">updates</span>
<span style="color:#a00">Updating</span> <span style="color:#a00">took</span> <span style="color:#099">8.428939</span> <span style="color:#a00">seconds,</span> <span style="color:#a00">did</span> <span style="color:#099">10000</span> <span style="color:#a00">rts</span>

<span style="color:#a00">Starting</span> <span style="color:#a00">benchmark</span> <span style="color:#a00">for</span> <span style="color:#a00">inserts</span>
<span style="color:#a00">Inserting</span> <span style="color:#a00">took</span> <span style="color:#099">10.351908</span> <span style="color:#a00">seconds,</span> <span style="color:#a00">did</span> <span style="color:#099">10000</span> <span style="color:#a00">rts</span></code></pre></div>
<p>Remember when reading those numbers that we can&rsquo;t compare them meaningfully
anymore. We installed our trigger after insert on <em>tweet.activity</em>, which
means that the update benchmark isn&rsquo;t calling any trigger whereas the insert
benchmark is calling our trigger function 10,000 times in this test.</p>

<p>About the concurrency, notifications are serialized at commit time in the
same way that the PostgreSQL commit log is serialized, so there&rsquo;s no extra
work for PostgreSQL here.</p>

<p>Our cache maintenance server received 10,000 notifications with a JSON
payload and then reported the cumulated figures to our cache table only
once, as we can see from the logs:</p>

<pre><code>2017/09/21 22:24:06 Received event: {&quot;messageid&quot;:35,&quot;rts&quot;:1,&quot;favs&quot;:0}
2017/09/21 22:24:06 Received event: {&quot;messageid&quot;:35,&quot;rts&quot;:1,&quot;favs&quot;:0}
2017/09/21 22:24:06 Received event: {&quot;messageid&quot;:35,&quot;rts&quot;:1,&quot;favs&quot;:0}
2017/09/21 22:24:06 Received event: {&quot;messageid&quot;:35,&quot;rts&quot;:1,&quot;favs&quot;:0}
2017/09/21 22:24:09 Materializing 1 events from memory
</code></pre>

<p>Having a look at the cache, here&rsquo;s what we have:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#00a">table</span> twcache.counters;</code></pre></div><div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-psql" data-lang="psql"> messageid │  rts   │ favs 
═══════════╪════════╪══════
         1 │  41688 │    0
         2 │ 222690 │    0
         3 │  22000 │    0
        33 │     -4 │    8
         5 │   7000 │    0
         6 │  30000 │    0
        35 │  10000 │    0
(7 rows)</code></pre></div>
<p>We can see the results of our tests, and in particular, the message with
<em>ids</em> from 1 to 6 are in the cache as expected. Remember the rules we
introduced earlier where the first thing we do when starting our cache
maintenance service is to <em>reset</em> the cache from the real values in the
database. That&rsquo;s how we got those values in the cache; alter all, the cache
service wasn&rsquo;t written when we ran our previous series of tests.</p>

<h2 id="limitations-of-listen-and-notify">Limitations of Listen and Notify</h2>

<p>It is crucial that an application using the PostgreSQL notification
capabilities are capable of missing events. Notifications are only sent to
connected client connections.</p>

<p>Any queueing mechanism requires that event accumulated when there&rsquo;s no
worker connected are kept available until next connection, and replication
is a special case of event queueing. It is not possible to implement
queueing correctly with PostgreSQL <em>listen/notify</em> feature.</p>

<p>A cache maintenance service really is the perfect use case for this
functionality, because it&rsquo;s easy to reset the cache at service start or
restart.</p>

<h2 id="listen-and-notify-support-in-drivers">Listen and Notify Support in Drivers</h2>

<p>Support for listen and notify PostgreSQL functionality depends on the driver
you&rsquo;re using. For instance, the Java JDBC driver documents the support at
<a href="https://jdbc.postgresql.org/documentation/head/listennotify.html">PostgreSQL™ Extensions to the JDBC
API</a>, and
quoting their page:</p>

<blockquote>
<p>A key limitation of the JDBC driver is that it cannot receive
asynchronous notifications and must poll the backend to check if any
notifications were issued. A timeout can be given to the poll function,
but then the execution of statements from other threads will block.</p>
</blockquote>

<p>There&rsquo;s still a full-length class implementation sample, so if you&rsquo;re using
Java check it out.</p>

<p>For Python, the <a href="http://initd.org/psycopg/">Psycopg</a> driver is the most
popular, and <a href="http://initd.org/psycopg/docs/advanced.html#asynchronous-notifications">Python asynchronous
notifications</a>
supports advanced techniques for avoiding <em>busy looping</em>:</p>

<blockquote>
<p>A simple application could poll the connection from time to time to check
if something new has arrived. A better strategy is to use some I/O
completion function such as select() to sleep until awakened by the kernel
when there is some data to read on the connection, thereby using no CPU
unless there is something to read.</p>
</blockquote>

<p>The Golang driver <a href="https://godoc.org/github.com/lib/pq">pq</a> also supports
<a href="https://godoc.org/github.com/lib/pq#hdr-Notifications">notifications</a> and
doesn&rsquo;t require polling. That&rsquo;s the one we&rsquo;ve been using this driver in our
example here.</p>

<p>For other languages, please check the documentation of your driver of choice.</p>

<h2 id="conclusion">Conclusion</h2>

<p>PostgreSQL implements several facilities that we can rely on to maintain an
application cache for data that changes often:</p>

<ul>
<li><p>In <a href="/blog/2018/07/computing-and-caching/">Computing and Caching</a>, we saw
how to use a MATERIALIZED VIEW to get a fixed snapshot of the data, and
then easily REFRESH it to implement our <strong>cache invalidation policy</strong>.</p>

<p>This technique is well adapted to use cases where you want to rebuild
your cache every once in a while, maybe every night, or several times a
day, down to maybe every five minutes if the refreshing of the cache is
really fast.</p></li>

<li><p>In <a href="/blog/2018/07/postgresql-event-based-processing/">PostgreSQL Event Based
Processing</a> we saw how
to use TRIGGERs to maintain a transactionally correct cache, and the
impact of such a choice on the scalability properties of your database
backend.</p>

<p>This solution is well suited to use case where the application only
receives a small amount of UPDATE traffic, and quite far apart, and
can&rsquo;t tolerate any lag when using the cache.</p></li>

<li><p>In today&rsquo;s article <a href="/blog/2018/07/postgresql-listen/notify/">PostgreSQL
LISTEN/NOTIFY</a> we saw how to
build an online cache maintenance service with PostgreSQL&rsquo;s advanced
notification features.</p>

<p>This solution is well suited to use cases where a small amount of lag
can be tolerated, up to maybe some seconds, most typically measured in
the hundreds of milliseconds.</p></li>
</ul>

<p>Again, we see that core PostgreSQL features allow application developers to
build exactly the facility they need. PostgreSQL really is
<a href="/tags/yesql/">YeSQL</a>!</p>
              
            </div>
          </div>
          <div style="margin-top: 1em;">
 <a href="https://theartofpostgresql.com" alt="The Art of PostgreSQL">
  <img src="/img/taopg-cta.jpg" style="width:90%; height: auto; margin-left: 5%">
 </a>
</div>

          <div id="post-footer" class="post-footer main-content-wrap">
            
              
                
                
                  <div class="post-footer-tags">
                    <span class="text-color-light text-small"></span><br/>
                    
  <a class="tag tag--primary tag--small" href="/tags/postgresql/">PostgreSQL</a>

  <a class="tag tag--primary tag--small" href="/tags/yesql/">YeSQL</a>

  <a class="tag tag--primary tag--small" href="/tags/concurrency/">Concurrency</a>

  <a class="tag tag--primary tag--small" href="/tags/listen/">LISTEN</a>

  <a class="tag tag--primary tag--small" href="/tags/notify/">NOTIFY</a>

  <a class="tag tag--primary tag--small" href="/tags/golang/">GoLang</a>

  <a class="tag tag--primary tag--small" href="/tags/json/">JSON</a>

                  </div>
                
              
            
            <div class="post-actions-wrap">
 <nav>
    <ul class="post-actions post-action-nav">
      
        <li class="post-action">
          
            <a class="post-action-btn btn btn--default tooltip--top" href="/blog/2018/07/batch-updates-and-concurrency/" data-tooltip="Batch Updates and Concurrency">
          
            <i class="fa fa-angle-left"></i>
            <span class="hide-xs hide-sm text-small icon-ml"></span>
          </a>
        </li>
        <li class="post-action">
          
            <a class="post-action-btn btn btn--default tooltip--top" href="/blog/2018/07/postgresql-event-based-processing/" data-tooltip="PostgreSQL Event Based Processing">
          
            <span class="hide-xs hide-sm text-small icon-mr"></span>
            <i class="fa fa-angle-right"></i>
          </a>
        </li>
      
    </ul>
  </nav>
  <ul class="post-actions post-action-share">
    
      <li class="post-action hide-lg hide-md hide-sm">
        <a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions">
          <i class="fa fa-share-alt"></i>
        </a>
      </li>
      <li class="post-action hide-xs">
        <a class="post-action-btn btn btn--default" target="new" href="https://plus.google.com/share?url=https%3a%2f%2ftapoueh.org%2fblog%2f2018%2f07%2fpostgresql-listen-notify%2f">
          <i class="fa fa-google-plus"></i>
        </a>
      </li>
      <li class="post-action hide-xs">
        <a class="post-action-btn btn btn--default" target="new" href="https://www.facebook.com/sharer/sharer.php?u=https%3a%2f%2ftapoueh.org%2fblog%2f2018%2f07%2fpostgresql-listen-notify%2f">
          <i class="fa fa-facebook-official"></i>
        </a>
      </li>
      <li class="post-action hide-xs">
        <a class="post-action-btn btn btn--default" target="new" href="https://twitter.com/intent/tweet?text=PostgreSQL%20LISTEN%2fNOTIFY with @tapoueh: https%3a%2f%2ftapoueh.org%2fblog%2f2018%2f07%2fpostgresql-listen-notify%2f">
          <i class="fa fa-twitter"></i>
        </a>
      </li>
    
    
      <li class="post-action">
        <a class="post-action-btn btn btn--default" href="#disqus_thread">
          <i class="fa fa-comment-o"></i>
        </a>
      </li>
    
    <li class="post-action">
      
        <a class="post-action-btn btn btn--default" href="#table-of-contents">
      
        <i class="fa fa-list"></i>
      </a>
    </li>
  </ul>
</div>


            
              
                <div id="disqus_thread">
  <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
              
            
          </div>
        </article>
        <footer id="footer" class="main-content-wrap">
  <span class="copyrights">
    &copy; 2019 Dimitri Fontaine. 
  </span>
</footer>

      </div>
      <div id="bottom-bar" class="post-bottom-bar" data-behavior="5">
        <div class="post-actions-wrap">
 <nav>
    <ul class="post-actions post-action-nav">
      
        <li class="post-action">
          
            <a class="post-action-btn btn btn--default tooltip--top" href="/blog/2018/07/batch-updates-and-concurrency/" data-tooltip="Batch Updates and Concurrency">
          
            <i class="fa fa-angle-left"></i>
            <span class="hide-xs hide-sm text-small icon-ml"></span>
          </a>
        </li>
        <li class="post-action">
          
            <a class="post-action-btn btn btn--default tooltip--top" href="/blog/2018/07/postgresql-event-based-processing/" data-tooltip="PostgreSQL Event Based Processing">
          
            <span class="hide-xs hide-sm text-small icon-mr"></span>
            <i class="fa fa-angle-right"></i>
          </a>
        </li>
      
    </ul>
  </nav>
  <ul class="post-actions post-action-share">
    
      <li class="post-action hide-lg hide-md hide-sm">
        <a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions">
          <i class="fa fa-share-alt"></i>
        </a>
      </li>
      <li class="post-action hide-xs">
        <a class="post-action-btn btn btn--default" target="new" href="https://plus.google.com/share?url=https%3a%2f%2ftapoueh.org%2fblog%2f2018%2f07%2fpostgresql-listen-notify%2f">
          <i class="fa fa-google-plus"></i>
        </a>
      </li>
      <li class="post-action hide-xs">
        <a class="post-action-btn btn btn--default" target="new" href="https://www.facebook.com/sharer/sharer.php?u=https%3a%2f%2ftapoueh.org%2fblog%2f2018%2f07%2fpostgresql-listen-notify%2f">
          <i class="fa fa-facebook-official"></i>
        </a>
      </li>
      <li class="post-action hide-xs">
        <a class="post-action-btn btn btn--default" target="new" href="https://twitter.com/intent/tweet?text=PostgreSQL%20LISTEN%2fNOTIFY with @tapoueh: https%3a%2f%2ftapoueh.org%2fblog%2f2018%2f07%2fpostgresql-listen-notify%2f">
          <i class="fa fa-twitter"></i>
        </a>
      </li>
    
    
      <li class="post-action">
        <a class="post-action-btn btn btn--default" href="#disqus_thread">
          <i class="fa fa-comment-o"></i>
        </a>
      </li>
    
    <li class="post-action">
      
        <a class="post-action-btn btn btn--default" href="#table-of-contents">
      
        <i class="fa fa-list"></i>
      </a>
    </li>
  </ul>
</div>


      </div>
      <div id="share-options-bar" class="share-options-bar" data-behavior="5">
  <ul class="share-options">
    <li class="share-option">
      <a class="share-option-btn" target="new" href="https://plus.google.com/share?url=https%3a%2f%2ftapoueh.org%2fblog%2f2018%2f07%2fpostgresql-listen-notify%2f">
        <i class="fa fa-google-plus"></i><span></span>
      </a>
    </li>
    <li class="share-option">
      <a class="share-option-btn" target="new" href="https://www.facebook.com/sharer/sharer.php?u=https%3a%2f%2ftapoueh.org%2fblog%2f2018%2f07%2fpostgresql-listen-notify%2f">
        <i class="fa fa-facebook-official"></i><span></span>
      </a>
    </li>
    <li class="share-option">
      <a class="share-option-btn" target="new" href="https://twitter.com/intent/tweet?text=PostgreSQL%20LISTEN%2fNOTIFY with @tapoueh: https%3a%2f%2ftapoueh.org%2fblog%2f2018%2f07%2fpostgresql-listen-notify%2f">
        <i class="fa fa-twitter"></i><span></span>
      </a>
    </li>
  </ul>
</div>
<div id="share-options-mask" class="share-options-mask"></div>

    </div>
    
    <div id="about">
  <div id="about-card">
    <div id="about-btn-close">
      <i class="fa fa-remove"></i>
    </div>
    
      <img id="about-card-picture" src="//www.gravatar.com/avatar/7b615d104c506aa0a49e17151fa94d9f?s=110" alt="" />
    
    <h4 id="about-card-name">Dimitri Fontaine</h4>
    
      <div id="about-card-bio">PostgreSQL Major Contributor</div>
    
    
      <div id="about-card-job">
        <i class="fa fa-briefcase"></i>
        <br/>
        Open Source Software Engineer
      </div>
    
    
      <div id="about-card-location">
        <i class="fa fa-map-marker"></i>
        <br/>
        France
      </div>
    
  </div>
</div>

    <div id="algolia-search-modal" class="modal-container">
  <div class="modal">
    <div class="modal-header">
      <span class="close-button"><i class="fa fa-close"></i></span>
      <a href="https://algolia.com" target="_blank" rel="noopener" class="searchby-algolia text-color-light link-unstyled">
        <span class="searchby-algolia-text text-color-light text-small">by</span>
        <img class="searchby-algolia-logo" src="https://www.algolia.com/static_assets/images/press/downloads/algolia-light.svg">
      </a>
      <i class="search-icon fa fa-search"></i>
      <form id="algolia-search-form">
        <input type="text" id="algolia-search-input" name="search"
          class="form-control input--large search-input" placeholder="" />
      </form>
    </div>
    <div class="modal-body">
      <div class="no-result text-color-light text-center"></div>
      <div class="results">
        
        
          <div class="media">
            
            <div class="media-body">
              <a class="link-unstyled" href="https://tapoueh.org/blog/2019/09/postgres-connection-strings-and-psql/">
                <h3 class="media-heading">Postgres Connection Strings and psql</h3>
              </a>
              <span class="media-meta">
                <span class="media-date text-small">
                  Sep 9, 2019
                </span>
              </span>
              <div class="media-content hide-xs font-merryweather"><p><a href="https://www.postgresql.org/docs/current/libpq-connect.html#LIBPQ-CONNSTRING">PostgreSQL connection
strings</a>
embedded in your application can take two different forms: the key-value
notation or the <code>postgresql://</code> URI scheme. When it comes to using <code>psql</code>
though, another form of connection string is introduced, with command line
options <code>-h -p -U</code> and environment variable support.</p>

<p>In this short article you will learn that you can use either of the three
different forms in <code>psql</code> and thus easily copy &amp; paste you application
connection string right at the console to test it!</p>

<p></p></div>
            </div>
            <div style="clear:both;"></div>
            <hr>
          </div>
        
          <div class="media">
            
            <div class="media-body">
              <a class="link-unstyled" href="https://tapoueh.org/blog/2019/08/the-art-of-postgresql/">
                <h3 class="media-heading">The Art Of PostgreSQL</h3>
              </a>
              <span class="media-meta">
                <span class="media-date text-small">
                  Aug 8, 2019
                </span>
              </span>
              <div class="media-content hide-xs font-merryweather"><p>I did it again! Today I am releasing the new edition of my book, with a new
title: “The Art of PostgreSQL”. I&rsquo;m very happy (and quite excited) to
declare my book as <em>Generally Available</em>!</p>

<figure class="right"><a href="https://theartofpostgresql.com">
    <img src="/img/TAOPCoverTablet.png"/> </a>
</figure>


<p><a href="https://theartofpostgresql.com">The Art of PostgreSQL</a> is the new edition
of my previous release, <em>Mastering PostgreSQL in Application Development</em>.
It contains mostly fixes to the old content, a new title, and a new book
design (PDF and paperback). Content wise, <a href="https://theartofpostgresql.com">The Art of
PostgreSQL</a> also comes with a new whole
chapter about PostgreSQL Extensions.</p>

<p>The new chapter covers extensions such as <code>hstore</code>, <code>pg_trgm</code>, <code>intarray</code>,
<code>earthdistance</code>, <code>ip4r</code>, and <code>hll</code> or HyperLogLog, one of the all times
favorite extensions of <a href="http://www.craigkerstiens.com">Craig Kerstiens</a>… who
made himself available to answer my questions and share his view of
PostgreSQL Extensions in an interview!</p></div>
            </div>
            <div style="clear:both;"></div>
            <hr>
          </div>
        
          <div class="media">
            
            <div class="media-body">
              <a class="link-unstyled" href="https://tapoueh.org/blog/2018/11/preventing-sql-injections/">
                <h3 class="media-heading">Preventing SQL Injections</h3>
              </a>
              <span class="media-meta">
                <span class="media-date text-small">
                  Nov 11, 2018
                </span>
              </span>
              <div class="media-content hide-xs font-merryweather"><p>An <em>SQL Injection</em> is a security breach, one made famous by the <a href="https://xkcd.com/327/">Exploits of
a Mom</a> <code>xkcd</code> comic episode in which we read about
<em>little Bobby Tables</em>:</p>

<figure class="center"><a href="https://xkcd.com/327/">
    <img src="/img/exploits_of_a_mom.png"/> </a>
</figure>


<p>PostgreSQL implements a protocol level facility to send the static SQL query
text separately from its dynamic arguments. An SQL injection happens when
the database server is mistakenly led to consider a dynamic argument of a
query as part of the query text. Sending those parts as separate entities
over the protocol means that SQL injection is no longer possible.</p>

<!--toc-->

<p></p></div>
            </div>
            <div style="clear:both;"></div>
            <hr>
          </div>
        
          <div class="media">
            
            <div class="media-body">
              <a class="link-unstyled" href="https://tapoueh.org/blog/2018/08/geolocation-with-postgresql/">
                <h3 class="media-heading">Geolocation with PostgreSQL</h3>
              </a>
              <span class="media-meta">
                <span class="media-date text-small">
                  Aug 8, 2018
                </span>
              </span>
              <div class="media-content hide-xs font-merryweather"><p>We have loaded Open Street Map points of interests in the article <a href="/blog/2013/08/the-most-popular-pub-names/">The Most
Popular Pub Names</a> — which
compares PostgreSQL with MongoDB for simple geographical queries, and is
part of our <a href="/tags/extensions/">PostgreSQL Extensions</a> article series. In
today&rsquo;s article, look at how to geolocalize an IP address and locate the
nearest pub, all within a single SQL query!</p>

<p>For that, we are going to use the awesome
<a href="https://github.com/RhodiumToad/ip4r">ip4r</a> extension from
<a href="http://blog.rhodiumtoad.org.uk/">RhodiumToad</a>.</p></div>
            </div>
            <div style="clear:both;"></div>
            <hr>
          </div>
        
          <div class="media">
            
            <div class="media-body">
              <a class="link-unstyled" href="https://tapoueh.org/blog/2018/08/postgresql-concurrency-an-article-series/">
                <h3 class="media-heading">PostgreSQL Concurrency: an Article Series</h3>
              </a>
              <span class="media-meta">
                <span class="media-date text-small">
                  Aug 8, 2018
                </span>
              </span>
              <div class="media-content hide-xs font-merryweather"><p><a href="https://www.postgresql.org">PostgreSQL</a> is a relational database management
system. It&rsquo;s even the world&rsquo;s most advanced open source one of them. As
such, as its core, Postgres solves concurrent access to a set of data and
maintains consistency while allowing concurrent operations.</p>

<p>In the <a href="/tags/concurrency/">PostgreSQL Concurrency</a> series of articles here
we did see several aspects of how to handle concurrent use cases of your
application design with PostgreSQL. The main thing to remember is that a
Database Management System first task is to handle concurrency access to the
data for you.</p>

<p></p></div>
            </div>
            <div style="clear:both;"></div>
            <hr>
          </div>
        
          <div class="media">
            
            <div class="media-body">
              <a class="link-unstyled" href="https://tapoueh.org/blog/2018/08/scheduled-data-processing-how-to-use-cron/">
                <h3 class="media-heading">Scheduled Data Processing: How to use cron?</h3>
              </a>
              <span class="media-meta">
                <span class="media-date text-small">
                  Aug 8, 2018
                </span>
              </span>
              <div class="media-content hide-xs font-merryweather"><p>A previous article in the <a href="/tags/concurrency">PostgreSQL Concurrency</a> series
covered how to manage concurrent retweets in an efficient way: in <a href="/blog/2018/07/computing-and-caching/">Computing
and Caching</a>, we learnt how to
maintain a cache right in your PostgreSQL database, using MATERIALIZED
VIEWS. We also had a look at how to take care of <a href="/blog/2018/07/batch-updates-and-concurrency/">Batch Updates and
Concurrency</a>.</p>

<p>While in the first case we are providing a solution to a technical problem
where we want to solve performance issues while keeping the same semantics,
in the second case we are actually implementing a part of the application&rsquo;s
<a href="/blog/2017/06/sql-and-business-logic/">Business Logic</a> as a scheduled job.</p>

<p>Today&rsquo;s article shows a modern technique to handle the scheduling of those
business oriented activities that are not tied to any user activity. When
thinking about it this way, you certainly don&rsquo;t want to implement the
backbone of your business logic in a <em>shell script</em> that&rsquo;s directly
maintained in the production environment, do you?</p></div>
            </div>
            <div style="clear:both;"></div>
            <hr>
          </div>
        
          <div class="media">
            
            <div class="media-body">
              <a class="link-unstyled" href="https://tapoueh.org/blog/2018/07/batch-updates-and-concurrency/">
                <h3 class="media-heading">Batch Updates and Concurrency</h3>
              </a>
              <span class="media-meta">
                <span class="media-date text-small">
                  Jul 7, 2018
                </span>
              </span>
              <div class="media-content hide-xs font-merryweather"><p>This article fits in the <a href="/tags/concurrency">PostgreSQL Concurrency</a> series,
where we installed a tweeter like application schema and had all the
characters from Shakespeare&rsquo;s <em>A Midsummer Night&rsquo;s Dream</em> tweet their own
lines in our database in <a href="/blog/2018/06/PostgreSQL-DML.md">PostgreSQL Concurrency: Data Modification
Language</a>.</p>

<p>A previous article in the series covered how to manage concurrent retweets
in an efficient way: <a href="/blog/2018/07/computing-and-caching/">Computing and
Caching</a>, where we learn how to
maintain a cache right in your PostgreSQL database, thanks for materialized
views. We even went as far as maintaining an <em>external</em> cache in another
application layer using PostgreSQL
<a href="https://www.postgresql.org/docs/current/static/sql-listen.html">LISTEN</a> and
<a href="https://www.postgresql.org/docs/current/static/sql-notify.html">NOTIFY</a>
features and a Golang application.</p>

<p>Today&rsquo;s article is going to address concurrency in the context of updating
data in a batch. This activity is quite common, as soon as your system is
connected to other systems either internally or with external providers.
While it&rsquo;s pretty easy to ingest new data, and easy enough to update data
from an external source when nothing happens in your database, doing the
operation safely with concurrent activity is more complex. Once more though,
PostgreSQL comes with all the tooling you need to handle that situation.</p></div>
            </div>
            <div style="clear:both;"></div>
            <hr>
          </div>
        
          <div class="media">
            
            <div class="media-body">
              <a class="link-unstyled" href="https://tapoueh.org/blog/2018/07/postgresql-listen-notify/">
                <h3 class="media-heading">PostgreSQL LISTEN/NOTIFY</h3>
              </a>
              <span class="media-meta">
                <span class="media-date text-small">
                  Jul 7, 2018
                </span>
              </span>
              <div class="media-content hide-xs font-merryweather"><p>This article fits in the <a href="/tags/concurrency">PostgreSQL Concurrency</a> series,
where we installed a tweeter like application schema and had all the
characters from Shakespeare&rsquo;s <em>A Midsummer Night&rsquo;s Dream</em> tweet their own
lines in our database in <a href="/blog/2018/06/PostgreSQL-DML.md">PostgreSQL Concurrency: Data Modification
Language</a>.</p>

<p>A previous article in the series covered how to manage concurrent retweets
in an efficient way: <a href="/blog/2018/07/computing-and-caching/">Computing and
Caching</a>, where we learn how to
maintain a cache right in your PostgreSQL database, thanks for materialized
views.</p>

<p>Today&rsquo;s article shows how to maintain an <em>external</em> cache in another
application layer. In this article we are going to maintain an in-memory
cache in a Golang service, using PostgreSQL
<a href="https://www.postgresql.org/docs/current/static/sql-listen.html">LISTEN</a> and
<a href="https://www.postgresql.org/docs/current/static/sql-notify.html">NOTIFY</a>
features.</p></div>
            </div>
            <div style="clear:both;"></div>
            <hr>
          </div>
        
          <div class="media">
            
            <div class="media-body">
              <a class="link-unstyled" href="https://tapoueh.org/blog/2018/07/postgresql-event-based-processing/">
                <h3 class="media-heading">PostgreSQL Event Based Processing</h3>
              </a>
              <span class="media-meta">
                <span class="media-date text-small">
                  Jul 7, 2018
                </span>
              </span>
              <div class="media-content hide-xs font-merryweather"><p>In the previous article of the series <a href="/blog/2018/07/modeling-for-concurrency/">Modeling for
Concurrency</a>, we saw how to model
your application for highly concurrent activity. It was a follow-up to the
article entitled <a href="/blog/2018/07/postgresql-concurrency-isolation-and-locking/">PostgreSQL Concurrency: Isolation and
Locking</a>, which
was a primer on PostgreSQL isolation and locking properties and behaviors.</p>

<p>Today&rsquo;s article takes us a step further and builds on what we did in the
previous articles in our series. After having had all the characters from
Shakespeare&rsquo;s <em>A Midsummer Night&rsquo;s Dream</em> tweet their own lines in our
database in <a href="/blog/2018/06/PostgreSQL-DML.md">PostgreSQL Concurrency: Data Modification
Language</a>, and having had them like and
retweet a lot in <a href="/blog/2018/07/postgresql-concurrency-isolation-and-locking/">PostgreSQL Concurrency: Isolation and
Locking</a>, we
saw how to manage concurrent retweets in an efficient way in <a href="/blog/2018/07/computing-and-caching/">Computing and
Caching</a>.</p>

<p>What we did implement in the previous article is a <em>cache</em> system, all with
its necessary <strong>cache invalidation policy</strong>. Sometimes though, the
processing of an <em>event</em> needs to happen within the same transaction where
the event is registered in your system. PostgreSQL makes it possible to
maintain a summary table transactionally thanks to its
<a href="https://www.postgresql.org/docs/current/static/sql-createtrigger.html">trigger</a>
support. Today, we&rsquo;re going to dive in how to maintain a summary table with
triggers, and its impact on concurrency.</p></div>
            </div>
            <div style="clear:both;"></div>
            <hr>
          </div>
        
          <div class="media">
            
            <div class="media-body">
              <a class="link-unstyled" href="https://tapoueh.org/blog/2018/07/computing-and-caching/">
                <h3 class="media-heading">Computing and Caching</h3>
              </a>
              <span class="media-meta">
                <span class="media-date text-small">
                  Jul 7, 2018
                </span>
              </span>
              <div class="media-content hide-xs font-merryweather"><p>Let&rsquo;s continue to dive in PostgreSQL Concurrency. In the previous article of
the series, <a href="/blog/2018/07/modeling-for-concurrency/">Modeling for
Concurrency</a>, we saw how to model
your application for highly concurrent activity. It was a follow-up to the
article entitled <a href="/blog/2018/07/postgresql-concurrency-isolation-and-locking/">PostgreSQL Concurrency: Isolation and
Locking</a>, which
was a primer on PostgreSQL isolation and locking properties and behaviors.</p>

<p>Today&rsquo;s article takes us a step further and builds on what we did in the
previous articles in our series. After having had all the characters from
Shakespeare&rsquo;s <em>A Midsummer Night&rsquo;s Dream</em> tweet their own lines in our
database in <a href="/blog/2018/06/PostgreSQL-DML.md">PostgreSQL Concurrency: Data Modification
Language</a>, and having had them like a
retweet a lot in <a href="/blog/2018/07/postgresql-concurrency-isolation-and-locking/">PostgreSQL Concurrency: Isolation and
Locking</a>, it&rsquo;s
time to think about how to display our counters in an efficient way.</p>

<p>In this article, we&rsquo;re going to think about when we should compute results
and when we should cache them for instant retrieval, all within the SQL
tooling. The SQL tooling for handling cache is a <a href="https://www.postgresql.org/docs/current/static/sql-creatematerializedview.html">MATERIALIZED
VIEW</a>,
and it comes with <strong>cache invalidation</strong> routines, of course.</p></div>
            </div>
            <div style="clear:both;"></div>
            <hr>
          </div>
        
      </div>
    </div>
    <div class="modal-footer">
      <p class="results-count text-medium"
         data-message-zero=""
         data-message-one=""
         data-message-other="">
         285 posts found
      </p>
    </div>
  </div>
</div>
    
  
    
    <div id="cover" style="background-image:url('https://tapoueh.org/images/mayan-calendar.jpg');"></div>
  


    
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.2.4/jquery.min.js" integrity="sha256-BbhdlvQf/xTY9gja0Dq3HiwQF8LaCRTXxZKRutelT44=" crossorigin="anonymous"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js" integrity="sha256-/BfiIkHlHoVihZdc6TFuj7MmJ0TWcWsMXkeDFwhi0zw=" crossorigin="anonymous"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/2.1.7/js/jquery.fancybox.min.js" integrity="sha256-GEAnjcTqVP+vBp3SSc8bEDQqvWAZMiHyUSIorrWwH50=" crossorigin="anonymous"></script>


<script src="/js/script-qi9wbxp2ya2j6p7wx1i6tgavftewndznf4v0hy2gvivk1rxgc3lm7njqb6bz.min.js"></script>



<script>
$(document).ready(function() {
  hljs.configure({ classPrefix: '', useBR: false });
  $('pre.code-highlight > code, pre > code').each(function(i, block) {
    if (!$(this).hasClass('codeblock')) {
      $(this).addClass('codeblock');
    }
    hljs.highlightBlock(block);
  });
});
</script>


  
    
      <script>
        var disqus_config = function () {
          this.page.url = 'https:\/\/tapoueh.org\/blog\/2018\/07\/postgresql-listen-notify\/';
          
            this.page.identifier = '\/blog\/2018\/07\/postgresql-listen-notify\/'
          
        };
        (function() {
          
          
          if (window.location.hostname == "localhost") {
            return;
          }
          var d = document, s = d.createElement('script');
          var disqus_shortname = 'tapoueh';
          s.src = '//' + disqus_shortname + '.disqus.com/embed.js';

          s.setAttribute('data-timestamp', +new Date());
          (d.head || d.body).appendChild(s);
        })();
      </script>
    
  



    
  </body>
</html>

