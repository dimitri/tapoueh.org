

  
    
  


  




  


  

<!DOCTYPE html>
<html lang="en-us">
  <head>
    
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="Hugo 0.85.0">
    <meta name="theme" content="Tranquilpeak 0.3.1-BETA">
    <title>PostgreSQL LISTEN/NOTIFY</title>
    <meta name="author" content="Dimitri Fontaine">
    <meta name="keywords" content="">

    <link rel="icon" href="/favicon.ico">
    

    
    <meta name="description" content="This article fits in the PostgreSQL Concurrency series,
where we installed a tweeter like application schema and had all the
characters from Shakespeare&rsquo;s A Midsummer Night&rsquo;s Dream tweet their own
lines in our database in PostgreSQL Concurrency: Data Modification
Language.

A previous article in the series covered how to manage concurrent retweets
in an efficient way: Computing and
Caching, where we learn how to
maintain a cache right in your PostgreSQL database, thanks for materialized
views.

Today&rsquo;s article shows how to maintain an external cache in another
application layer. In this article we are going to maintain an in-memory
cache in a Golang service, using PostgreSQL
LISTEN and
NOTIFY
features.">
    <meta property="og:description" content="This article fits in the PostgreSQL Concurrency series,
where we installed a tweeter like application schema and had all the
characters from Shakespeare&rsquo;s A Midsummer Night&rsquo;s Dream tweet their own
lines in our database in PostgreSQL Concurrency: Data Modification
Language.

A previous article in the series covered how to manage concurrent retweets
in an efficient way: Computing and
Caching, where we learn how to
maintain a cache right in your PostgreSQL database, thanks for materialized
views.

Today&rsquo;s article shows how to maintain an external cache in another
application layer. In this article we are going to maintain an in-memory
cache in a Golang service, using PostgreSQL
LISTEN and
NOTIFY
features.">
    <meta property="og:type" content="blog">
    <meta property="og:title" content="PostgreSQL LISTEN/NOTIFY">
    <meta property="og:url" content="https://tapoueh.org/blog/2018/07/postgresql-listen/notify/">
    <meta property="og:site_name" content="The Art of PostgreSQL">
    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="PostgreSQL LISTEN/NOTIFY">
    <meta name="twitter:description" content="This article fits in the PostgreSQL Concurrency series,
where we installed a tweeter like application schema and had all the
characters from Shakespeare&rsquo;s A Midsummer Night&rsquo;s Dream tweet their own
lines in our database in PostgreSQL Concurrency: Data Modification
Language.

A previous article in the series covered how to manage concurrent retweets
in an efficient way: Computing and
Caching, where we learn how to
maintain a cache right in your PostgreSQL database, thanks for materialized
views.

Today&rsquo;s article shows how to maintain an external cache in another
application layer. In this article we are going to maintain an in-memory
cache in a Golang service, using PostgreSQL
LISTEN and
NOTIFY
features.">
    
      <meta name="twitter:creator" content="@tapoueh">
    
    

    
    

    
      <meta property="og:image" content="//www.gravatar.com/avatar/7b615d104c506aa0a49e17151fa94d9f?s=640">
    

    
      <meta property="og:image" content="https://tapoueh.org/img/siren_alarm_bell_signal_alert-512.png">
    
    
      <meta property="og:image" content="https://tapoueh.org/img/elephant.png">
    
    

    

    
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" />
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/fancybox/2.1.4/jquery.fancybox.css" />
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/fancybox/2.1.4/helpers/jquery.fancybox-thumbs.min.css" />
    
    
    <link rel="stylesheet" href="/css/style-jsjn0006wyhpyzivf6yceb31gvpjatbcs3qzjvlumobfnugccvobqwxnnaj8.min.css" />
    
    
      <link rel="stylesheet" href="https://tapoueh.org/css/dim.css">
    
      <link rel="stylesheet" href="https://tapoueh.org/css/nav.css">
    

    
      
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-47059482-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
    
    
  </head>

  <body>
    <div id="blog">
      <header id="header" data-behavior="5">
  <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
  <div class="navbar-collapse collapse header-title" id="navigation">
    <ul class="nav navbar-nav navbar-right">
      
      <li class="dropdown">
        
        <a style="color: black;" href="/" alt="blog"><i class="sidebar-button-icon fa fa-lg fa-home"></i></a>
        
      </li>
      
      <li class="dropdown">
        
        <a style="color: black;" href="/conf/" alt="talks"><i class="sidebar-button-icon fa fa-lg fa-microphone"></i></a>
        
      </li>
      
      <li class="dropdown">
        
        <a style="color: black;" href="https://twitter.com/tapoueh" alt="Twitter"><i class="sidebar-button-icon fa fa-lg fa-twitter"></i></a>
        
      </li>
      
      <li class="dropdown">
        
        <a style="color: black;" href="http://theartofpostgresql.com" alt="The Art Of PostgreSQL"><i class="sidebar-button-icon fa fa-lg fa-book"></i></a>
        
      </li>
      
    </ul>
  </div>

  
    
      <a class="header-right-icon "
         href="https://theartofpostgresql.com/" target="_blank">
    
    
      <i class="fa fa-lg fa-book"></i>
    
    
    </a>
  
</header>

      <nav id="sidebar" data-behavior="5">
  <div class="sidebar-container">
    
      <div class="sidebar-profile">
        <a href="/#about">
          <img class="sidebar-profile-picture" src="//www.gravatar.com/avatar/7b615d104c506aa0a49e17151fa94d9f?s=110" alt="" />
        </a>
        <h4 class="sidebar-profile-name">Dimitri Fontaine</h4>
        
          <h5 class="sidebar-profile-bio">PostgreSQL Major Contributor</h5>
        
      </div>
    
    <ul class="sidebar-buttons">
      
  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="/">
    
      <i class="sidebar-button-icon fa fa-lg fa-pagelines"></i>
      
      <span class="sidebar-button-desc">Blog</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="/about/">
    
      <i class="sidebar-button-icon fa fa-lg fa-beer"></i>
      
      <span class="sidebar-button-desc">About</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="/categories/yesql/">
    
      <i class="sidebar-button-icon fa fa-lg fa-database"></i>
      
      <span class="sidebar-button-desc">YeSQL</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://theartofpostgresql.com" target="_blank" rel="noopener">
    
      <i class="sidebar-button-icon fa fa-lg fa-book"></i>
      
      <span class="sidebar-button-desc">The Art of PostgreSQL</span>
    </a>
  </li>


    </ul>
    <ul class="sidebar-buttons">
      
  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://github.com/dimitri" target="_blank" rel="noopener">
    
      <i class="sidebar-button-icon fa fa-lg fa-github"></i>
      
      <span class="sidebar-button-desc">GitHub</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="https://twitter.com/tapoueh" target="_blank" rel="noopener">
    
      <i class="sidebar-button-icon fa fa-lg fa-twitter"></i>
      
      <span class="sidebar-button-desc">Twitter</span>
    </a>
  </li>

  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="/categories">
    
      <i class="sidebar-button-icon fa fa-lg fa-bookmark"></i>
      
      <span class="sidebar-button-desc">Categories</span>
    </a>
  </li>


    </ul>
    <ul class="sidebar-buttons">
      
  <li class="sidebar-button">
    
      <a class="sidebar-button-link " href="/index.xml">
    
      <i class="sidebar-button-icon fa fa-lg fa-rss"></i>
      
      <span class="sidebar-button-desc">RSS</span>
    </a>
  </li>


    </ul>
  </div>
</nav>

      
  <div class="post-header-cover
              text-left
              post-header-cover--partial"
       style="background-image:url('/img/elephant.png')"
       data-behavior="5">
    
      <div class="post-header main-content-wrap text-left">
  
    <h1 class="post-title" itemprop="headline">
      PostgreSQL LISTEN/NOTIFY
    </h1>
  
  
  <div class="postShorten-meta post-meta">
    
      <time itemprop="datePublished" datetime="2018-07-19T12:58:21&#43;02:00">
        <span style="float: left; width: 35%">
          <i class="fa fa-calendar"></i> 
  
  
  
  
    Thursday 19 Jul 2018
  

        </span>
      </time>
    
    <span style="float: right; width: 65%">
      <i class="fa fa-clock-o"></i> 14 mins read
      
    </span>
    <span style="float: left; width: 35%">
      <i class="fa fa-bookmark"></i> 
  
  
    <span></span>
    
      <a class="category-link" href="/categories/postgresql">PostgreSQL</a>, 
    
      <a class="category-link" href="/categories/yesql">YeSQL</a>
    
  

    </span>
    <div>
      <p>
        
        
        
        
        
        
        <a href="/tags/concurrency/">
          <i class="fa fa-tag"></i> Concurrency
        </a>
        
        
        
        <a href="/tags/listen/">
          <i class="fa fa-tag"></i> LISTEN
        </a>
        
        
        
        <a href="/tags/notify/">
          <i class="fa fa-tag"></i> NOTIFY
        </a>
        
        
        
        <a href="/tags/golang/">
          <i class="fa fa-tag"></i> GoLang
        </a>
        
        
        
        <a href="/tags/json/">
          <i class="fa fa-tag"></i> JSON
        </a>
        
        
      </p>
    </div>
  </div>


</div>
    
  </div>


      <div id="main" data-behavior="5"
        class="hasCover
               hasCoverMetaIn
               ">
        <article class="post" itemscope itemType="http://schema.org/BlogPosting">
          
          
          <div class="post-content markdown" itemprop="articleBody">
            <div class="main-content-wrap">
              <p>This article fits in the <a href="/tags/concurrency">PostgreSQL Concurrency</a> series,
where we installed a tweeter like application schema and had all the
characters from Shakespeare&rsquo;s <em>A Midsummer Night&rsquo;s Dream</em> tweet their own
lines in our database in <a href="/blog/2018/06/PostgreSQL-DML.md">PostgreSQL Concurrency: Data Modification
Language</a>.</p>

<p>A previous article in the series covered how to manage concurrent retweets
in an efficient way: <a href="/blog/2018/07/computing-and-caching/">Computing and
Caching</a>, where we learn how to
maintain a cache right in your PostgreSQL database, thanks for materialized
views.</p>

<p>Today&rsquo;s article shows how to maintain an <em>external</em> cache in another
application layer. In this article we are going to maintain an in-memory
cache in a Golang service, using PostgreSQL
<a href="https://www.postgresql.org/docs/current/static/sql-listen.html">LISTEN</a> and
<a href="https://www.postgresql.org/docs/current/static/sql-notify.html">NOTIFY</a>
features.</p>

 




<div class="table-of-contents toc bd-callout">
    
    <h4 class="text-muted">Table of Contents</h4>
    
        
        
            
                
                
                
                    <ul class="toc-h1">
                
                
                
                
                <li>
                  <a href="/blog/2018/07/postgresql-listen/notify/#listen-and-notify">
                    Listen and Notify
                  </a>
                </li>
                
                
                    </ul>
                
            
        
    
        
        
            
                
                
                
                    <ul class="toc-h1">
                
                
                
                
                <li>
                  <a href="/blog/2018/07/postgresql-listen/notify/#postgresql-notifications">
                    PostgreSQL Notifications
                  </a>
                </li>
                
                
                    </ul>
                
            
        
    
        
        
            
                
                
                
                    <ul class="toc-h1">
                
                
                
                
                <li>
                  <a href="/blog/2018/07/postgresql-listen/notify/#postgresql-event-publication-system">
                    PostgreSQL Event Publication System
                  </a>
                </li>
                
                
                    </ul>
                
            
        
    
        
        
            
                
                
                
                    <ul class="toc-h1">
                
                
                
                
                <li>
                  <a href="/blog/2018/07/postgresql-listen/notify/#notifications-and-cache-maintenance">
                    Notifications and Cache Maintenance
                  </a>
                </li>
                
                
                    </ul>
                
            
        
    
        
        
            
                
                
                
                    <ul class="toc-h1">
                
                
                
                
                <li>
                  <a href="/blog/2018/07/postgresql-listen/notify/#limitations-of-listen-and-notify">
                    Limitations of Listen and Notify
                  </a>
                </li>
                
                
                    </ul>
                
            
        
    
        
        
            
                
                
                
                    <ul class="toc-h1">
                
                
                
                
                <li>
                  <a href="/blog/2018/07/postgresql-listen/notify/#listen-and-notify-support-in-drivers">
                    Listen and Notify Support in Drivers
                  </a>
                </li>
                
                
                    </ul>
                
            
        
    
        
        
            
                
                
                
                    <ul class="toc-h1">
                
                
                
                
                <li>
                  <a href="/blog/2018/07/postgresql-listen/notify/#conclusion">
                    Conclusion
                  </a>
                </li>
                
                
                    </ul>
                
            
        
    
</div>



<h2 id="listen-and-notify">Listen and Notify</h2>

<p>The PostgreSQL protocol includes a streaming protocol with <em>COPY</em> and also
implements asynchronous messages and notifications. This means that as soon
as a connection is established with PostgreSQL, the server can send messages
to the client even when the client is idle.</p>

<h2 id="postgresql-notifications">PostgreSQL Notifications</h2>

<p>Messages that flow from the server to the connected client should be
processed by the client. It could be that the server is being restarted, or
an application message is being delivered.</p>

<p>Here&rsquo;s an example of doing this:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql">yesql#<span style="color:#bbb"> </span><span style="color:#00a">listen</span><span style="color:#bbb"> </span>channel;<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#00a">LISTEN</span><span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb"></span>yesql#<span style="color:#bbb"> </span><span style="color:#00a">notify</span><span style="color:#bbb"> </span>channel,<span style="color:#bbb"> </span><span style="color:#a50">&#39;foo&#39;</span>;<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#00a">NOTIFY</span><span style="color:#bbb">
</span><span style="color:#bbb"></span>Asynchronous<span style="color:#bbb"> </span>notification<span style="color:#bbb"> </span><span style="color:#a50">&#34;channel&#34;</span><span style="color:#bbb"> </span><span style="color:#00a">with</span><span style="color:#bbb"> </span>payload<span style="color:#bbb"> </span><span style="color:#a50">&#34;foo&#34;</span><span style="color:#bbb">  </span><span style="color:#f00;background-color:#faa">⏎</span><span style="color:#bbb">
</span><span style="color:#bbb"></span>received<span style="color:#bbb"> </span><span style="color:#00a">from</span><span style="color:#bbb"> </span>server<span style="color:#bbb"> </span>process<span style="color:#bbb"> </span><span style="color:#00a">with</span><span style="color:#bbb"> </span>PID<span style="color:#bbb"> </span><span style="color:#099">40430</span>.</code></pre></div>
<p>Note that the message could be sent from another connection, so try it and
see with several <em>psql</em> instances. The <em>payload</em> from the message can be any
text, up to 8kB in length. This allows for rich messages to flow, such as
JSON encoded values.</p>

<h2 id="postgresql-event-publication-system">PostgreSQL Event Publication System</h2>

<p>In the <a href="#triggers">Triggers</a> section we saw that in order to maintain a
cache of the action counters either by day or by messageid, we can write a
trigger. This implements event driven processing but kills our concurrency
and scalability properties.</p>

<p>It&rsquo;s possible for our trigger to <em>notify</em> an external client. This client
must be a daemon program, which uses <em>listen</em> to register our messages. Each
time a notification is sent, the daemon program processes it as necessary,
possibly updating our <em>twcache.counters</em> table. As we have a single daemon
program listening to notifications and updating the cache, we now bypass the
concurrency issues.</p>

<p>Before implementing the client application, we can implement the trigger for
notification, and use <em>psql</em> as a testing client:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#00a">begin</span>;<span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#00a">create</span><span style="color:#bbb"> </span><span style="color:#00a">or</span><span style="color:#bbb"> </span><span style="color:#00a">replace</span><span style="color:#bbb"> </span><span style="color:#00a">function</span><span style="color:#bbb"> </span>twcache.tg_notify_counters<span style="color:#bbb"> </span>()<span style="color:#bbb">
</span><span style="color:#bbb"> </span><span style="color:#00a">returns</span><span style="color:#bbb"> </span><span style="color:#00a">trigger</span><span style="color:#bbb">
</span><span style="color:#bbb"> </span><span style="color:#00a">language</span><span style="color:#bbb"> </span>plpgsql<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#00a">as</span><span style="color:#bbb"> </span><span style="color:#f00;background-color:#faa">$$</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#00a">declare</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span>channel<span style="color:#bbb"> </span><span style="color:#0aa">text</span><span style="color:#bbb"> </span>:=<span style="color:#bbb"> </span>TG_ARGV[<span style="color:#099">0</span>];<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#00a">begin</span><span style="color:#bbb">
</span><span style="color:#bbb">  </span>PERFORM<span style="color:#bbb"> </span>(<span style="color:#bbb">
</span><span style="color:#bbb">     </span><span style="color:#00a">with</span><span style="color:#bbb"> </span>payload(messageid,<span style="color:#bbb"> </span>rts,<span style="color:#bbb"> </span>favs)<span style="color:#bbb"> </span><span style="color:#00a">as</span><span style="color:#bbb">
</span><span style="color:#bbb">     </span>(<span style="color:#bbb">
</span><span style="color:#bbb">       </span><span style="color:#00a">select</span><span style="color:#bbb"> </span><span style="color:#00a">NEW</span>.messageid,<span style="color:#bbb">
</span><span style="color:#bbb">              </span>coalesce(<span style="color:#bbb">
</span><span style="color:#bbb">                 </span><span style="color:#00a">case</span><span style="color:#bbb"> </span><span style="color:#00a">NEW</span>.action<span style="color:#bbb">
</span><span style="color:#bbb">                   </span><span style="color:#00a">when</span><span style="color:#bbb"> </span><span style="color:#a50">&#39;rt&#39;</span><span style="color:#bbb">    </span><span style="color:#00a">then</span><span style="color:#bbb">  </span><span style="color:#099">1</span><span style="color:#bbb">
</span><span style="color:#bbb">                   </span><span style="color:#00a">when</span><span style="color:#bbb"> </span><span style="color:#a50">&#39;de-rt&#39;</span><span style="color:#bbb"> </span><span style="color:#00a">then</span><span style="color:#bbb"> </span>-<span style="color:#099">1</span><span style="color:#bbb">
</span><span style="color:#bbb">                  </span><span style="color:#00a">end</span>,<span style="color:#bbb">
</span><span style="color:#bbb">                 </span><span style="color:#099">0</span><span style="color:#bbb">
</span><span style="color:#bbb">              </span>)<span style="color:#bbb"> </span><span style="color:#00a">as</span><span style="color:#bbb"> </span>rts,<span style="color:#bbb">
</span><span style="color:#bbb">              </span>coalesce(<span style="color:#bbb">
</span><span style="color:#bbb">                </span><span style="color:#00a">case</span><span style="color:#bbb"> </span><span style="color:#00a">NEW</span>.action<span style="color:#bbb">
</span><span style="color:#bbb">                  </span><span style="color:#00a">when</span><span style="color:#bbb"> </span><span style="color:#a50">&#39;fav&#39;</span><span style="color:#bbb">    </span><span style="color:#00a">then</span><span style="color:#bbb">  </span><span style="color:#099">1</span><span style="color:#bbb">
</span><span style="color:#bbb">                  </span><span style="color:#00a">when</span><span style="color:#bbb"> </span><span style="color:#a50">&#39;de-fav&#39;</span><span style="color:#bbb"> </span><span style="color:#00a">then</span><span style="color:#bbb"> </span>-<span style="color:#099">1</span><span style="color:#bbb">
</span><span style="color:#bbb">                 </span><span style="color:#00a">end</span>,<span style="color:#bbb">
</span><span style="color:#bbb">                </span><span style="color:#099">0</span><span style="color:#bbb">
</span><span style="color:#bbb">              </span>)<span style="color:#bbb"> </span><span style="color:#00a">as</span><span style="color:#bbb"> </span>favs<span style="color:#bbb">
</span><span style="color:#bbb">     </span>)<span style="color:#bbb">
</span><span style="color:#bbb">     </span><span style="color:#00a">select</span><span style="color:#bbb"> </span>pg_notify(channel,<span style="color:#bbb"> </span>row_to_json(payload)::<span style="color:#0aa">text</span>)<span style="color:#bbb">
</span><span style="color:#bbb">       </span><span style="color:#00a">from</span><span style="color:#bbb"> </span>payload<span style="color:#bbb">
</span><span style="color:#bbb">  </span>);<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#00a">RETURN</span><span style="color:#bbb"> </span><span style="color:#00a">NULL</span>;<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#00a">end</span>;<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#f00;background-color:#faa">$$</span>;<span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#00a">CREATE</span><span style="color:#bbb"> </span><span style="color:#00a">TRIGGER</span><span style="color:#bbb"> </span>notify_counters<span style="color:#bbb">
</span><span style="color:#bbb">         </span><span style="color:#00a">AFTER</span><span style="color:#bbb"> </span><span style="color:#00a">INSERT</span><span style="color:#bbb">
</span><span style="color:#bbb">            </span><span style="color:#00a">ON</span><span style="color:#bbb"> </span>tweet.activity<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#00a">FOR</span><span style="color:#bbb"> </span><span style="color:#00a">EACH</span><span style="color:#bbb"> </span><span style="color:#00a">ROW</span><span style="color:#bbb">
</span><span style="color:#bbb">       </span><span style="color:#00a">EXECUTE</span><span style="color:#bbb"> </span><span style="color:#00a">PROCEDURE</span><span style="color:#bbb"> </span>twcache.tg_notify_counters(<span style="color:#a50">&#39;tweet.activity&#39;</span>);<span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#00a">commit</span>;</code></pre></div>
<p>Then to test the trigger, we can issue the following statements at a <em>psql</em>
prompt:</p>
<pre><code class="language-psql" data-lang="psql">listen &#34;tweet.activity&#34;;

insert into tweet.activity(messageid, action)
     values (33, &#39;rt&#39;),
            (33, &#39;rt&#39;),
            (33, &#39;de-rt&#39;),
            (33, &#39;fav&#39;),
            (33, &#39;de-fav&#39;),
            (33, &#39;rt&#39;),
            (33, &#39;fav&#39;);</code></pre>
<p>We get then the following output from the console:</p>
<pre><code class="language-psql" data-lang="psql">INSERT 0 7
Asynchronous notification &#34;tweet.activity&#34; with payload        ⏎
&#34;{&#34;messageid&#34;:33,&#34;rts&#34;:1,&#34;favs&#34;:0}&#34; received from              ⏎
server process with PID 73216.
Asynchronous notification &#34;tweet.activity&#34; with payload        ⏎
&#34;{&#34;messageid&#34;:33,&#34;rts&#34;:-1,&#34;favs&#34;:0}&#34; received from             ⏎
server process with PID 73216.
Asynchronous notification &#34;tweet.activity&#34; with payload        ⏎
&#34;{&#34;messageid&#34;:33,&#34;rts&#34;:0,&#34;favs&#34;:1}&#34; received from              ⏎
server process with PID 73216.
Asynchronous notification &#34;tweet.activity&#34; with payload        ⏎
&#34;{&#34;messageid&#34;:33,&#34;rts&#34;:0,&#34;favs&#34;:-1}&#34; received from             ⏎
server process with PID 73216.</code></pre>
<p>So we made seven inserts, and we have four notifications. This behavior
might be surprising, yet it is fully documented on the PostgreSQL manual
page for the
<a href="https://www.postgresql.org/docs/current/static/sql-notify.html">NOTIFY</a>
command:</p>

<blockquote>
<p>If the same channel name is signaled multiple times from the same
transaction with identical payload strings, the database server can decide
to deliver a single notification only. On the other hand, notifications
with distinct payload strings will always be delivered as distinct
notifications. Similarly, notifications from different transactions will
never get folded into one notification. Except for dropping later
instances of duplicate notifications, NOTIFY guarantees that notifications
from the same transaction get delivered in the order they were sent. It is
also guaranteed that messages from different transactions are delivered in
the order in which the transactions committed.</p>
</blockquote>

<p>Our test case isn&rsquo;t very good, so let&rsquo;s write another one, and keep in mind
that our implementation of the cache server with <em>notify</em> can only be
correct if the main application issues only distinct <em>tweet.activity</em>
actions in a single transaction. For our usage, this is not a deal-breaker,
so we can fix our tests.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#00a">insert</span><span style="color:#bbb"> </span><span style="color:#00a">into</span><span style="color:#bbb"> </span>tweet.activity(messageid,<span style="color:#bbb"> </span>action)<span style="color:#bbb"> </span><span style="color:#00a">values</span><span style="color:#bbb"> </span>(<span style="color:#099">33</span>,<span style="color:#bbb"> </span><span style="color:#a50">&#39;rt&#39;</span>);<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#00a">insert</span><span style="color:#bbb"> </span><span style="color:#00a">into</span><span style="color:#bbb"> </span>tweet.activity(messageid,<span style="color:#bbb"> </span>action)<span style="color:#bbb"> </span><span style="color:#00a">values</span><span style="color:#bbb"> </span>(<span style="color:#099">33</span>,<span style="color:#bbb"> </span><span style="color:#a50">&#39;de-rt&#39;</span>);<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#00a">insert</span><span style="color:#bbb"> </span><span style="color:#00a">into</span><span style="color:#bbb"> </span>tweet.activity(messageid,<span style="color:#bbb"> </span>action)<span style="color:#bbb"> </span><span style="color:#00a">values</span><span style="color:#bbb"> </span>(<span style="color:#099">33</span>,<span style="color:#bbb"> </span><span style="color:#a50">&#39;fav&#39;</span>);<span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#00a">insert</span><span style="color:#bbb"> </span><span style="color:#00a">into</span><span style="color:#bbb"> </span>tweet.activity(messageid,<span style="color:#bbb"> </span>action)<span style="color:#bbb"> </span><span style="color:#00a">values</span><span style="color:#bbb"> </span>(<span style="color:#099">33</span>,<span style="color:#bbb"> </span><span style="color:#a50">&#39;de-rt&#39;</span>);</code></pre></div>
<p>And this time we get the expected notifications:</p>
<pre><code class="language-psql" data-lang="psql">Asynchronous notification &#34;tweet.activity&#34; with payload        ⏎
&#34;{&#34;messageid&#34;:33,&#34;rts&#34;:1,&#34;favs&#34;:0}&#34; received from              ⏎
server process with PID 73216.
Asynchronous notification &#34;tweet.activity&#34; with payload        ⏎
&#34;{&#34;messageid&#34;:33,&#34;rts&#34;:-1,&#34;favs&#34;:0}&#34; received from             ⏎
server process with PID 73216.
Asynchronous notification &#34;tweet.activity&#34; with payload        ⏎
&#34;{&#34;messageid&#34;:33,&#34;rts&#34;:0,&#34;favs&#34;:1}&#34; received from              ⏎
server process with PID 73216.
Asynchronous notification &#34;tweet.activity&#34; with payload        ⏎
&#34;{&#34;messageid&#34;:33,&#34;rts&#34;:-1,&#34;favs&#34;:0}&#34; received from             ⏎
server process with PID 73216.</code></pre>
<hr />

<figure class="right"><a href="https://theartofpostgresql.com"><img src="/img/TAOP_Book_Cover_200x260.png"/></a>
</figure>


<p>This article is extracted from my book <a href="https://theartofpostgresql.com">The Art of
PostgreSQL</a>, which teaches SQL to developers
so that they may replace thousands of lines of code with very simple
queries. The book has a full chapter about <em>Data Manipulation and
Concurrency Control</em> in PostgreSQL, including caching with materialized
views, check it out!</p>

<hr />

<h2 id="notifications-and-cache-maintenance">Notifications and Cache Maintenance</h2>

<p>Now that we have the basic server-side infrastructure in place, where
PostgreSQL is the server and a backend application the client, we can look
into about maintaining our <em>twcache.counters</em> cache in an event driven
fashion.</p>

<p>PostgreSQL LISTEN and NOTIFY support is perfect for maintaining a cache.
Because notifications are only delivered to client connections that are
listening at the moment of the notify call, our cache maintenance service
must implement the following behavior, in this exact order:</p>

<ol>
<li><p>Connect to the PostgreSQL database we expect notifications from and
 issue the <em>listen</em> command.</p></li>

<li><p>Fetch the current values from their <em>single source of truth</em> and reset
 the cache with those computed values.</p></li>

<li><p>Process notifications as they come and update the in-memory cache, and
 once in a while synchronize the in-memory cache to its materialized
 location, as per the cache invalidation policy.</p></li>
</ol>

<p>The cache service can be implemented within the cache maintenance service.
As an example, a cache server application might both process notifications
and serve the current cache from memory over an HTTP API. The cache service
might also be one of the popular cache solutions such as
<a href="https://memcached.org">Memcached</a> or <a href="https://redis.io">Redis</a>.</p>

<p>In our example, we implement a cache maintenance service in Go and the cache
itself is maintained as a PostgreSQL table:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#00a">begin</span>;<span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#00a">create</span><span style="color:#bbb"> </span><span style="color:#00a">schema</span><span style="color:#bbb"> </span><span style="color:#00a">if</span><span style="color:#bbb"> </span><span style="color:#00a">not</span><span style="color:#bbb"> </span><span style="color:#00a">exists</span><span style="color:#bbb"> </span>twcache;<span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#00a">create</span><span style="color:#bbb"> </span><span style="color:#00a">table</span><span style="color:#bbb"> </span>twcache.counters<span style="color:#bbb">
</span><span style="color:#bbb"> </span>(<span style="color:#bbb">
</span><span style="color:#bbb">   </span>messageid<span style="color:#bbb">   </span><span style="color:#0aa">bigint</span><span style="color:#bbb"> </span><span style="color:#00a">not</span><span style="color:#bbb"> </span><span style="color:#00a">null</span><span style="color:#bbb"> </span><span style="color:#00a">primary</span><span style="color:#bbb"> </span><span style="color:#00a">key</span>,<span style="color:#bbb">
</span><span style="color:#bbb">   </span>rts<span style="color:#bbb">         </span><span style="color:#0aa">bigint</span>,<span style="color:#bbb">
</span><span style="color:#bbb">   </span>favs<span style="color:#bbb">        </span><span style="color:#0aa">bigint</span><span style="color:#bbb">
</span><span style="color:#bbb"> </span>);<span style="color:#bbb">
</span><span style="color:#bbb">
</span><span style="color:#bbb"></span><span style="color:#00a">commit</span>;</code></pre></div>
<p>With this table, implementing a NOTIFY client service that maintains the
cache is easy enough to do, and here&rsquo;s what happens when the service runs
and we do some testing:</p>
<pre><code>2017/09/21 22:00:36 Connecting to postgres:///yesql?sslmode=disable… 
2017/09/21 22:00:36 Listening to notifications on channel &#34;tweet.activity&#34;
2017/09/21 22:00:37 Cache initialized with 6 entries.
2017/09/21 22:00:37 Start processing notifications, waiting for events…
2017/09/21 22:00:42 Received event: {&#34;messageid&#34;:33,&#34;rts&#34;:1,&#34;favs&#34;:0}
2017/09/21 22:00:42 Received event: {&#34;messageid&#34;:33,&#34;rts&#34;:-1,&#34;favs&#34;:0}
2017/09/21 22:00:42 Received event: {&#34;messageid&#34;:33,&#34;rts&#34;:0,&#34;favs&#34;:1}
2017/09/21 22:00:42 Received event: {&#34;messageid&#34;:33,&#34;rts&#34;:-1,&#34;favs&#34;:0}
2017/09/21 22:00:47 Materializing 6 events from memory</code></pre>
<p>The client code is written in Go, and is included in full in this article.
One of the main bits of interest is the <em>materialize</em> function, which is an
interesting implementation of pushing the in-memory cache data structure
down to our PostgreSQL table <em>twcache.counters</em>.</p>

<p>The in-memory cache structure looks like the following:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#00a">type</span> Counter <span style="color:#00a">struct</span> {
	MessageId <span style="color:#0aa">int</span> <span style="color:#a50">`json:&#34;messageid&#34;`</span>
	Rts       <span style="color:#0aa">int</span> <span style="color:#a50">`json:&#34;rts&#34;`</span>
	Favs      <span style="color:#0aa">int</span> <span style="color:#a50">`json:&#34;favs&#34;`</span>
}

<span style="color:#00a">type</span> Cache <span style="color:#00a">map</span>[<span style="color:#0aa">int</span>]*Counter</code></pre></div>
<p>And given such a data structure, we use the efficient Go default JSON
marshaling facility to transform the cache elements and pass them all down
to PostgreSQL as a single JSON object.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#00a">func</span> <span style="color:#0a0">materialize</span>(db *sql.DB, cache Cache) <span style="color:#0aa">error</span> {
    ...
    
	js, err := json.<span style="color:#0a0">Marshal</span>(cache)

	<span style="color:#00a">if</span> err != <span style="color:#00a">nil</span> {
		log.<span style="color:#0a0">Printf</span>(<span style="color:#a50">&#34;Error while materializing cache: %s&#34;</span>, err)
		<span style="color:#00a">return</span> err
	}
    
	_, err = db.<span style="color:#0a0">Query</span>(q, js)
    
    ...
    <span style="color:#00a">return</span> <span style="color:#00a">nil</span>
}</code></pre></div>
<p>The JSON object is then processed in a SQL query, that we find embedded in
the Go code — it&rsquo;s the <em>q</em> string variable that is used in the snippet above
in the expression <em>db.Query(q, js)</em>, where <em>js</em> is the JSON representation
of the entirety of the cache data.</p>

<p>Here&rsquo;s the SQL query we use:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#00a">with</span><span style="color:#bbb"> </span>rec<span style="color:#bbb"> </span><span style="color:#00a">as</span><span style="color:#bbb">
</span><span style="color:#bbb"> </span>(<span style="color:#bbb">
</span><span style="color:#bbb">   </span><span style="color:#00a">select</span><span style="color:#bbb"> </span>rec.*<span style="color:#bbb">
</span><span style="color:#bbb">     </span><span style="color:#00a">from</span><span style="color:#bbb"> </span>json_each(<span style="color:#f00;background-color:#faa">$</span><span style="color:#099">1</span>)<span style="color:#bbb"> </span><span style="color:#00a">as</span><span style="color:#bbb"> </span>t,<span style="color:#bbb">
</span><span style="color:#bbb">          </span>json_populate_record(<span style="color:#00a">null</span>::twcache.counters,<span style="color:#bbb"> </span>value)<span style="color:#bbb"> </span><span style="color:#00a">as</span><span style="color:#bbb"> </span>rec<span style="color:#bbb">
</span><span style="color:#bbb"> </span>)<span style="color:#bbb">
</span><span style="color:#bbb"> </span><span style="color:#00a">insert</span><span style="color:#bbb"> </span><span style="color:#00a">into</span><span style="color:#bbb"> </span>twcache.counters(messageid,<span style="color:#bbb"> </span>rts,<span style="color:#bbb"> </span>favs)<span style="color:#bbb">
</span><span style="color:#bbb">      </span><span style="color:#00a">select</span><span style="color:#bbb"> </span>messageid,<span style="color:#bbb"> </span>rts,<span style="color:#bbb"> </span>favs<span style="color:#bbb">
</span><span style="color:#bbb">        </span><span style="color:#00a">from</span><span style="color:#bbb"> </span>rec<span style="color:#bbb">
</span><span style="color:#bbb"> </span><span style="color:#00a">on</span><span style="color:#bbb"> </span>conflict<span style="color:#bbb"> </span>(messageid)<span style="color:#bbb">
</span><span style="color:#bbb">   </span><span style="color:#00a">do</span><span style="color:#bbb"> </span><span style="color:#00a">update</span><span style="color:#bbb">
</span><span style="color:#bbb">         </span><span style="color:#00a">set</span><span style="color:#bbb"> </span>rts<span style="color:#bbb">  </span>=<span style="color:#bbb"> </span>counters.rts<span style="color:#bbb"> </span>+<span style="color:#bbb"> </span>excluded.rts,<span style="color:#bbb">
</span><span style="color:#bbb">             </span>favs<span style="color:#bbb"> </span>=<span style="color:#bbb"> </span>counters.favs<span style="color:#bbb"> </span>+<span style="color:#bbb"> </span>excluded.favs<span style="color:#bbb">
</span><span style="color:#bbb">       </span><span style="color:#00a">where</span><span style="color:#bbb"> </span>counters.messageid<span style="color:#bbb"> </span>=<span style="color:#bbb"> </span>excluded.messageid</code></pre></div>
<p>In this query, we use the PostgreSQL
<a href="https://www.postgresql.org/docs/9.6/static/functions-json.html#FUNCTIONS-JSON-PROCESSING-TABLE">json_populate_record</a>
function. This function is almost magical and it is described as such in the
documentation:</p>

<blockquote>
<p>Expands the object in from_json to a row whose columns match the record
type defined by base (see note below).</p>

<p>Note: In <em>json_populate_record</em>, <em>json_populate_recordset</em>,
<em>json_to_record</em> and <em>json_to_recordset</em>, type coercion from the JSON is
&ldquo;best effort&rdquo; and may not result in desired values for some types. JSON
keys are matched to identical column names in the target row type. JSON
fields that do not appear in the target row type will be omitted from the
output, and target columns that do not match any JSON field will simply be
NULL.</p>
</blockquote>

<p>The function allows transforming a JSON document into a full-blown
relational tuple to process as usual in PostgreSQL. Here we use an implicit
<em>lateral</em> construct that feeds the <em>json_populate_record()</em> function from
the output of the <em>json_each()</em> function. We could have used the <em>recordset</em>
variant, but we&rsquo;re discarding the Go cache key that repeats the <em>MessageId</em>
here.</p>

<p>Then our SQL query uses the <em>insert into &hellip; select &hellip; on conflict do
update</em> variant that we&rsquo;re used to by now.</p>

<p>So, here&rsquo;s the full Go script we&rsquo;re using here:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#00a">package</span> main

<span style="color:#00a">import</span> (
	<span style="color:#a50">&#34;database/sql&#34;</span>
	<span style="color:#a50">&#34;encoding/json&#34;</span>
	<span style="color:#a50">&#34;flag&#34;</span>
	<span style="color:#a50">&#34;time&#34;</span>
	<span style="color:#a50">&#34;log&#34;</span>
	<span style="color:#a50">&#34;os&#34;</span>

	<span style="color:#a50">&#34;github.com/lib/pq&#34;</span>
)

<span style="color:#00a">type</span> Config <span style="color:#00a">struct</span> {
	PGuri   <span style="color:#0aa">string</span>
	Channel <span style="color:#0aa">string</span>
	Sync    time.Duration
	Idle    time.Duration
}

<span style="color:#00a">type</span> Counter <span style="color:#00a">struct</span> {
	MessageId <span style="color:#0aa">int</span> <span style="color:#a50">`json:&#34;messageid&#34;`</span>
	Rts       <span style="color:#0aa">int</span> <span style="color:#a50">`json:&#34;rts&#34;`</span>
	Favs      <span style="color:#0aa">int</span> <span style="color:#a50">`json:&#34;favs&#34;`</span>
}

<span style="color:#00a">type</span> Cache <span style="color:#00a">map</span>[<span style="color:#0aa">int</span>]*Counter

<span style="color:#00a">const</span> sync_delay = <span style="color:#099">10</span> * time.Second
<span style="color:#00a">const</span> idle_delay = <span style="color:#099">30</span> * time.Second
<span style="color:#00a">const</span> scrn_width = <span style="color:#099">65</span>
<span style="color:#00a">const</span> min_reconn = <span style="color:#099">10</span> * time.Second
<span style="color:#00a">const</span> max_reconn = time.Minute

<span style="color:#00a">func</span> <span style="color:#0a0">main</span>() {
	conf := <span style="color:#0a0">processFlags</span>()
	log.<span style="color:#0a0">SetOutput</span>(os.Stdout)

	log.<span style="color:#0a0">Printf</span>(<span style="color:#a50">&#34;Connecting to %s… &#34;</span>, conf.PGuri)
	db, err := sql.<span style="color:#0a0">Open</span>(<span style="color:#a50">&#34;postgres&#34;</span>, conf.PGuri)
	<span style="color:#00a">if</span> err != <span style="color:#00a">nil</span> {
		log.<span style="color:#0a0">Printf</span>(<span style="color:#a50">&#34;Failed to connect to &#39;%s&#39;: %s&#34;</span>, conf.PGuri, err)
		os.<span style="color:#0a0">Exit</span>(<span style="color:#099">1</span>)
	}
	<span style="color:#00a">defer</span> db.<span style="color:#0a0">Close</span>()

	reportErr := <span style="color:#00a">func</span>(ev pq.ListenerEventType, err <span style="color:#0aa">error</span>) {
		<span style="color:#00a">if</span> err != <span style="color:#00a">nil</span> {
			log.<span style="color:#0a0">Printf</span>(<span style="color:#a50">&#34;Failed to start listener: %s&#34;</span>, err)
			os.<span style="color:#0a0">Exit</span>(<span style="color:#099">1</span>)
		}
	}

	<span style="color:#aaa;font-style:italic">//
</span><span style="color:#aaa;font-style:italic"></span>	<span style="color:#aaa;font-style:italic">// First, LISTEN to incoming events
</span><span style="color:#aaa;font-style:italic"></span>	<span style="color:#aaa;font-style:italic">//
</span><span style="color:#aaa;font-style:italic"></span>	listener := pq.<span style="color:#0a0">NewListener</span>(conf.PGuri, min_reconn, max_reconn, reportErr)
	err = listener.<span style="color:#0a0">Listen</span>(conf.Channel)
	<span style="color:#00a">if</span> err != <span style="color:#00a">nil</span> {
		log.<span style="color:#0a0">Printf</span>(
			<span style="color:#a50">&#34;Failed to LISTEN to channel &#39;%s&#39;: %s&#34;</span>,
			conf.Channel, err)
		<span style="color:#0aa">panic</span>(err)
	}
	log.<span style="color:#0a0">Printf</span>(
		<span style="color:#a50">&#34;Listening to notifications on channel \&#34;%s\&#34;&#34;</span>,
		conf.Channel)

	<span style="color:#aaa;font-style:italic">//
</span><span style="color:#aaa;font-style:italic"></span>	<span style="color:#aaa;font-style:italic">// Second, initialize the cache with the current values from the
</span><span style="color:#aaa;font-style:italic"></span>	<span style="color:#aaa;font-style:italic">// base table, only then proceed to process the notifications.
</span><span style="color:#aaa;font-style:italic"></span>	<span style="color:#aaa;font-style:italic">//
</span><span style="color:#aaa;font-style:italic"></span>	cache, err := <span style="color:#0a0">initCache</span>(db)

	<span style="color:#00a">if</span> err != <span style="color:#00a">nil</span> {
		log.<span style="color:#0a0">Printf</span>(<span style="color:#a50">&#34;Error initializing cache&#34;</span>)
		<span style="color:#0aa">panic</span>(err)
	}
	log.<span style="color:#0a0">Printf</span>(
		<span style="color:#a50">&#34;Cache initialized with %d entries.&#34;</span>,
		<span style="color:#0aa">len</span>(cache))

	<span style="color:#aaa;font-style:italic">//
</span><span style="color:#aaa;font-style:italic"></span>	<span style="color:#aaa;font-style:italic">// Third, grab notifications and process them by updating the
</span><span style="color:#aaa;font-style:italic"></span>	<span style="color:#aaa;font-style:italic">// counters that changed.
</span><span style="color:#aaa;font-style:italic"></span>	<span style="color:#aaa;font-style:italic">//
</span><span style="color:#aaa;font-style:italic"></span>	log.<span style="color:#0a0">Println</span>(<span style="color:#a50">&#34;Start processing notifications, waiting for events…&#34;</span>)

	reset := time.<span style="color:#0a0">Now</span>()
	<span style="color:#00a">for</span> {
		<span style="color:#0a0">waitForNotification</span>(listener, cache, conf.Idle)

		<span style="color:#00a">if</span> time.<span style="color:#0a0">Since</span>(reset) &gt;= conf.Sync {
			err := <span style="color:#0a0">materialize</span>(db, cache)

			<span style="color:#aaa;font-style:italic">// reset the cache *unless* there was an error!
</span><span style="color:#aaa;font-style:italic"></span>			<span style="color:#00a">if</span> err == <span style="color:#00a">nil</span> {
				cache = <span style="color:#0aa">make</span>(Cache)
				reset = time.<span style="color:#0a0">Now</span>()
			}
		}
	}
}

<span style="color:#00a">func</span> <span style="color:#0a0">processFlags</span>() *Config {
	<span style="color:#00a">var</span> conninfo <span style="color:#0aa">string</span> = <span style="color:#a50">&#34;postgres:///yesql?sslmode=disable&#34;</span>
	<span style="color:#00a">var</span> channel <span style="color:#0aa">string</span> = <span style="color:#a50">&#34;tweet.activity&#34;</span>

	syncPtr := flag.<span style="color:#0a0">Int</span>(<span style="color:#a50">&#34;sync&#34;</span>, <span style="color:#0aa">int</span>(sync_delay.<span style="color:#0a0">Seconds</span>()),
		<span style="color:#a50">&#34;Sync cache every SYNC seconds&#34;</span>)
	flag.<span style="color:#0a0">StringVar</span>(&amp;conninfo, <span style="color:#a50">&#34;pguri&#34;</span>, conninfo,
		<span style="color:#a50">&#34;PostgreSQL connection string&#34;</span>)
	flag.<span style="color:#0a0">StringVar</span>(&amp;channel, <span style="color:#a50">&#34;channel&#34;</span>, channel,
		<span style="color:#a50">&#34;LISTEN to this channel&#34;</span>)

	flag.<span style="color:#0a0">Parse</span>()

	sync := time.<span style="color:#0a0">Duration</span>(*syncPtr) * time.Second
	idle := sync / <span style="color:#099">4</span>

	<span style="color:#00a">return</span> &amp;Config{conninfo, channel, sync, idle}
}

<span style="color:#00a">func</span> <span style="color:#0a0">waitForNotification</span>(l *pq.Listener, cache Cache, timeout time.Duration) {
	<span style="color:#00a">select</span> {
	<span style="color:#00a">case</span> n := &lt;-l.Notify:
		<span style="color:#00a">var</span> c Counter
		err := json.<span style="color:#0a0">Unmarshal</span>([]<span style="color:#0aa">byte</span>(n.Extra), &amp;c)

		<span style="color:#00a">if</span> err != <span style="color:#00a">nil</span> {
			log.<span style="color:#0a0">Printf</span>(<span style="color:#a50">&#34;Failed to parse &#39;%s&#39;: %s&#34;</span>, n.Extra, err)
		} <span style="color:#00a">else</span> {
			log.<span style="color:#0a0">Printf</span>(<span style="color:#a50">&#34;Received event: %s&#34;</span>, n.Extra)
			<span style="color:#0a0">updateCounter</span>(cache, c)
		}

	<span style="color:#00a">case</span> &lt;-time.<span style="color:#0a0">After</span>(timeout):
		<span style="color:#00a">return</span>
	}
}

<span style="color:#00a">func</span> <span style="color:#0a0">initCache</span>(db *sql.DB) (Cache, <span style="color:#0aa">error</span>) {
	q := <span style="color:#a50">&#34;select messageid, rts, favs from tweet.message_with_counters;&#34;</span>

	rows, err := db.<span style="color:#0a0">Query</span>(q)
	<span style="color:#00a">if</span> err != <span style="color:#00a">nil</span> {
		<span style="color:#00a">return</span> <span style="color:#00a">nil</span>, err
	}
	cache := <span style="color:#0aa">make</span>(Cache)

	<span style="color:#00a">for</span> rows.<span style="color:#0a0">Next</span>() {
		c := Counter{}
		err := rows.<span style="color:#0a0">Scan</span>(&amp;c.MessageId, &amp;c.Rts, &amp;c.Favs)

		<span style="color:#00a">if</span> err != <span style="color:#00a">nil</span> {
			<span style="color:#00a">return</span> <span style="color:#00a">nil</span>, err
		}
		cache[c.MessageId] = &amp;c
	}
	err = rows.<span style="color:#0a0">Err</span>()
	<span style="color:#00a">if</span> err != <span style="color:#00a">nil</span> {
		<span style="color:#00a">return</span> <span style="color:#00a">nil</span>, err
	}
	<span style="color:#00a">return</span> cache, <span style="color:#00a">nil</span>
}

<span style="color:#00a">func</span> <span style="color:#0a0">materialize</span>(db *sql.DB, cache Cache) <span style="color:#0aa">error</span> {
	<span style="color:#00a">if</span> <span style="color:#0aa">len</span>(cache) == <span style="color:#099">0</span> {
		<span style="color:#00a">return</span> <span style="color:#00a">nil</span>
	}
	log.<span style="color:#0a0">Printf</span>(<span style="color:#a50">&#34;Materializing %d events from memory&#34;</span>, <span style="color:#0aa">len</span>(cache))

	q := <span style="color:#a50">`
</span><span style="color:#a50">with rec as
</span><span style="color:#a50"> (
</span><span style="color:#a50">   select rec.*
</span><span style="color:#a50">     from json_each($1) as t,
</span><span style="color:#a50">          json_populate_record(null::twcache.counters, value) as rec
</span><span style="color:#a50"> )
</span><span style="color:#a50"> insert into twcache.counters(messageid, rts, favs)
</span><span style="color:#a50">      select messageid, rts, favs
</span><span style="color:#a50">        from rec
</span><span style="color:#a50"> on conflict (messageid)
</span><span style="color:#a50">   do update
</span><span style="color:#a50">         set rts  = counters.rts + excluded.rts,
</span><span style="color:#a50">             favs = counters.favs + excluded.favs
</span><span style="color:#a50">       where counters.messageid = excluded.messageid
</span><span style="color:#a50">`</span>
	js, err := json.<span style="color:#0a0">Marshal</span>(cache)
	<span style="color:#00a">if</span> err != <span style="color:#00a">nil</span> {
		log.<span style="color:#0a0">Printf</span>(<span style="color:#a50">&#34;Error while materializing cache: %s&#34;</span>, err)
		<span style="color:#00a">return</span> err
	}

	_, err = db.<span style="color:#0a0">Query</span>(q, js)
	<span style="color:#00a">if</span> err != <span style="color:#00a">nil</span> {
		log.<span style="color:#0a0">Printf</span>(<span style="color:#a50">&#34;Error materliazing cache: %s&#34;</span>, err)
		<span style="color:#00a">return</span> err
	}
	<span style="color:#00a">return</span> <span style="color:#00a">nil</span>
}

<span style="color:#00a">func</span> <span style="color:#0a0">updateCounter</span>(cache Cache, c Counter) {
	_, found := cache[c.MessageId]

	<span style="color:#00a">if</span> found {
		cache[c.MessageId].Rts += c.Rts
		cache[c.MessageId].Favs += c.Favs
	} <span style="color:#00a">else</span> {
		cache[c.MessageId] = &amp;c
	}
}</code></pre></div>
<p>It&rsquo;s important to note that coded as such, we can use the function to both
materialize a full cache as fetched at startup, and to materialize the cache
we build in-memory while receiving notifications.</p>

<p>The query used to fetch the initial value of the cache and set it again at
startup is the following:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#00a">select</span><span style="color:#bbb"> </span>messageid,<span style="color:#bbb"> </span>rts,<span style="color:#bbb"> </span>favs<span style="color:#bbb">
</span><span style="color:#bbb">  </span><span style="color:#00a">from</span><span style="color:#bbb"> </span>tweet.message_with_counters;</code></pre></div>
<p>We use the view definition that we saw earlier to do the computations for
us, and fill in our in-memory cache data structure from the result of the
query.</p>

<p>The trigger processing has a cost of course, as we can see in the following
test:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-lisp" data-lang="lisp"><span style="color:#a00">CL-USER&gt;</span> (<span style="color:#a00">concurrency::concurrency-test</span> <span style="color:#099">100</span> <span style="color:#099">100</span> <span style="color:#099">35</span>)
<span style="color:#a00">Starting</span> <span style="color:#a00">benchmark</span> <span style="color:#a00">for</span> <span style="color:#a00">updates</span>
<span style="color:#a00">Updating</span> <span style="color:#a00">took</span> <span style="color:#099">8.428939</span> <span style="color:#a00">seconds,</span> <span style="color:#a00">did</span> <span style="color:#099">10000</span> <span style="color:#a00">rts</span>

<span style="color:#a00">Starting</span> <span style="color:#a00">benchmark</span> <span style="color:#a00">for</span> <span style="color:#a00">inserts</span>
<span style="color:#a00">Inserting</span> <span style="color:#a00">took</span> <span style="color:#099">10.351908</span> <span style="color:#a00">seconds,</span> <span style="color:#a00">did</span> <span style="color:#099">10000</span> <span style="color:#a00">rts</span></code></pre></div>
<p>Remember when reading those numbers that we can&rsquo;t compare them meaningfully
anymore. We installed our trigger after insert on <em>tweet.activity</em>, which
means that the update benchmark isn&rsquo;t calling any trigger whereas the insert
benchmark is calling our trigger function 10,000 times in this test.</p>

<p>About the concurrency, notifications are serialized at commit time in the
same way that the PostgreSQL commit log is serialized, so there&rsquo;s no extra
work for PostgreSQL here.</p>

<p>Our cache maintenance server received 10,000 notifications with a JSON
payload and then reported the cumulated figures to our cache table only
once, as we can see from the logs:</p>
<pre><code>2017/09/21 22:24:06 Received event: {&#34;messageid&#34;:35,&#34;rts&#34;:1,&#34;favs&#34;:0}
2017/09/21 22:24:06 Received event: {&#34;messageid&#34;:35,&#34;rts&#34;:1,&#34;favs&#34;:0}
2017/09/21 22:24:06 Received event: {&#34;messageid&#34;:35,&#34;rts&#34;:1,&#34;favs&#34;:0}
2017/09/21 22:24:06 Received event: {&#34;messageid&#34;:35,&#34;rts&#34;:1,&#34;favs&#34;:0}
2017/09/21 22:24:09 Materializing 1 events from memory</code></pre>
<p>Having a look at the cache, here&rsquo;s what we have:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#00a">table</span><span style="color:#bbb"> </span>twcache.counters;</code></pre></div><pre><code class="language-psql" data-lang="psql"> messageid │  rts   │ favs 
═══════════╪════════╪══════
         1 │  41688 │    0
         2 │ 222690 │    0
         3 │  22000 │    0
        33 │     -4 │    8
         5 │   7000 │    0
         6 │  30000 │    0
        35 │  10000 │    0
(7 rows)</code></pre>
<p>We can see the results of our tests, and in particular, the message with
<em>ids</em> from 1 to 6 are in the cache as expected. Remember the rules we
introduced earlier where the first thing we do when starting our cache
maintenance service is to <em>reset</em> the cache from the real values in the
database. That&rsquo;s how we got those values in the cache; alter all, the cache
service wasn&rsquo;t written when we ran our previous series of tests.</p>

<h2 id="limitations-of-listen-and-notify">Limitations of Listen and Notify</h2>

<p>It is crucial that an application using the PostgreSQL notification
capabilities are capable of missing events. Notifications are only sent to
connected client connections.</p>

<p>Any queueing mechanism requires that event accumulated when there&rsquo;s no
worker connected are kept available until next connection, and replication
is a special case of event queueing. It is not possible to implement
queueing correctly with PostgreSQL <em>listen/notify</em> feature.</p>

<p>A cache maintenance service really is the perfect use case for this
functionality, because it&rsquo;s easy to reset the cache at service start or
restart.</p>

<h2 id="listen-and-notify-support-in-drivers">Listen and Notify Support in Drivers</h2>

<p>Support for listen and notify PostgreSQL functionality depends on the driver
you&rsquo;re using. For instance, the Java JDBC driver documents the support at
<a href="https://jdbc.postgresql.org/documentation/head/listennotify.html">PostgreSQL™ Extensions to the JDBC
API</a>, and
quoting their page:</p>

<blockquote>
<p>A key limitation of the JDBC driver is that it cannot receive
asynchronous notifications and must poll the backend to check if any
notifications were issued. A timeout can be given to the poll function,
but then the execution of statements from other threads will block.</p>
</blockquote>

<p>There&rsquo;s still a full-length class implementation sample, so if you&rsquo;re using
Java check it out.</p>

<p>For Python, the <a href="http://initd.org/psycopg/">Psycopg</a> driver is the most
popular, and <a href="http://initd.org/psycopg/docs/advanced.html#asynchronous-notifications">Python asynchronous
notifications</a>
supports advanced techniques for avoiding <em>busy looping</em>:</p>

<blockquote>
<p>A simple application could poll the connection from time to time to check
if something new has arrived. A better strategy is to use some I/O
completion function such as select() to sleep until awakened by the kernel
when there is some data to read on the connection, thereby using no CPU
unless there is something to read.</p>
</blockquote>

<p>The Golang driver <a href="https://godoc.org/github.com/lib/pq">pq</a> also supports
<a href="https://godoc.org/github.com/lib/pq#hdr-Notifications">notifications</a> and
doesn&rsquo;t require polling. That&rsquo;s the one we&rsquo;ve been using this driver in our
example here.</p>

<p>For other languages, please check the documentation of your driver of choice.</p>

<h2 id="conclusion">Conclusion</h2>

<p>PostgreSQL implements several facilities that we can rely on to maintain an
application cache for data that changes often:</p>

<ul>
<li><p>In <a href="/blog/2018/07/computing-and-caching/">Computing and Caching</a>, we saw
how to use a MATERIALIZED VIEW to get a fixed snapshot of the data, and
then easily REFRESH it to implement our <strong>cache invalidation policy</strong>.</p>

<p>This technique is well adapted to use cases where you want to rebuild
your cache every once in a while, maybe every night, or several times a
day, down to maybe every five minutes if the refreshing of the cache is
really fast.</p></li>

<li><p>In <a href="/blog/2018/07/postgresql-event-based-processing/">PostgreSQL Event Based
Processing</a> we saw how
to use TRIGGERs to maintain a transactionally correct cache, and the
impact of such a choice on the scalability properties of your database
backend.</p>

<p>This solution is well suited to use case where the application only
receives a small amount of UPDATE traffic, and quite far apart, and
can&rsquo;t tolerate any lag when using the cache.</p></li>

<li><p>In today&rsquo;s article <a href="/blog/2018/07/postgresql-listen/notify/">PostgreSQL
LISTEN/NOTIFY</a> we saw how to
build an online cache maintenance service with PostgreSQL&rsquo;s advanced
notification features.</p>

<p>This solution is well suited to use cases where a small amount of lag
can be tolerated, up to maybe some seconds, most typically measured in
the hundreds of milliseconds.</p></li>
</ul>

<p>Again, we see that core PostgreSQL features allow application developers to
build exactly the facility they need. PostgreSQL really is
<a href="/tags/yesql/">YeSQL</a>!</p>
              
            </div>
          </div>
          <div style="margin-top: 1em;">
 <a href="https://theartofpostgresql.com" alt="The Art of PostgreSQL">
  <img src="/img/taopg-cta.jpg" style="width:90%; height: auto; margin-left: 5%">
 </a>
</div>

          <div id="post-footer" class="post-footer main-content-wrap">
            
              
                
                
                  <div class="post-footer-tags">
                    <span class="text-color-light text-small"></span><br/>
                    
  <a class="tag tag--primary tag--small" href="/tags/postgresql/">PostgreSQL</a>

  <a class="tag tag--primary tag--small" href="/tags/yesql/">YeSQL</a>

  <a class="tag tag--primary tag--small" href="/tags/concurrency/">Concurrency</a>

  <a class="tag tag--primary tag--small" href="/tags/listen/">LISTEN</a>

  <a class="tag tag--primary tag--small" href="/tags/notify/">NOTIFY</a>

  <a class="tag tag--primary tag--small" href="/tags/golang/">GoLang</a>

  <a class="tag tag--primary tag--small" href="/tags/json/">JSON</a>

                  </div>
                
              
            
            <div class="post-actions-wrap">
 <nav>
    <ul class="post-actions post-action-nav">
      
        <li class="post-action">
          
            <a class="post-action-btn btn btn--default tooltip--top" href="/blog/2018/07/batch-updates-and-concurrency/" data-tooltip="Batch Updates and Concurrency">
          
            <i class="fa fa-angle-left"></i>
            <span class="hide-xs hide-sm text-small icon-ml"></span>
          </a>
        </li>
        <li class="post-action">
          
            <a class="post-action-btn btn btn--default tooltip--top" href="/blog/2018/07/postgresql-event-based-processing/" data-tooltip="PostgreSQL Event Based Processing">
          
            <span class="hide-xs hide-sm text-small icon-mr"></span>
            <i class="fa fa-angle-right"></i>
          </a>
        </li>
      
    </ul>
  </nav>
  <ul class="post-actions post-action-share">
    
      <li class="post-action hide-lg hide-md hide-sm">
        <a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions">
          <i class="fa fa-share-alt"></i>
        </a>
      </li>
      <li class="post-action hide-xs">
        <a class="post-action-btn btn btn--default" target="new" href="https://plus.google.com/share?url=https%3a%2f%2ftapoueh.org%2fblog%2f2018%2f07%2fpostgresql-listen%2fnotify%2f">
          <i class="fa fa-google-plus"></i>
        </a>
      </li>
      <li class="post-action hide-xs">
        <a class="post-action-btn btn btn--default" target="new" href="https://www.facebook.com/sharer/sharer.php?u=https%3a%2f%2ftapoueh.org%2fblog%2f2018%2f07%2fpostgresql-listen%2fnotify%2f">
          <i class="fa fa-facebook-official"></i>
        </a>
      </li>
      <li class="post-action hide-xs">
        <a class="post-action-btn btn btn--default" target="new" href="https://twitter.com/intent/tweet?text=PostgreSQL%20LISTEN%2fNOTIFY with @tapoueh: https%3a%2f%2ftapoueh.org%2fblog%2f2018%2f07%2fpostgresql-listen%2fnotify%2f">
          <i class="fa fa-twitter"></i>
        </a>
      </li>
    
    
      <li class="post-action">
        <a class="post-action-btn btn btn--default" href="#disqus_thread">
          <i class="fa fa-comment-o"></i>
        </a>
      </li>
    
    <li class="post-action">
      
        <a class="post-action-btn btn btn--default" href="#table-of-contents">
      
        <i class="fa fa-list"></i>
      </a>
    </li>
  </ul>
</div>


            
              
                <div id="disqus_thread">
  <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
              
            
          </div>
        </article>
        <footer id="footer" class="main-content-wrap">
  <span class="copyrights">
    &copy; 2021 Dimitri Fontaine. 
  </span>
</footer>

      </div>
      <div id="bottom-bar" class="post-bottom-bar" data-behavior="5">
        <div class="post-actions-wrap">
 <nav>
    <ul class="post-actions post-action-nav">
      
        <li class="post-action">
          
            <a class="post-action-btn btn btn--default tooltip--top" href="/blog/2018/07/batch-updates-and-concurrency/" data-tooltip="Batch Updates and Concurrency">
          
            <i class="fa fa-angle-left"></i>
            <span class="hide-xs hide-sm text-small icon-ml"></span>
          </a>
        </li>
        <li class="post-action">
          
            <a class="post-action-btn btn btn--default tooltip--top" href="/blog/2018/07/postgresql-event-based-processing/" data-tooltip="PostgreSQL Event Based Processing">
          
            <span class="hide-xs hide-sm text-small icon-mr"></span>
            <i class="fa fa-angle-right"></i>
          </a>
        </li>
      
    </ul>
  </nav>
  <ul class="post-actions post-action-share">
    
      <li class="post-action hide-lg hide-md hide-sm">
        <a class="post-action-btn btn btn--default btn-open-shareoptions" href="#btn-open-shareoptions">
          <i class="fa fa-share-alt"></i>
        </a>
      </li>
      <li class="post-action hide-xs">
        <a class="post-action-btn btn btn--default" target="new" href="https://plus.google.com/share?url=https%3a%2f%2ftapoueh.org%2fblog%2f2018%2f07%2fpostgresql-listen%2fnotify%2f">
          <i class="fa fa-google-plus"></i>
        </a>
      </li>
      <li class="post-action hide-xs">
        <a class="post-action-btn btn btn--default" target="new" href="https://www.facebook.com/sharer/sharer.php?u=https%3a%2f%2ftapoueh.org%2fblog%2f2018%2f07%2fpostgresql-listen%2fnotify%2f">
          <i class="fa fa-facebook-official"></i>
        </a>
      </li>
      <li class="post-action hide-xs">
        <a class="post-action-btn btn btn--default" target="new" href="https://twitter.com/intent/tweet?text=PostgreSQL%20LISTEN%2fNOTIFY with @tapoueh: https%3a%2f%2ftapoueh.org%2fblog%2f2018%2f07%2fpostgresql-listen%2fnotify%2f">
          <i class="fa fa-twitter"></i>
        </a>
      </li>
    
    
      <li class="post-action">
        <a class="post-action-btn btn btn--default" href="#disqus_thread">
          <i class="fa fa-comment-o"></i>
        </a>
      </li>
    
    <li class="post-action">
      
        <a class="post-action-btn btn btn--default" href="#table-of-contents">
      
        <i class="fa fa-list"></i>
      </a>
    </li>
  </ul>
</div>


      </div>
      <div id="share-options-bar" class="share-options-bar" data-behavior="5">
  <ul class="share-options">
    <li class="share-option">
      <a class="share-option-btn" target="new" href="https://plus.google.com/share?url=https%3a%2f%2ftapoueh.org%2fblog%2f2018%2f07%2fpostgresql-listen%2fnotify%2f">
        <i class="fa fa-google-plus"></i><span></span>
      </a>
    </li>
    <li class="share-option">
      <a class="share-option-btn" target="new" href="https://www.facebook.com/sharer/sharer.php?u=https%3a%2f%2ftapoueh.org%2fblog%2f2018%2f07%2fpostgresql-listen%2fnotify%2f">
        <i class="fa fa-facebook-official"></i><span></span>
      </a>
    </li>
    <li class="share-option">
      <a class="share-option-btn" target="new" href="https://twitter.com/intent/tweet?text=PostgreSQL%20LISTEN%2fNOTIFY with @tapoueh: https%3a%2f%2ftapoueh.org%2fblog%2f2018%2f07%2fpostgresql-listen%2fnotify%2f">
        <i class="fa fa-twitter"></i><span></span>
      </a>
    </li>
  </ul>
</div>
<div id="share-options-mask" class="share-options-mask"></div>

    </div>
    
    <div id="about">
  <div id="about-card">
    <div id="about-btn-close">
      <i class="fa fa-remove"></i>
    </div>
    
      <img id="about-card-picture" src="//www.gravatar.com/avatar/7b615d104c506aa0a49e17151fa94d9f?s=110" alt="" />
    
    <h4 id="about-card-name">Dimitri Fontaine</h4>
    
      <div id="about-card-bio">PostgreSQL Major Contributor</div>
    
    
      <div id="about-card-job">
        <i class="fa fa-briefcase"></i>
        <br/>
        Open Source Software Engineer
      </div>
    
    
      <div id="about-card-location">
        <i class="fa fa-map-marker"></i>
        <br/>
        France
      </div>
    
  </div>
</div>

    

    
  
    
      
      <div id="cover" style="background-image:url('https://tapoueh.org/images/mayan-calendar.jpg');"></div>
    
  


    
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.2.4/jquery.min.js" integrity="sha256-BbhdlvQf/xTY9gja0Dq3HiwQF8LaCRTXxZKRutelT44=" crossorigin="anonymous"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js" integrity="sha256-/BfiIkHlHoVihZdc6TFuj7MmJ0TWcWsMXkeDFwhi0zw=" crossorigin="anonymous"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/2.1.7/js/jquery.fancybox.min.js" integrity="sha256-GEAnjcTqVP+vBp3SSc8bEDQqvWAZMiHyUSIorrWwH50=" crossorigin="anonymous"></script>


<script src="/js/script-pcw6v3xilnxydl1vddzazdverrnn9ctynvnxgwho987mfyqkuylcb1nlt.min.js"></script>


<script lang="javascript">
window.onload = updateMinWidth;
window.onresize = updateMinWidth;
document.getElementById("sidebar").addEventListener("transitionend", updateMinWidth);
function updateMinWidth() {
  var sidebar = document.getElementById("sidebar");
  var main = document.getElementById("main");
  main.style.minWidth = "";
  var w1 = getComputedStyle(main).getPropertyValue("min-width");
  var w2 = getComputedStyle(sidebar).getPropertyValue("width");
  var w3 = getComputedStyle(sidebar).getPropertyValue("left");
  main.style.minWidth = `calc(${w1} - ${w2} - ${w3})`;
}
</script>

<script>
$(document).ready(function() {
  hljs.configure({ classPrefix: '', useBR: false });
  $('pre.code-highlight > code, pre > code').each(function(i, block) {
    if (!$(this).hasClass('codeblock')) {
      $(this).addClass('codeblock');
    }
    hljs.highlightBlock(block);
  });
});
</script>


  
    
      <script>
        var disqus_config = function () {
          this.page.url = 'https:\/\/tapoueh.org\/blog\/2018\/07\/postgresql-listen\/notify\/';
          
            this.page.identifier = '\/blog\/2018\/07\/postgresql-listen\/notify\/'
          
        };
        (function() {
          
          
          if (window.location.hostname == "localhost") {
            return;
          }
          var d = document, s = d.createElement('script');
          var disqus_shortname = 'tapoueh';
          s.src = '//' + disqus_shortname + '.disqus.com/embed.js';

          s.setAttribute('data-timestamp', +new Date());
          (d.head || d.body).appendChild(s);
        })();
      </script>
    
  




    
  </body>
</html>

