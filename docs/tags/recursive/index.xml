<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Recursive on Dimitri Fontaine, PostgreSQL Expert</title>
    <link>https://tapoueh.org/tags/recursive/</link>
    <description>Recent content in Recursive on Dimitri Fontaine, PostgreSQL Expert</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 06 Feb 2018 23:24:17 +0100</lastBuildDate>
    
	<atom:link href="https://tapoueh.org/tags/recursive/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Find the number of the longest continuously rising days for a stock</title>
      <link>https://tapoueh.org/blog/2018/02/find-the-number-of-the-longest-continuously-rising-days-for-a-stock/</link>
      <pubDate>Tue, 06 Feb 2018 23:24:17 +0100</pubDate>
      
      <guid>https://tapoueh.org/blog/2018/02/find-the-number-of-the-longest-continuously-rising-days-for-a-stock/</guid>
      <description>&lt;p&gt;Today I want to react to an article that claims that &lt;a href=&#34;https://www.datasciencecentral.com/profiles/blogs/relational-algebra-is-the-root-of-sql-problems&#34;&gt;Relational Algebra Is
the Root of SQL
Problems&lt;/a&gt;
in which the author hand-waves the following position:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;SQL becomes more a hindrance to data manipulation than an efficient tool.
SQL’s greatest problem isn’t in the implementation level, but at its
theory foundation. The problem can’t be solved by application
optimization. Relational algebra isn’t sophisticated enough for handling
the complicated data manipulation scenarios.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Then they go on to several &lt;em&gt;arguments from authority&lt;/em&gt; to “prove” their
point. My reading of the article is that SQL is very hard when you didn&amp;rsquo;t
care to learn it, as most technologies are.&lt;/p&gt;

&lt;p&gt;In this article, we&amp;rsquo;re going to look at the &lt;em&gt;simple examples&lt;/em&gt; provided where
apparently SQL makes it so much harder to find a solution compared to
writing some Java or C++ code. Contrary to the original article, we go as
far as to actually writing both the SQL solution and a complete Python
solution, so that we can compare.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Exporting a Hierarchy in JSON: with recursive queries</title>
      <link>https://tapoueh.org/blog/2018/01/exporting-a-hierarchy-in-json-with-recursive-queries/</link>
      <pubDate>Wed, 31 Jan 2018 18:00:01 +0100</pubDate>
      
      <guid>https://tapoueh.org/blog/2018/01/exporting-a-hierarchy-in-json-with-recursive-queries/</guid>
      <description>&lt;p&gt;In another article here, entitled &lt;a href=&#34;https://tapoueh.org/blog/2017/09/on-json-and-sql/&#34;&gt;on JSON and
SQL&lt;/a&gt;, we saw in great details how to import
a data set only available as a giant JSON file. Then we normalized the data
set, so as to be able to write SQL and process our data. This approach is
sometimes very useful and was a good way to learn some of the JSON functions
provided by PostgreSQL.&lt;/p&gt;

&lt;p&gt;In this article, we&amp;rsquo;re going to use SQL to export the data from our
relational model into a JSON document. The trick that makes it complex in
this example is that we have a recursive data model, with a notion of a
&lt;em&gt;parent&lt;/em&gt; row that exists in the same table as the current one. That&amp;rsquo;s a nice
excuse to learn more about the SQL construct &lt;a href=&#34;https://www.postgresql.org/docs/current/static/queries-with.html&#34;&gt;WITH
RECURSIVE&lt;/a&gt;.&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>