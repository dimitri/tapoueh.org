<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>WITH on The Art of PostgreSQL</title>
    <link>https://tapoueh.org/tags/with/</link>
    <description>Recent content in WITH on The Art of PostgreSQL</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 31 Jan 2018 18:00:01 +0100</lastBuildDate><atom:link href="https://tapoueh.org/tags/with/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Exporting a Hierarchy in JSON: with recursive queries</title>
      <link>https://tapoueh.org/blog/2018/01/exporting-a-hierarchy-in-json-with-recursive-queries/</link>
      <pubDate>Wed, 31 Jan 2018 18:00:01 +0100</pubDate>
      
      <guid>https://tapoueh.org/blog/2018/01/exporting-a-hierarchy-in-json-with-recursive-queries/</guid>
      <description>&lt;p&gt;In another article here, entitled &lt;a href=&#34;https://tapoueh.org/blog/2017/09/on-json-and-sql/&#34;&gt;on JSON and
SQL&lt;/a&gt;, we saw in great details how to import
a data set only available as a giant JSON file. Then we normalized the data
set, so as to be able to write SQL and process our data. This approach is
sometimes very useful and was a good way to learn some of the JSON functions
provided by PostgreSQL.&lt;/p&gt;

&lt;p&gt;In this article, we&amp;rsquo;re going to use SQL to export the data from our
relational model into a JSON document. The trick that makes it complex in
this example is that we have a recursive data model, with a notion of a
&lt;em&gt;parent&lt;/em&gt; row that exists in the same table as the current one. That&amp;rsquo;s a nice
excuse to learn more about the SQL construct &lt;a href=&#34;https://www.postgresql.org/docs/current/static/queries-with.html&#34;&gt;WITH
RECURSIVE&lt;/a&gt;.&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>
