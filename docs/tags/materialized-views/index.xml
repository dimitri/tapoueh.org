<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Materialized Views on The Art of PostgreSQL</title>
    <link>https://tapoueh.org/tags/materialized-views/</link>
    <description>Recent content in Materialized Views on The Art of PostgreSQL</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 13 Jul 2018 13:10:21 +0200</lastBuildDate><atom:link href="https://tapoueh.org/tags/materialized-views/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Computing and Caching</title>
      <link>https://tapoueh.org/blog/2018/07/computing-and-caching/</link>
      <pubDate>Fri, 13 Jul 2018 13:10:21 +0200</pubDate>
      
      <guid>https://tapoueh.org/blog/2018/07/computing-and-caching/</guid>
      <description>&lt;p&gt;Let&amp;rsquo;s continue to dive in PostgreSQL Concurrency. In the previous article of
the series, &lt;a href=&#34;https://tapoueh.org/blog/2018/07/modeling-for-concurrency/&#34;&gt;Modeling for
Concurrency&lt;/a&gt;, we saw how to model
your application for highly concurrent activity. It was a follow-up to the
article entitled &lt;a href=&#34;https://tapoueh.org/blog/2018/07/postgresql-concurrency-isolation-and-locking/&#34;&gt;PostgreSQL Concurrency: Isolation and
Locking&lt;/a&gt;, which
was a primer on PostgreSQL isolation and locking properties and behaviors.&lt;/p&gt;

&lt;p&gt;Today&amp;rsquo;s article takes us a step further and builds on what we did in the
previous articles in our series. After having had all the characters from
Shakespeare&amp;rsquo;s &lt;em&gt;A Midsummer Night&amp;rsquo;s Dream&lt;/em&gt; tweet their own lines in our
database in &lt;a href=&#34;https://tapoueh.org/blog/2018/06/PostgreSQL-DML.md&#34;&gt;PostgreSQL Concurrency: Data Modification
Language&lt;/a&gt;, and having had them like a
retweet a lot in &lt;a href=&#34;https://tapoueh.org/blog/2018/07/postgresql-concurrency-isolation-and-locking/&#34;&gt;PostgreSQL Concurrency: Isolation and
Locking&lt;/a&gt;, it&amp;rsquo;s
time to think about how to display our counters in an efficient way.&lt;/p&gt;

&lt;p&gt;In this article, we&amp;rsquo;re going to think about when we should compute results
and when we should cache them for instant retrieval, all within the SQL
tooling. The SQL tooling for handling cache is a &lt;a href=&#34;https://www.postgresql.org/docs/current/static/sql-creatematerializedview.html&#34;&gt;MATERIALIZED
VIEW&lt;/a&gt;,
and it comes with &lt;strong&gt;cache invalidation&lt;/strong&gt; routines, of course.&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>
