<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Sql on Dimitri Fontaine, PostgreSQL Expert</title>
    <link>http://tapoueh.org/tags/sql/</link>
    <description>Recent content in Sql on Dimitri Fontaine, PostgreSQL Expert</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 03 Jul 2017 14:32:29 +0200</lastBuildDate>
    
	<atom:link href="http://tapoueh.org/tags/sql/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Playing with Unicode</title>
      <link>http://tapoueh.org/blog/2017/07/playing-with-unicode/</link>
      <pubDate>Mon, 03 Jul 2017 14:32:29 +0200</pubDate>
      
      <guid>http://tapoueh.org/blog/2017/07/playing-with-unicode/</guid>
      <description>&lt;p&gt;The reason why I like Unicode a lot is because it allows me to code in text
based environments and still have nice output. Today, we&amp;rsquo;re going to play
with
&lt;a href=&#34;https://en.wikipedia.org/wiki/Regional_Indicator_Symbol&#34;&gt;Regional Indicator Symbol&lt;/a&gt;,
which is implemented as a Unicode combinaison of letters from ðŸ‡¦ to ðŸ‡¿. For
instance, if you display ðŸ‡« then ðŸ‡· concatenated together, you get ðŸ‡«ðŸ‡·. Let&amp;rsquo;s
try that from our &lt;a href=&#34;https://www.postgresql.org/&#34;&gt;PostgreSQL&lt;/a&gt; prompt!&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>PostgreSQL and the calendar</title>
      <link>http://tapoueh.org/blog/2017/06/postgresql-and-the-calendar/</link>
      <pubDate>Fri, 30 Jun 2017 14:35:59 +0200</pubDate>
      
      <guid>http://tapoueh.org/blog/2017/06/postgresql-and-the-calendar/</guid>
      <description>&lt;p&gt;The modern calendar is a trap for the young engineer&amp;rsquo;s mind. We deal with
the calendar on a daily basis and until exposed to its insanity it&amp;rsquo;s rather
common to think that calendar based computations are easy. That&amp;rsquo;s until
you&amp;rsquo;ve tried to do it once. A very good read about how the current calendar
came to be the way it is now is Erik&amp;rsquo;s
Naggum &lt;a href=&#34;http://naggum.no/lugm-time.html&#34;&gt;The Long, Painful History of Time&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>SQL and Business Logic</title>
      <link>http://tapoueh.org/blog/2017/06/sql-and-business-logic/</link>
      <pubDate>Mon, 19 Jun 2017 13:30:19 +0200</pubDate>
      
      <guid>http://tapoueh.org/blog/2017/06/sql-and-business-logic/</guid>
      <description>&lt;p&gt;Business logic is &lt;em&gt;supposed to be&lt;/em&gt; the part of the application where you
deal with customer or user facing decisions and computations. It is often
argued that this part should be well separated from the rest of the
technical infrastructure of your code. Of course, SQL and relational
database design is meant to support your business cases (or user stories),
so then we can ask ourselves if SQL should be part of your business logic
implementation. Or actually, how much of your business logic should be SQL?&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Exploring a Data Set in SQL</title>
      <link>http://tapoueh.org/blog/2017/06/exploring-a-data-set-in-sql/</link>
      <pubDate>Tue, 13 Jun 2017 13:47:08 +0200</pubDate>
      
      <guid>http://tapoueh.org/blog/2017/06/exploring-a-data-set-in-sql/</guid>
      <description>&lt;p&gt;Sometimes you need to dive in an existing data set that you know very little
about. Let&amp;rsquo;s say we&amp;rsquo;ve been lucky to have had a high level description of
the business case covered by a database, and then access to it. Our next
step is figuring out data organisation, content and quality. Our tool box:
&lt;em&gt;the world&amp;rsquo;s most advanced open source
database&lt;/em&gt;, &lt;a href=&#34;https://www.postgresql.org&#34;&gt;PostgreSQL&lt;/a&gt;, and its &lt;em&gt;Structured
Query Language&lt;/em&gt;, SQL.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>How to Write SQL</title>
      <link>http://tapoueh.org/blog/2017/06/how-to-write-sql/</link>
      <pubDate>Thu, 08 Jun 2017 13:23:26 +0200</pubDate>
      
      <guid>http://tapoueh.org/blog/2017/06/how-to-write-sql/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://twitter.com/krisajenkins&#34;&gt;Kris Jenkins&lt;/a&gt; cooked up a very nice way
to embed SQL in your
code: &lt;a href=&#34;https://github.com/krisajenkins/yesql&#34;&gt;YeSQL for Clojure&lt;/a&gt;. The main
idea is that you should be writing your SQL queries in &lt;code&gt;.sql&lt;/code&gt; files in your
code repository and maintain them there.&lt;/p&gt;

&lt;p&gt;The idea is very good and it is now possible to find alternative
implementations of the &lt;a href=&#34;https://clojure.org&#34;&gt;Clojure&lt;/a&gt; &lt;em&gt;yesql&lt;/em&gt; library in
other languages. Today, we are going to have a look at one of them for
the &lt;a href=&#34;https://www.python.org&#34;&gt;python&lt;/a&gt; programming
language: &lt;a href=&#34;https://github.com/honza/anosql&#34;&gt;anosql&lt;/a&gt;.&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>