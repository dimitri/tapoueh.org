<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Common Lisp on Dimitri Fontaine, Expert PostgreSQL</title>
    <link>http://tapoueh.org/categories/common-lisp/</link>
    <description>Recent content in Common Lisp on Dimitri Fontaine, Expert PostgreSQL</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 22 Jan 2015 01:48:00 +0100</lastBuildDate>
    
	<atom:link href="http://tapoueh.org/categories/common-lisp/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>My First Slashdot Effect</title>
      <link>http://tapoueh.org/blog/2015/01/my-first-slashdot-effect/</link>
      <pubDate>Thu, 22 Jan 2015 01:48:00 +0100</pubDate>
      
      <guid>http://tapoueh.org/blog/2015/01/my-first-slashdot-effect/</guid>
      <description>Thanks to the Postgres Weekly issue #89 and a post to Hacker News front page (see Pgloader: A High-speed PostgreSQL Swiss Army Knife, Written in Lisp it well seems that I just had my first Slashdot effect&amp;hellip;
Well actually you know what? I don&amp;rsquo;t&amp;hellip;
So please consider using the new mirror http://dimitri.github.io/pgloader/ and maybe voting on Hacker News for either tooling around your favorite database system, PostgreSQL or your favorite programming language, Common Lisp&amp;hellip;</description>
    </item>
    
    <item>
      <title>New release: pgloader 3.2</title>
      <link>http://tapoueh.org/blog/2015/01/new-release-pgloader-3.2/</link>
      <pubDate>Fri, 16 Jan 2015 09:35:00 +0100</pubDate>
      
      <guid>http://tapoueh.org/blog/2015/01/new-release-pgloader-3.2/</guid>
      <description>PostgreSQL comes with an awesome bulk copy protocol and tooling best known as the COPY and \copy commands. Being a transactional system, PostgreSQL COPY implementation will ROLLBACK any work done if a single error is found in the data set you&amp;rsquo;re importing. That&amp;rsquo;s the reason why pgloader got started: it provides with error handling for the COPY protocol.
That&amp;rsquo;s basically what pgloader used to be all about
As soon as we have the capability to load data from unreliable sources, another use case appears on the horizon, and soon enough pgloader grew the capacity to load data from other databases, some having a more liberal notion of what is sane data type input.</description>
    </item>
    
    <item>
      <title>Turn your PostgreSQL queries into Charts</title>
      <link>http://tapoueh.org/blog/2014/08/turn-your-postgresql-queries-into-charts/</link>
      <pubDate>Mon, 25 Aug 2014 14:09:00 +0200</pubDate>
      
      <guid>http://tapoueh.org/blog/2014/08/turn-your-postgresql-queries-into-charts/</guid>
      <description>Earlier this year we did compare compare Aggregating NBA data, PostgreSQL vs MongoDB then talked about PostgreSQL, Aggregates and histograms where we even produced a nice Histogram chart directly within the awesome psql console. Today, let&amp;rsquo;s get that same idea to the next level, with pgcharts:
  The new pgcharts application
The application&amp;rsquo;s specifications are quite simple: edit an SQL query, set your categories and your data series, add in some legends, and get a nice chart.</description>
    </item>
    
    <item>
      <title>from Parsing to Compiling</title>
      <link>http://tapoueh.org/blog/2013/05/from-parsing-to-compiling/</link>
      <pubDate>Mon, 13 May 2013 11:08:00 +0200</pubDate>
      
      <guid>http://tapoueh.org/blog/2013/05/from-parsing-to-compiling/</guid>
      <description>Last week came with two bank holidays in a row, and I took the opportunity to design a command language for pgloader. While doing that, I unexpectedly stumbled accross a very nice AHAH! moment, and I now want to share it with you, dear reader.
AHAH, you&amp;rsquo;ll see!
The general approach I&amp;rsquo;m following code wise with that command language is to first get a code API to expose the capabilities of the system, then somehow plug the command language into that API thanks to a parser.</description>
    </item>
    
    <item>
      <title>Lost in scope</title>
      <link>http://tapoueh.org/blog/2013/01/lost-in-scope/</link>
      <pubDate>Wed, 09 Jan 2013 11:07:00 +0100</pubDate>
      
      <guid>http://tapoueh.org/blog/2013/01/lost-in-scope/</guid>
      <description>Thanks to Mickael on twitter I got to read an article about loosing scope with some common programming languages. As the blog article Lost in scope references functional programming languages and plays with both Javascript and Erlang, I though I had to try it out with Common Lisp too.
Let&amp;rsquo;s have fun with lambda!
So, here we go with a simple Common Lisp attempt. The Lost in scope article begins with defining a very simple function returning a boolean value, only true when it&amp;rsquo;s not monday.</description>
    </item>
    
    <item>
      <title>CL Happy Numbers</title>
      <link>http://tapoueh.org/blog/2012/11/cl-happy-numbers/</link>
      <pubDate>Tue, 20 Nov 2012 18:20:00 +0100</pubDate>
      
      <guid>http://tapoueh.org/blog/2012/11/cl-happy-numbers/</guid>
      <description>A while ago I stumbled upon Happy Numbers as explained in programming praxis, and offered an implementation of them in SQL and in Emacs Lisp. Yeah, I know. Why not, though?
Today I&amp;rsquo;m back on that topic and as I&amp;rsquo;m toying with Common Lisp I though it would be a good excuse to learn me some new tricks. As you can see from the earlier blog entry, last time I did attack the digits problem quite lightly.</description>
    </item>
    
    <item>
      <title>Concurrent Hello</title>
      <link>http://tapoueh.org/blog/2012/11/concurrent-hello/</link>
      <pubDate>Sun, 04 Nov 2012 23:04:00 +0100</pubDate>
      
      <guid>http://tapoueh.org/blog/2012/11/concurrent-hello/</guid>
      <description>Thanks to Mickael on twitter I ran into that article about implementing a very basic Hello World! program as a way to get into a new concurrent language or facility. The original article, titled Concurrent Hello World in Go, Erlang and C++ is all about getting to know The Go Programming Language better.
To quote the article:
 The first thing I always do when playing around with a new software platform is to write a concurrent &amp;ldquo;Hello World&amp;rdquo; program.</description>
    </item>
    
    <item>
      <title>Fast and stupid?</title>
      <link>http://tapoueh.org/blog/2012/08/fast-and-stupid/</link>
      <pubDate>Wed, 22 Aug 2012 16:05:00 +0200</pubDate>
      
      <guid>http://tapoueh.org/blog/2012/08/fast-and-stupid/</guid>
      <description>I stumbled onto an interesting article about performance when using python, called Python performance the easy(ish) way, where the author tries to get the bet available performances out of the dumbiest possible python code, trying to solve a very simple and stupid problem.
With so many smart qualifiers you can only guess that I did love the challenge. The idea is to write the simplest code possible and see how smarter you need to be when you need perfs.</description>
    </item>
    
    <item>
      <title>Solving Every Sudoku Puzzle</title>
      <link>http://tapoueh.org/blog/2012/07/solving-every-sudoku-puzzle/</link>
      <pubDate>Tue, 10 Jul 2012 20:37:00 +0200</pubDate>
      
      <guid>http://tapoueh.org/blog/2012/07/solving-every-sudoku-puzzle/</guid>
      <description>Peter Norvig published a while ago a very nice article titled Solving Every Sudoku Puzzle wherein he presents a programmatic approach to solving that puzzle game.
  The article is very well written and makes it easy to think that coming up with the code for such a solver is a very easy task, you apply some basic problem search principles and there you are. Which is partly true, in fact.</description>
    </item>
    
  </channel>
</rss>