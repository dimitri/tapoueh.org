<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
  <channel>
    <title>tail -f /dev/dim</title>
    <link>http://tapoueh.org/index.html</link>
    <description>Dimitri Fontaine's blog</description>
    <language>en-us</language>
    <generator>Emacs Muse</generator>
<item>
  <title>Concurrent Hello</title>
  <link>http://tapoueh.org/blog/2012/11/04-Concurrent-Hello.html</link>
  <description><![CDATA[<p>Thanks to <a href="https://twitter.com/mickael/status/265191809100181504">Mickael</a> on <em>twitter</em> I ran into that article about implementing a
very basic <em>Hello World!</em> program as a way to get into a new concurrent
language or facility. The original article, titled
<a href="http://himmele.blogspot.de/2012/11/concurrent-hello-world-in-go-erlang.html">Concurrent Hello World in Go, Erlang and C++</a> is all about getting to know
<a href="http://golang.org/">The Go Programming Language</a> better.</p>

<p>To quote the article:</p>

<blockquote>
<p class="quoted">
The first thing I always do when playing around with a new
software platform is to write a concurrent &quot;Hello World&quot; program. The
program works as follows: One active entity (e.g. thread, Erlang process,
Goroutine) has to print &quot;Hello &quot; and another one &quot;World!\n&quot; with the two
active entities synchronizing with each other so that the output always is
&quot;Hello World!\n&quot;.</p>

</blockquote>

<p>Here's my try in <a href="http://cliki.net/">Common Lisp</a> using <a href="http://lparallel.org/">lparallel</a>, the whole <code>20</code> lines of it:</p>

<pre class="src">
(<span style="color: #7f007f;">defun</span> <span style="color: #0000ff;">say-hello</span> (helloq worldq n)
  (<span style="color: #7f007f;">dotimes</span> (i n)
    (format t <span style="color: #bc8f8f;">"Hello "</span>)
    (lq:push-queue <span style="color: #da70d6;">:say-world</span> worldq)
    (lq:pop-queue helloq))
  (lq:push-queue <span style="color: #da70d6;">:quit</span> worldq))

(<span style="color: #7f007f;">defun</span> <span style="color: #0000ff;">say-world</span> (helloq worldq)
  (<span style="color: #7f007f;">when</span> (eq (lq:pop-queue worldq) <span style="color: #da70d6;">:say-world</span>)
    (format t <span style="color: #bc8f8f;">"World!~%"</span>)
    (lq:push-queue <span style="color: #da70d6;">:say-hello</span> helloq)
    (say-world helloq worldq)))

(<span style="color: #7f007f;">defun</span> <span style="color: #0000ff;">hello-world</span> (n)
  (<span style="color: #7f007f;">let*</span> ((lp:*kernel*    (lp:make-kernel 2))
         (channel        (lp:make-channel))
         (helloq         (lq:make-queue))
         (worldq         (lq:make-queue)))
    (lp:submit-task channel #'say-world helloq worldq)
    (lp:submit-task channel #'say-hello helloq worldq n)))
</pre>

<p>Unfortunately, I have some problem running that (both with <a href="http://ccl.clozure.com/">CCL</a> and <a href="http://sbcl.org/">sbcl</a>, in
two different Operating Systems). Sometimes the first entry get an extra
line feed in between <em>Hello</em> and <em>World!</em>, and it seems that I can only blame my
being a CL noob. I will need to learn some more, but this day is well over
now and what I wanted to be a nice and quick distraction is taking already
too much of my time. Too bad, as I wanted to say that I much prefer the
Common Lisp <em>syntax</em> over the <em>Go</em> one, and wanted to insist that I'll skip <em>Go</em>
some more...</p>
]]></description>
  <author>dim@tapoueh.org (Dimitri Fontaine)</author>
  <pubDate>Sun, 04 Nov 2012 23:04:00 +0100</pubDate>
  <guid isPermaLink="true">http://tapoueh.org/blog/2012/11/04-Concurrent-Hello.html</guid>
</item>
<item>
  <title>Fast and stupid?</title>
  <link>http://tapoueh.org/blog/2012/08/20-performance-the-easiest-way.html</link>
  <description><![CDATA[<p>I stumbled onto an interesting article about performance when using python,
called <a href="http://jiaaro.com/python-performance-the-easyish-way">Python performance the easy(ish) way</a>, where the author tries to get
the bet available performances out of the dumbiest possible python code,
trying to solve a very simple and stupid problem.</p>

<p>With so many <em>smart</em> qualifiers you can only guess that I did love the
challenge. The idea is to write the simplest code possible and see how
smarter you need to be when you need perfs. Let's have a try!</p>

<h3>local python results</h3>

<p class="first">Here's the code I did use to benchmark the python solution:</p>

<pre class="src">
<span style="color: #7f007f;">def</span> <span style="color: #0000ff;">sumrange</span>(arg):
    <span style="color: #7f007f;">return</span> <span style="color: #da70d6;">sum</span>(<span style="color: #da70d6;">xrange</span>(arg))

<span style="color: #7f007f;">def</span> <span style="color: #0000ff;">sumrange2</span>(arg):
    <span style="color: #b8860b;">x</span> = <span style="color: #b8860b;">i</span> = 0
    <span style="color: #7f007f;">while</span> i &lt; arg:
        <span style="color: #b8860b;">x</span> += i
        <span style="color: #b8860b;">i</span> += 1
    <span style="color: #7f007f;">return</span> x


<span style="color: #7f007f;">import</span> ctypes
<span style="color: #b8860b;">ct_sumrange</span> = ctypes.CDLL(<span style="color: #bc8f8f;">'/Users/dim/dev/CL/jiaroo/sumrange.so'</span>)

<span style="color: #7f007f;">def</span> <span style="color: #0000ff;">sumrange_ctypes</span>(arg):
    <span style="color: #7f007f;">return</span> ct_sumrange.sumrange(arg)

<span style="color: #7f007f;">if</span> <span style="color: #da70d6;">__name__</span> == <span style="color: #bc8f8f;">"__main__"</span>:
    <span style="color: #7f007f;">import</span> timeit
    t1 = timeit.Timer(<span style="color: #bc8f8f;">'import jiaroo; jiaroo.sumrange(10**10)'</span>)
    t2 = timeit.Timer(<span style="color: #bc8f8f;">'import jiaroo; jiaroo.sumrange2(10**10)'</span>)
    ct = timeit.Timer(<span style="color: #bc8f8f;">'import jiaroo; jiaroo.sumrange_ctypes(10**10)'</span>)

    <span style="color: #7f007f;">print</span> <span style="color: #bc8f8f;">'timing python sumrange(10**10)'</span>
    <span style="color: #7f007f;">print</span> <span style="color: #bc8f8f;">'xrange: %5fs'</span> % t1.timeit(1)
    <span style="color: #7f007f;">print</span> <span style="color: #bc8f8f;">'while:  %5fs'</span> % t2.timeit(1)
    <span style="color: #7f007f;">print</span> <span style="color: #bc8f8f;">'ctypes: %5fs'</span> % ct.timeit(1)
</pre>

<p>Oh. And the C code too, sorry about that.</p>

<pre class="src">
<span style="color: #da70d6;">#include</span> <span style="color: #bc8f8f;">&lt;stdio.h&gt;</span>

<span style="color: #228b22;">int</span> <span style="color: #0000ff;">sumrange</span>(<span style="color: #228b22;">int</span> <span style="color: #b8860b;">arg</span>)
{
    <span style="color: #228b22;">int</span> <span style="color: #b8860b;">i</span>, <span style="color: #b8860b;">x</span>;
    x = 0;

    <span style="color: #7f007f;">for</span> (i = 0; i &lt; arg; i++) {
        x = x + i;
    }
    <span style="color: #7f007f;">return</span> x;
}
</pre>

<p>And here's how I did compile it. The author of the inspiring article
insisted on stupid optimisation targets, I did follow him:</p>

<pre class="src">
gcc -shared -Wl,-install_name,sumrange.so -o sumrange.so -fPIC sumrange.c -O0
</pre>

<p>And here's the result I did get out of it:</p>

<pre class="src">
python jiaroo.py
timing python sumrange(10**10)
<span style="color: #da70d6;">xrange</span>: 927.039917s
<span style="color: #7f007f;">while</span>:  2377.291237s
ctypes: 5.297124s
</pre>

<p>Let's be fair, with <code>-O2</code> we get much better results:</p>

<pre class="src">
timing python sumrange(10**10)
ctypes: 1.065684s
</pre>


<h3>Common Lisp to the rescue</h3>

<p class="first">So let's have a try in Common Lisp, will you ask me, right?</p>

<p>Here's the code I did use, you can see three different tries:</p>

<pre class="src">
<span style="color: #b22222;">;;;; </span><span style="color: #b22222;">jiaroo.lisp
</span><span style="color: #b22222;">;;;</span><span style="color: #b22222;">
</span><span style="color: #b22222;">;;; </span><span style="color: #b22222;">See http://jiaaro.com/python-performance-the-easyish-way
</span><span style="color: #b22222;">;;;</span><span style="color: #b22222;">
</span><span style="color: #b22222;">;;; </span><span style="color: #b22222;">The goal here is to find out if CL needs to resort to C for very simple
</span><span style="color: #b22222;">;;; </span><span style="color: #b22222;">optimisation tricks like python apparently needs too, unless using pypy
</span><span style="color: #b22222;">;;; </span><span style="color: #b22222;">(to some extend).
</span>
(<span style="color: #7f007f;">in-package</span> #<span style="color: #da70d6;">:jiaroo</span>)

<span style="color: #b22222;">;;; </span><span style="color: #b22222;">"jiaroo" goes here. Hacks and glory await!
</span>
(<span style="color: #7f007f;">defun</span> <span style="color: #0000ff;">sumrange-loop</span> (max)
  <span style="color: #bc8f8f;">"return the sum of numbers from 1 to MAX"</span>
  (<span style="color: #7f007f;">let</span> ((sum 0))
    (<span style="color: #7f007f;">declare</span> (type (and unsigned-byte fixnum) max sum)
             (optimize speed))
    (<span style="color: #7f007f;">loop</span> for i fixnum from 1 to max do (incf sum i))))

(<span style="color: #7f007f;">defun</span> <span style="color: #0000ff;">sumrange-dotimes</span> (max)
  <span style="color: #bc8f8f;">"return the sum of numbers from 1 to MAX"</span>
  (<span style="color: #7f007f;">let</span> ((sum 0))
    (<span style="color: #7f007f;">declare</span> (type (and unsigned-byte fixnum) max sum)
             (optimize speed))
    (<span style="color: #7f007f;">dotimes</span> (i max sum)
      (incf sum i))))

(<span style="color: #7f007f;">defun</span> <span style="color: #0000ff;">pk-sumrange</span> (max)
  (<span style="color: #7f007f;">declare</span> (type (and unsigned-byte fixnum) max)
           (optimize speed))
  (<span style="color: #7f007f;">let</span> ((sum 0))
    (<span style="color: #7f007f;">declare</span> (type (and fixnum unsigned-byte) sum))
    (<span style="color: #7f007f;">dotimes</span> (i max sum)
      (setf sum (logand (+ sum i) most-positive-fixnum)))))

(<span style="color: #7f007f;">defmacro</span> <span style="color: #0000ff;">timing</span> (<span style="color: #228b22;">&amp;body</span> forms)
  <span style="color: #bc8f8f;">"return both how much real time was spend in body and its result"</span>
  (<span style="color: #7f007f;">let</span> ((start (gensym))
        (end (gensym))
        (result (gensym)))
    `(<span style="color: #7f007f;">let*</span> ((,start (get-internal-real-time))
            (,result (<span style="color: #7f007f;">progn</span> ,@forms))
            (,end (get-internal-real-time)))
       (values ,result (/ (- ,end ,start) internal-time-units-per-second)))))

(<span style="color: #7f007f;">defun</span> <span style="color: #0000ff;">bench-sumrange</span> (power)
  <span style="color: #bc8f8f;">"print execution time of both the previous functions"</span>
  (<span style="color: #7f007f;">let*</span> ((max (expt 10 power))
         (lp-time (<span style="color: #7f007f;">multiple-value-bind</span> (r s) (timing (sumrange-loop max)) s))
         (dt-time (<span style="color: #7f007f;">multiple-value-bind</span> (r s) (timing (sumrange-dotimes max)) s))
         (pk-time (<span style="color: #7f007f;">multiple-value-bind</span> (r s) (timing (pk-sumrange max)) s)))
    (format t <span style="color: #bc8f8f;">"timing common lisp sumrange 10**~d~%"</span> power)
    (format t <span style="color: #bc8f8f;">"loop:       ~2,3fs ~%"</span> lp-time)
    (format t <span style="color: #bc8f8f;">"dotimes:    ~2,3fs ~%"</span> dt-time)
    (format t <span style="color: #bc8f8f;">"pk dotimes: ~2,3fs ~%"</span> pk-time)))
</pre>

<p>And here's the results:</p>

<pre class="src">
CL-USER&gt; (bench-sumrange 10)
timing common lisp sumrange 10**10
loop:       11.213s
dotimes:    7.642s
pk dotimes: 22.185s
NIL
</pre>


<h3>Discussion</h3>

<p class="first">So python is very slow. C is pretty fast. And Common Lisp just in the
middle. Honnestly I expected better performances from my beloved Common Lisp
here, but I didn't try very hard, by using <a href="http://ccl.clozure.com/">Clozure Common Lisp</a> which is not
the quicker Common Lisp implementation around. For this very benchmark, if
you're seeking speed use either <a href="http://sbcl.org/">Steel Bank Common Lisp</a> or <a href="http://www.clisp.org/">CLISP</a> which is
known to have a pretty fast bignums implementation (which you don't need in
64 bits in that game).</p>

<p>On the other hand, I think that having to go write a C plugin and deal with
how to compile and deploy it in the middle of a python script is something
to avoid. When using Common Lisp you don't need to resort to that for the
<em>runtime</em> to get down from python <em>xrange</em> implementation at <code>927.039917s</code> down to
the <em>dotimes</em> implementation taking <code>7.642s</code>. That's about <code>121</code> times faster.</p>

<p>So while <code>C</code> is even better, and while I would like a Common Lisp guru to show
me how to get a better speed here, I still very much appreciate the solution
here.</p>

<p>Let's see the winning source code in <em>python</em> and <em>common lisp</em> to compare the
programmer side of things: how hard was it really to get <code>121</code> times faster?</p>

<pre class="src">
<span style="color: #7f007f;">def</span> <span style="color: #0000ff;">sumrange</span>(arg):
    <span style="color: #7f007f;">return</span> <span style="color: #da70d6;">sum</span>(<span style="color: #da70d6;">xrange</span>(arg))
</pre>

<pre class="src">
(<span style="color: #7f007f;">defun</span> <span style="color: #0000ff;">sumrange-dotimes</span> (max)
  <span style="color: #bc8f8f;">"return the sum of numbers from 1 to MAX"</span>
  (<span style="color: #7f007f;">let</span> ((sum 0))
    (<span style="color: #7f007f;">declare</span> (type (and unsigned-byte fixnum) max sum)
             (optimize speed))
    (<span style="color: #7f007f;">dotimes</span> (i max sum)
      (incf sum i))))
</pre>

<p>That's about it. Yes we can see some <em>manual</em> optimisation directives here,
which are optimisation <em>extra complexity</em>. Not to the same level as bringing a
compiled artifact that you need to build and deploy, though. Remember that
you will need to know the full path where to find the <code>sumrange.so</code> file on
the production system, in the optimised <em>python</em> case, so that's what we are
comparing against.</p>

<p>Here's what happens without the optimisation, and with a smaller target:</p>

<pre class="src">
CL-USER&gt; (time (jiaroo:sumrange-dotimes (expt 10 9)))
(JIAROO:SUMRANGE-DOTIMES (EXPT 10 9))
took 722,592 microseconds (0.722592 seconds) to run.
During that period, and with 2 available CPU cores,
     714,709 microseconds (0.714709 seconds) were spent in user mode
       1,183 microseconds (0.001183 seconds) were spent in system mode
499999999500000000

CL-USER&gt; (time (<span style="color: #7f007f;">let</span> ((sum 0)) (<span style="color: #7f007f;">dotimes</span> (i (expt 10 9) sum) (incf sum i))))
(<span style="color: #7f007f;">LET</span> ((SUM 0)) (<span style="color: #7f007f;">DOTIMES</span> (I (EXPT 10 9) SUM) (INCF SUM I)))
took 2,174,767 microseconds (2.174767 seconds) to run.
During that period, and with 2 available CPU cores,
     2,156,549 microseconds (2.156549 seconds) were spent in user mode
        10,225 microseconds (0.010225 seconds) were spent in system mode
499999999500000000
</pre>

<p>We get a <code>3</code> times speed-up from those 2 lines of lisp optimisation
directives, which is pretty good. And it's exponential as I didn't have the
patience to actually wait until the non optimised <code>10^10</code> run finished, I
killed it.</p>


<h3>Conclusion</h3>

<p class="first">That's a case here where I don't know how to reach <code>C</code> level of performances
with Common Lisp, which could just be because I don't know yet how to do.</p>

<p>Still, getting a <code>121</code> times speedup when compared to the pure <em>python</em> version
of the code is pretty good and encourages me to continue diving into Common
Lisp.</p>
]]></description>
  <author>dim@tapoueh.org (Dimitri Fontaine)</author>
  <pubDate>Wed, 22 Aug 2012 16:05:00 +0200</pubDate>
  <guid isPermaLink="true">http://tapoueh.org/blog/2012/08/20-performance-the-easiest-way.html</guid>
</item>
<item>
  <title>Solving Every Sudoku Puzzle</title>
  <link>http://tapoueh.org/blog/2012/07/10-solving-sudoku.html</link>
  <description><![CDATA[<p><a href="http://norvig.com/">Peter Norvig</a> published a while ago a very nice article titled
<a href="http://norvig.com/sudoku.html">Solving Every Sudoku Puzzle</a> wherein he presents a programmatic approach to
solving that puzzle game.</p>

<center>
<p><a class="image-link" href="http://en.wikipedia.org/wiki/Sudoku">
<img src="../../../images/sudoku.png"></a></p>
</center>

<p>The article is very well written and makes it easy to think that coming up
with the code for such a solver is a very easy task, you apply some basic
problem search principles and there you are. Which is partly true, in fact.
Also, he uses <code>python</code>, and that means that a lot of trivial programming
activities are not a concern anymore, such as memory management.</p>

<p>As I've been teaching myself <a href="http://www.cliki.net/Common%20Lisp">Common Lisp</a> for some weeks now I though I would
like to read a lisp version of his code, and the article even has a section
titled <em>Translations</em>. Unfortunately, no lisp version is available there. One
might argue that <a href="http://clojure.org/">Clojure</a> is a decent enough lisp, but my current quest is
all about <em>Common Lisp</em> really. So I had to write one myself.</p>

<pre class="src">
CL-USER&gt; (sudoku:print-puzzle
          (sudoku:solve-grid
<span style="color: #bc8f8f;">"5300700006001950000980000608000600034008030017000200060600002800004190050000800</span><span style="color: #ffff00; background-color: #ff0000; font-weight: bold;">79"))</span>
5 3 4 | 6 7 8 | 9 1 2
6 7 2 | 1 9 5 | 3 4 8
1 9 8 | 3 4 2 | 5 6 7
------+-------+------
8 5 9 | 7 6 1 | 4 2 3
4 2 6 | 8 5 3 | 7 9 1
7 1 3 | 9 2 4 | 8 5 6
------+-------+------
9 6 1 | 5 3 7 | 2 8 4
2 8 7 | 4 1 9 | 6 3 5
3 4 5 | 2 8 6 | 1 7 9
took 1,974 microseconds (0.001974 seconds) to run.
During that period, and with 2 available CPU cores,
     1,894 microseconds (0.001894 seconds) were spent in user mode
        88 microseconds (0.000088 seconds) were spent in system mode
 174,320 bytes of memory allocated.
#&lt;SUDOKU::PUZZLE #x3020023BB9FD&gt;
</pre>

<h3>Comments on the python version</h3>

<p class="first">Norvig's article is very well written, I think. By that I mean that by
reading it you're confident that you've understood the problem and how the
solution is articulated, so you almost think you don't need to really try to
understand the code, it's just an illustration of the text.</p>

<p>Well, not so much. When you want to port the exact same algorithm you have
to understand exactly what the code is doing so that you're not implementing
something else. All the more when, as I did, you want to use some other data
structure.</p>

<p>My goal was not to rewrite the code as-is, but to try and come up with
<em>idiomatic</em> lisp code implementing Norvig's solution. So rather than using
<em>strings</em> and <em>dictionaries</em> (in lisp, they still call them a <a href="http://www.lispworks.com/documentation/lw50/CLHS/Body/f_mk_has.htm">hash table</a>) I've
been using more natural data structures.</p>

<p>The <em>python</em> code is really uneasy to follow, full of functional programming
veteran tricks. I mean avoiding <em>exceptions</em> and simply returning <code>False</code>
whenever there's a problem, and using functions such as <code>all</code> and <code>some</code> to
manage that. It's certainly working, it's not making the code any easier to
read.</p>

<p>To summarize, that code looks like it's been written by someone smart who
didn't want to spend more than a couple of hours on it, and did take all
known trustworthy shortcuts he could to achieve that goal. Quality and
readability certainly weren't the key motive. I've been quite deceived after
reading a very good article.</p>


<h3>Comments on the common lisp version</h3>

<p class="first">Keep in mind that I'm just a <em>Common Lisp</em> newbie. I've been told some good
pieces of advice by knowledgeable people though, so with some luck my
implementation is somewhat <em>lispy</em> enough.</p>

<p>So we start by defining some data structures and low-level functions to
build up the more complex one, so that it's easier to read and debug. The
<em>sudoku</em> puzzle is then a grid of digits and a grid of possible values in
places where the digits are yet unknown.</p>

<p>The way to represent that 9x9 grid is with using <a href="http://www.lispworks.com/documentation/lw51/CLHS/Body/f_mk_ar.htm">make-array</a>:</p>

<pre class="src">
(make-array '(9 9)
            <span style="color: #da70d6;">:element-type</span> '(integer 0 9)
            <span style="color: #da70d6;">:initial-element</span> 0)
</pre>

<p>Then the possible values. I though about using a <code>bit-vector</code> (and actually I
did implement it that way), then I've been told that the <em>Common Lisp</em> way to
approach that is using <a href="http://psg.com/~dlamkins/sl/chapter18.html">2-complement integer representation</a>, as we have
plenty of functions to operate numbers that way. I wouldn't believe that
would make the code simpler, but in fact it really did, see:</p>

<pre class="src">
CL-USER&gt; #b111111111
511
CL-USER&gt; (logcount #b111111111)
9
CL-USER&gt; (logcount 511)
9
CL-USER&gt; (logbitp 3 #b100100100)
NIL
CL-USER&gt; (logbitp 2 #b100100100)
T
CL-USER&gt; (format nil <span style="color: #bc8f8f;">"~2r"</span> (logxor #b111111111 (ash 1 4)))
<span style="color: #bc8f8f;">"111101111"</span>
CL-USER&gt; (logbitp 4 (logxor #b111111111 (ash 1 4)))
NIL
</pre>

<p>With that in mind, we can write the following code:</p>

<pre class="src">
(<span style="color: #7f007f;">defun</span> <span style="color: #0000ff;">count-remaining-possible-values</span> (possible-values)
  <span style="color: #bc8f8f;">"How many possible values are left in there?"</span>
  <span style="color: #b22222;">;; </span><span style="color: #b22222;">we could raise an empty-values condition if we get 0...
</span>  (logcount possible-values))

(<span style="color: #7f007f;">defun</span> <span style="color: #0000ff;">first-set-value</span> (possible-values)
  <span style="color: #bc8f8f;">"Return the index of the first set value in POSSIBLE-VALUES."</span>
  (+ 1 (floor (log possible-values 2))))

(<span style="color: #7f007f;">defun</span> <span style="color: #0000ff;">only-possible-value-is?</span> (possible-values value)
  <span style="color: #bc8f8f;">"Return a generalized boolean which is true when the only value found in
   POSSIBLE-VALUES is VALUE"</span>
  (and (logbitp (- value 1) possible-values)
       (= 1 (logcount possible-values))))

(<span style="color: #7f007f;">defun</span> <span style="color: #0000ff;">list-all-possible-values</span> (possible-values)
  <span style="color: #bc8f8f;">"Return a list of all possible values to explore"</span>
  (<span style="color: #7f007f;">loop</span> for i from 1 to 9
     when (logbitp (- i 1) possible-values)
     collect i))

(<span style="color: #7f007f;">defun</span> <span style="color: #0000ff;">value-is-set?</span> (possible-values value)
  <span style="color: #bc8f8f;">"Return a generalized boolean which is true when given VALUE is possible
   in POSSIBLE-VALUES"</span>
  (logbitp (- value 1) possible-values))

(<span style="color: #7f007f;">defun</span> <span style="color: #0000ff;">unset-possible-value</span> (possible-values value)
  <span style="color: #bc8f8f;">"return an integer representing POSSIBLE-VALUES with VALUE unset"</span>
  (logxor possible-values (ash 1 (- value 1))))
</pre>

<p>You can see here that I was also under the influence of a recent reading
about <a href="http://gar1t.com/blog/2012/06/10/solving-embarrassingly-obvious-problems-in-erlang/">making it obvious</a>, or so called <a href="http://dieswaytoofast.blogspot.fr/2012/07/erlang-why-so-many-seemingly-identical.html">intentional programming</a>, following
what <a href="http://armstrongonsoftware.blogspot.fr/">Joe Armstrong</a> has to say about it:</p>

<blockquote>
<p class="quoted"><em>Intentional programming is a name I give to a style of programming where
the reader of a program can easily see what the programmer intended by
their code. The intention of the code should be obvious from the names
of the functions involved and not be inferred by analysing the structure
of the code. (Reading the code should) precisely expresses the intention
of the programmer—here no guesswork or program analysis is involved, we
clearly read what was intended.</em></p>
</blockquote>

<p>So there we go with function names such as <code>count-remaining-possible-values</code>,
that will help when reading some more complex code, as in the following, the
meat of the solution:</p>

<pre class="src">
(<span style="color: #7f007f;">defmethod</span> <span style="color: #0000ff;">eliminate</span> ((puzzle puzzle) row col value)
  <span style="color: #bc8f8f;">"Eliminate given VALUE from possible values in cell ROWxCOL of PUZZLE, and
   propagate when needed"</span>
  (<span style="color: #7f007f;">with-slots</span> (grid values) puzzle
    <span style="color: #b22222;">;; </span><span style="color: #b22222;">if already unset, work is already done
</span>    (<span style="color: #7f007f;">when</span> (value-is-set? (aref values row col) value)
      <span style="color: #b22222;">;; </span><span style="color: #b22222;">eliminate the value from the set of possible values
</span>      (<span style="color: #7f007f;">let*</span> ((possible-values
              (unset-possible-value (aref values row col) value)))
        (setf (aref values row col) possible-values)

        <span style="color: #b22222;">;; </span><span style="color: #b22222;">now if we're left with a single possible value
</span>        (<span style="color: #7f007f;">when</span> (= 1 (count-remaining-possible-values possible-values))
          (<span style="color: #7f007f;">let</span> ((found-value (first-set-value possible-values)))
            <span style="color: #b22222;">;; </span><span style="color: #b22222;">update the main grid
</span>            (setf (aref grid row col) found-value)

            <span style="color: #b22222;">;; </span><span style="color: #b22222;">eliminate that value we just found in all peers
</span>            (eliminate-value-in-peers puzzle row col found-value)))

        <span style="color: #b22222;">;; </span><span style="color: #b22222;">now check if any unit has a single possible place for that value
</span>        (<span style="color: #7f007f;">loop</span>
           for (r . c)
           in (list-places-with-single-unit-solution puzzle row col value)
           do (assign puzzle r c value))))))
</pre>

<p>So that lisp code is quite verbose and at 389 lines almost doubles the 201
lines Norvig had. When clarity is part of the goal, that's hard to avoid, I
hope I made a good case that this is not due to lisp being overly verbose by
itself.</p>


<h3>Comments on the development environment</h3>

<p class="first">Or why I even considered <em>Common Lisp</em> as an interesting language for that
kind of exercise, and some more. <em>I'll have to tell about re-sharding data
live with 16 threads and 256 databases, all in CL, someday</em>.</p>

<p>So I've been doing some <em>Emacs Lisp</em> development for a while now, and the part
that makes that so much fun is the instant reward. You write some code in
your editor, type a key chord (usually, that's <code>C-M-x runs the command
eval-defun</code>) and your code is loaded up, ready to be tested. In <em>Emacs Lisp</em>
the test can be simply using your editor and watching the new behavior
taking place, or playing in the <code>M-x ielm</code> console. When the code is not
ready, it crashes, and you're left in the interactive debugger, where you
can use <code>C-x C-e runs the command eval-last-sexp</code> to evaluate any expression
in your source and see its value in the current <em>debug frame</em>.</p>

<p>That way of working is a huge productivity boost, that I've been missing
much when getting back to writing C code for PostgreSQL. I can't <code>C-M-x</code> the
current function and go write some <code>SQL</code> to test it right away, I have to
<em>compile</em> the whole source tree, then <em>install</em> the new binaries, then <em>restart</em>
the test server and then open up a <em>psql</em> console to interact with the new
code. Of course I could just <code>make check</code> and watch the results, but then if I
attach a <em>debugger</em> it complains that the code on-disk is more recent than the
code in the <em>core dump</em>.</p>

<p>What if you want <em>Emacs Lisp</em> integrated facilities and something made for
general programming rather than suited to building a text editor? Don't get
me wrong, you can probably find more production ready code in <em>elisp</em> than in
many other languages, just because Emacs has been there for about 35 years.
Editor targeted production code, though.</p>

<p>This integrated development cycle is all the same when you're using <em>Common
Lisp</em>. The awesome <a href="http://common-lisp.net/project/slime/">Superior Lisp Interaction Mode for Emacs</a> is providing
exactly that experience. Just run <code>M-x slime</code> and then as you define your code
you can <code>C-M-x</code> the function at point, see the compilation errors and warnings
if any in the associated <em>REPL</em>, and just try your code. I tend to mostly play
in the command line, it's possible to just use <code>C-x C-e</code> while typing too.</p>


<h3>Performances</h3>

<p class="first">Of course we do care! After all the original article came with a quite
detailed performance analysis with graphs and all. I won't be reproducing
that, sorry. I'll just show you what penalty you get for using an older
language specification, much more dynamic and with more features than
python, and with a great, scratch that, awesome development environment.</p>

<p>Oh wait, that's the other way round, no penalty, it's actually so much
faster!</p>

<h4>Python version perfs</h4>

<p class="first">The results I got on my desktop machine are about twice as fast as in the
original article, I guess newer machines and newer python have something to
say for that:</p>

<pre class="src">
  dim ~/dev/CL/sudoku python sudoku.dim.py
  All tests pass.
  Solved 50 of 50 easy puzzles (avg 0.01 secs (151 Hz), max 0.01 secs).
  Solved 95 of 95 hard puzzles (avg 0.02 secs (42 Hz), max 0.12 secs).
  Solved 11 of 11 hardest puzzles (avg 0.01 secs (115 Hz), max 0.01 secs).
</pre>

<p>That makes an average of <code>(50*151 + 95*42 + 11*115) / (50+95+11) =
82Hz</code>.</p>

<p>That seems pretty good, let's continue.</p>

<p>As you can see I've cut away the <em>random puzzle</em> part, that's because I was
too lazy to implement that part, which didn't seem all that interesting to
me. If you think that's a problem and need solving, I accept patches.</p>


<h4>Common lisp version perfs</h4>

<p class="first">When using <a href="http://sbcl.org/">SBCL</a> on the same machine, what I got was:</p>

<pre class="src">
  (sudoku:solve-example-grids)
  Solved 50 of 50 easy puzzles (avg .0021 sec (471.7 Hz), max 0.015 secs).
  Solved 95 of 95 hard puzzles (avg .0022 sec (446.0 Hz), max 0.008 secs).
  Solved 11 of 11 hardest puzzles (avg .0018 sec (550.0 Hz), max 0.003 secs).
</pre>

<p>With the same way to compute the average, we now have <code>461.6Hz</code>.</p>

<p>Now, that's between 3 times and more than <strong>10 times faster</strong> than the python
version (taken collection per collection), for a comparable effort, a much
better development environment, and the same all dynamic no explicit
compiling approach.</p>



<h3>Conclusion</h3>

<p class="first">I guess I'm fond of <em>Common Lisp</em>, which I already saw coming (so did you,
right?), and now I have some public article and code to share about why :)</p>

<p>The code is hosted at <a href="https://github.com/dimitri/sudoku">https://github.com/dimitri/sudoku</a> if you're
interested, with the necessary files to reproduce, some docs, etc.</p>

<p>Also, apart from using <em>integers</em> as <em>bitfields</em>, which I did more for being
lispy than for performances, I did very little effort for optimizing the
code. It's quite naive in this respect, yet allow me an average of <code>461.6Hz</code>
rather than <code>82Hz</code>, that's <strong><em>5.6 times faster</em></strong> average.</p>

<p>So yes, I will continue to invest some precious time in <em>Common Lisp</em> as a
very good interactive scripting language, and maybe more than that.</p>
]]></description>
  <author>dim@tapoueh.org (Dimitri Fontaine)</author>
  <pubDate>Tue, 10 Jul 2012 20:37:00 +0200</pubDate>
  <guid isPermaLink="true">http://tapoueh.org/blog/2012/07/10-solving-sudoku.html</guid>
</item>
  </channel>
</rss>
