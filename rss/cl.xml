<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
  <channel>
    <title>tail -f /dev/dim</title>
    <link>http://tapoueh.org/index.html</link>
    <description>Dimitri Fontaine's blog</description>
    <language>en-us</language>
    <generator>Emacs Muse</generator>
<item>
  <title>Playing with pgloader</title>
  <link>http://tapoueh.org/blog/2013/02/12-playing-with-pgloader.html</link>
  <description><![CDATA[<p>While making progress with both <a href="http://wiki.postgresql.org/wiki/Event_Triggers">Event Triggers</a> and <a href="http://tapoueh.org/blog/2013/01/08-Extensions-Templates.html">Extension Templates</a>, I
needed to make a little break. My current keeping sane mental exercise seems
to mainly involve using <em>Common Lisp</em>, a programming language that ships with
about all the building blocks you need.</p>

<center>
<p><img src="../../../images/made-with-lisp.png" alt=""></p>
</center>

<center>
<p><em>Yes, that old language brings so much on the table</em></p>
</center>

<p>When using <em>Common Lisp</em>, you have an awesome interactive development
environment where you can redefine function and objects <em>while testing them</em>.
That means you don't have to quit the interpreter, reload the new version of
the code and put the interactive test case together all over again after a
change. Just evaluate the change in the interactive environement: functions
are compiled incrementally over their previous definition, objects whose
classes have changed are migrated live.</p>

<p>See, I just said <em>objects</em> and <em>classes</em>. <em>Common Lisp</em> comes with some advanced
<em>Object Oriented Programming</em> facilities named <a href="http://www.aiai.ed.ac.uk/~jeff/clos-guide.html">CLOS</a> and <a href="http://www.alu.org/mop/index.html">MOP</a> where the <em>Java</em> and
<em>Python</em> and <em>C++</em> object models are just a subset of what you're being offered.
Hint, those don't have <a href="http://en.wikipedia.org/wiki/Multiple_dispatch">Multiple Dispatch</a>.</p>

<p>And you have a very sophisticated <a href="http://www.gigamonkeys.com/book/beyond-exception-handling-conditions-and-restarts.html">Condition System</a> where <em>Exceptions</em> are just
a subset of what you can do (hint: have a look a <a href="http://www.gigamonkeys.com/book/beyond-exception-handling-conditions-and-restarts.html#restarts">restarts</a> and tell me you
didn't wish your programming language of choice had them). And it continues
that way for about any basic building bloc you might want to be using.</p>

<h3>Loading data</h3>

<p class="first">Back to <a href="http://tapoueh.org/pgsql/pgloader.html">pgloader</a> will you tell me. Right. I've been spending a couple of
evening on hacking on the new version of pgloader in <em>Common Lisp</em>, and wanted
to share some preliminary results.</p>

<center>
<p><img src="../../../images/toy-loader.320.jpg" alt=""></p>
</center>

<center>
<p><em>Playing with the loader</em></p>
</center>

<p>The current status of the new <em>pgloader</em> still is pretty rough, if you're not
used to develop in Common Lisp you might not find it ready for use yet. I'm
still working on the internal APIs and trying to make something clean and
easy to use for a developer, and then I will provide some external ways to
play with it, user oriented. I missed that step once with the <em>Python</em> based
version of the tool, I don't want to do the same errors again this time.</p>

<p>So here's a test run with the current <em>pgloader</em>, on a small enough data set
of <code>226 MB</code> of <code>CSV</code> files.</p>

<pre class="src">
time python pgloader.py -R.. --summary -Tc ../pgloader.dbname.conf

Table name        |    duration |    size |  copy rows |     errors
====================================================================
aaaaaaaaaa_aaaa   |      2.148s |       - |      24595 |          0
bbbbbbbbbb_bbbb...|      0.609s |       - |        326 |          0
cccccccccc_cccc...|      2.868s |       - |      25126 |          0
dddddddddd_dddd...|      0.638s |       - |          8 |          0
eeeeeeeeee_eeee...|      2.874s |       - |      36825 |          0
ffffffffff_ffffff |      0.667s |       - |        624 |          0
gggggggggg_gggg...|      0.847s |       - |       5638 |          0
hhh_hhhhhhh       |      9.907s |       - |     120159 |          0
iii_iiiiiiiiiiiii |      0.574s |       - |        661 |          0
jjjjjjj           |      6.647s |       - |      30027 |          0
kkk_kkkkkkkkk     |      0.439s |       - |         12 |          0
lll_llllll        |      0.308s |       - |          4 |          0
mmmm_mmm          |      2.139s |       - |      29669 |          0
nnnn_nnnnnn       |      8.555s |       - |     100197 |          0
oooo_ooooo        |     13.781s |       - |      93555 |          0
pppp_ppppppp      |      8.275s |       - |      76457 |          0
qqqq_qqqqqqqqqqqq |      8.568s |       - |     126159 |          0
====================================================================
Total             |  01m09.902s |       - |     670042 |          0
</pre>


<h3>Streaming data</h3>

<p class="first">With the new code in <em>Common Lisp</em>, I could benefit from real multi threading
and higher level abstraction to make it easy to use: <a href="http://lparallel.org/">lparallel</a> is a lib
providing exactly what I need here, with <em>workers</em> and <em>queues</em> to communicate
data in between them.</p>

<p>What I'm doing is that two threads are separated, one is reading the data
from either a <code>CSV</code> file or a <em>MySQL</em> database directly, and pushing that data
in the queue; while the other thread is pulling data from the queue and
writing it into our <a href="http://www.postgresql.org/">PostgreSQL</a> database.</p>

<pre class="src">
CL-USER&gt; (pgloader.csv:import-database <span style="color: #bc8f8f;">"dbname"</span>
            :csv-path-root <span style="color: #bc8f8f;">"/path/to/csv/"</span>
            :separator #\Tab
            :quote #\"
            :escape <span style="color: #bc8f8f;">"\"\""</span>
            :null-as <span style="color: #bc8f8f;">":null:"</span>)
                    table name       read   imported     errors       time
------------------------------  ---------  ---------  ---------  ---------
               aaaaaaaaaa_aaaa      24595      24595          0     0.995s
          bbbbbbbbbb_bbbbbbbbb        326        326          0     0.570s
       cccccccccc_cccccccccccc      25126      25126          0     1.461s
      dddddddddd_dddddddddd_dd          8          8          0     0.650s
eeeeeeeeee_eeeeeeeeee_eeeeeeee      36825      36825          0     1.664s
             ffffffffff_ffffff        624        624          0     0.707s
     gggggggggg_ggggg_gggggggg       5638       5638          0     0.655s
                   hhh_hhhhhhh     120159     120159          0     3.415s
             iii_iiiiiiiiiiiii        661        661          0     0.420s
                       jjjjjjj      30027      30027          0     2.743s
                 kkk_kkkkkkkkk         12         12          0     0.327s
                    lll_llllll          4          4          0     0.315s
                      mmmm_mmm      29669      29669          0     1.182s
                   nnnn_nnnnnn     100197     100197          0     2.206s
                    oooo_ooooo      93555      93555          0     9.683s
                  pppp_ppppppp      76457      76457          0     5.349s
             qqqq_qqqqqqqqqqqq     126159     126159          0     2.495s
------------------------------  ---------  ---------  ---------  ---------
             Total import time     670042     670042          0    34.836s
NIL
</pre>

<p>As you can see the control is still made for interactive developer usage,
which is fine for now but will have to change down the road, when the APIs
stabilize.</p>

<p>Now, let's compare to reading directly from <em>MySQL</em>:</p>

<pre class="src">
CL-USER&gt; (pgloader.mysql:stream-database <span style="color: #bc8f8f;">"dbname"</span>)
                    table name       read   imported     errors       time
------------------------------  ---------  ---------  ---------  ---------
               aaaaaaaaaa_aaaa      24595      24595          0     0.887s
          bbbbbbbbbb_bbbbbbbbb        326        326          0     0.617s
       cccccccccc_cccccccccccc      25126      25126          0     1.497s
      dddddddddd_dddddddddd_dd          8          8          0     0.582s
eeeeeeeeee_eeeeeeeeee_eeeeeeee      36825      36825          0     1.697s
             ffffffffff_ffffff        624        624          0     0.748s
     gggggggggg_ggggg_gggggggg       5638       5638          0     0.923s
                   hhh_hhhhhhh     120159     120159          0     3.525s
             iii_iiiiiiiiiiiii        661        661          0     0.449s
                       jjjjjjj      30027      30027          0     2.546s
                 kkk_kkkkkkkkk         12         12          0     0.330s
                    lll_llllll          4          4          0     0.323s
                      mmmm_mmm      29669      29669          0     1.227s
                   nnnn_nnnnnn     100197     100197          0     2.489s
                    oooo_ooooo      93555      93555          0     9.148s
                  pppp_ppppppp      76457      76457          0     6.713s
             qqqq_qqqqqqqqqqqq     126159     126159          0     4.571s
------------------------------  ---------  ---------  ---------  ---------
          Total streaming time     670042     670042          0    38.272s
NIL
</pre>

<p>The <em>streaming</em> here is a tad slower than the <em>importing</em> from files. Now if you
want to be fair when comparing those, you would have to take into account
the time it takes to <em>export</em> the data out from its source. When doing that
<em>export/import</em> dance, a quick test shows a timing of <code>1m4.745s</code>. Now, if we do
an <em>export only</em> test, it runs in <code>31.822s</code>. So yes streaming is a good thing to
have here.</p>


<h3>Conclusion</h3>

<p class="first">We just got twice as fast as the python version.</p>

<p>Some will say that I'm not comparing fairly to the <em>Python</em> version of
pgloader here, because I could have implemented the streaming facility in
<em>Python</em> too. Well actually I did, the option are called <a href="http://tapoueh.org/pgsql/pgloader.html#sec13">section_threads</a> and
<a href="http://tapoueh.org/pgsql/pgloader.html#sec15">split_file_reading</a>, that you can set so that a reader is pushing data into a
set of queues and several workers are feeding each from its own queue. It
didn't help with performances at all. Once again, read about the infamous
<a href="http://docs.python.org/3/c-api/init.html#threads">Global Interpreter Lock</a> to understand why not.</p>

<center>
<p><img src="../../../images/lisplogo_flag_128.png" alt=""></p>
</center>

<p>So actually it's a fair comparison here where the new code is twice as fast
as the previous one, with only some hours of hacking and before spending any
time on optimisation. Well, apart from using a <em>producer</em>, a <em>consumer</em> and a
<em>queue</em>, which I almost had to have for streaming in between two database
connections anyways.</p>
]]></description>
  <author>dim@tapoueh.org (Dimitri Fontaine)</author>
  <pubDate>Tue, 12 Feb 2013 11:17:00 +0100</pubDate>
  <guid isPermaLink="true">http://tapoueh.org/blog/2013/02/12-playing-with-pgloader.html</guid>
</item>
<item>
  <title>pgloader: what's next?</title>
  <link>http://tapoueh.org/blog/2013/01/28-pgloader-future.html</link>
  <description><![CDATA[<p><a href="../../../pgsql/pgloader.html">pgloader</a> is a tool to help loading data into <a href="http://www.postgresql.org/">PostgreSQL</a>, adding some error
management to the <a href="http://www.postgresql.org/docs/9.2/interactive/sql-copy.html">COPY</a> command. <code>COPY</code> is the fast way of loading data into
PostgreSQL and is transaction safe. That means that if a single error
appears within your bulk of data, you will have loaded none of it. <code>pgloader</code>
will submit the data again in smaller chunks until it's able to isolate the
bad from the good, and then the good is loaded in.</p>

<center>
<p><img src="../../../images/PDL_Adapter-250.png" alt=""></p>
</center>

<center>
<p><em>Not quite this kind of data loader</em></p>
</center>

<p>In a recent migration project where we freed data from MySQL into
PostgreSQL, we used <code>pgloader</code> again. But the loading time was not fast enough
for the service downtime window that we had here. Indeed <a href="http://www.python.org/">Python</a> is not known
for being the fastest solution around. It's easy to use and to ship to
production, but sometimes you not only want to be able to be efficient when
writing code, you also need the code to actually run fast too.</p>

<h3>Faster data loading</h3>

<p class="first">So I began writing a little dedicated tool for that migration in <a href="http://cliki.net/">Common Lisp</a>
which is growing on me as my personal answer to the burning question: <em>python
2 or python 3</em>? I find <em>Common Lisp</em> to offer an even more dynamic programming
environment, an easier language to use, and the result often has
performances characteristics way beyond what I can get with python. Between
<a href="http://tapoueh.org/blog/2012/07/10-solving-sudoku.html">5 times faster</a> and <a href="http://tapoueh.org/blog/2012/08/20-performance-the-easiest-way.html">121 times faster</a> in some quite stupid benchmark.</p>

<p>Here, with real data, my one shot attempt has been running more than <em>twice
as fast</em> as the python version, after about a day of programming.</p>

<center>
<p><img src="../../../images/lisp-python.png" alt=""></p>
</center>

<center>
<p><em>See what's happening now?</em></p>
</center>

<p>The other thing here is that I've tempted to get <code>pgloader</code> work in parallel,
but at the time I didn't know about the <a href="http://docs.python.org/3/c-api/init.html#threads">Global Interpreter Lock</a> that they
didn't find how to remove in Python 3 still, by the way. So my threading
attempts at making <code>pgloader</code> work in parallel are pretty useless.</p>

<p>Whereas in <em>Common Lisp</em> I can just use the <a href="http://lparallel.org/">lparallel</a> lib, which exposes
threading facilities and some <em>queueing</em> facilities as a mean to communicate
data in between workers, and have my code easily work in parallel for real.</p>


<h3>Compatibility</h3>

<p class="first">The only drawback that I can see here is that if you've been writing your
own <em>reformating modules</em> in python for <code>pgloader</code> (yes you can
<a href="http://tapoueh.org/pgsql/pgloader.html#sec21">implement your own reformating module for pgloader</a>), then you would have to
port it to <em>Common Lisp</em>. Shout me an email if that's your case.</p>


<h3>Next version</h3>

<p class="first">So, I think we're going to have a <em>pgloader 3</em> someday, that will be way
faster than the current one, and bundle some more features: real parallel
behavior, ability to fetch non local data (connecting to MySQL directly, or
HTTP, S3, etc); and I'm thinking about offering a <code>COPY</code> like syntax to drive
the loading too, while at it. Also, the ability to discover the set of data
to load all by itself when you want to load a whole database: think of it as
a special <em>Migration</em> mode of operations.</p>

<p>Some feature requests can't be solved easily when keeping the old <code>.INI</code>
syntax cruft, so it's high time to implement some kind of a real command
language. I have several ideas about those, in between the <code>COPY</code> syntax and
the <code>SQL*Loader</code> configuration format, which is both clunky and quite
powerful, too.</p>

<p>After a beginning in <code>TCL</code> and a complete rewrite in python in <code>2005</code>, it looks
like <code>2013</code> is going to be the year of <em>pgloader 3</em>, in <em>Common Lisp</em>!</p>
]]></description>
  <author>dim@tapoueh.org (Dimitri Fontaine)</author>
  <pubDate>Mon, 28 Jan 2013 10:48:00 +0100</pubDate>
  <guid isPermaLink="true">http://tapoueh.org/blog/2013/01/28-pgloader-future.html</guid>
</item>
<item>
  <title>Lost in scope</title>
  <link>http://tapoueh.org/blog/2013/01/09-Lost-in-scope.html</link>
  <description><![CDATA[<p>Thanks to <a href="https://twitter.com/mickael/status/288795520179240962">Mickael</a> on <em>twitter</em> I got to read an article about loosing scope
with some common programming languages. As the blog article <a href="https://my.smeuh.org/al/blog/lost-in-scope">Lost in scope</a>
references <em>functional programming languages</em> and plays with both <em>Javascript</em>
and <em>Erlang</em>, I though I had to try it out with <em>Common Lisp</em> too.</p>

<center>
<p><img src="../../../images/lambda.png" alt=""></p>
</center>

<center>
<p><em>Let's have fun with lambda!</em></p>
</center>

<p>So, here we go with a simple Common Lisp attempt. The <em>Lost in scope</em> article
begins with defining a very simple function returning a boolean value, only
true when it's not <code>monday</code>.</p>

<h3>Monday is special</h3>

<p class="first">Keep in mind that the following example has been choosen to be simple yet
offer a case of <em>lexical binding shadowing</em>. It looks convoluted. Focus on the
<code>day</code> binding.</p>

<pre class="src">
(<span style="color: #7f007f;">defparameter</span> <span style="color: #b8860b;">*days*</span>
  '(monday tuesday wednesday thursday friday saturday sunday)
  <span style="color: #bc8f8f;">"List of days in the week"</span>)

(<span style="color: #7f007f;">defun</span> <span style="color: #0000ff;">any-day-but-monday?</span> (day)
  <span style="color: #bc8f8f;">"Returns a generalized boolean, true unless DAY is 'monday"</span>
  (member day (remove-if (<span style="color: #7f007f;">lambda</span> (day) (eq day 'monday)) *days*)))
</pre>

<p>So as you can see, in <em>Common Lisp</em> we just get away with a list of symbols
rather than a string that we split to have a list of strings, or an array of
strings, as in the examples with <em>python</em> and <em>ruby</em>.</p>

<p>Now, the <em>generalized boolean</em> is either <code>nil</code> to mean false, or anything else
to mean <code>true</code>, and in that example the return value of <a href="http://www.lispworks.com/documentation/HyperSpec/Body/a_member.htm">member</a> is a sub-list
that begins where the <em>member</em> was found:</p>

<pre class="src">
CL-USER&gt; (any-day-but-monday? 'monday)
NIL

CL-USER&gt; (any-day-but-monday? 'tuesday)
(TUESDAY WEDNESDAY THURSDAY FRIDAY SATURDAY SUNDAY)
</pre>

<p>Oh, and as we work with <em>Common Lisp</em>, we're having a real <a href="http://www.gigamonkeys.com/book/lather-rinse-repeat-a-tour-of-the-repl.html">REPL</a> where to play
directly with our code, no need to add <em>interactive</em> stanzas in the main
program text file just to be able to play with it. In <a href="http://common-lisp.net/project/slime/">Emacs Slime</a> we just
use <code>C-M-x</code> on a <em>form</em> to have it available in the <em>REPL</em>, or <code>C-c C-l</code> to load the
whole file we're working on.</p>

<p>So, we see that <em>Common Lisp</em> scoping rules are silently doing the right thing
here. Within the <a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_rm_rm.htm">remove-if</a> call we define a <em>lambda</em> function taking a single
parameter called <em>day</em>. It so happens that this parameter is shadowing the
<em>any-day-but-monday?</em> function parameter, and that shadowing only happens in
the <em>lexical scope</em> of the <em>lambda</em> we are creating. For a detailed discussion
about that concept, I would refer you to the <a href="http://www.cs.cmu.edu/Groups/AI/html/cltl/clm/node43.html">Scope and Extent</a> chapter of
<em>Common Lisp the Language, 2nd Edition</em>.</p>

<p>In <em>Common Lisp</em> we have both <em>lexical scope</em> and <em>dynamic extents</em>, and a
variable defined with <em>defparameter</em> or <em>defvar</em> or that you otherwise <a href="http://www.lispworks.com/documentation/HyperSpec/Body/s_declar.htm">declare</a>
<em>special</em> will have a <em>dynamic extent</em>. Hence this section title.</p>


<h3>Closures</h3>

<p class="first">Now, the <a href="https://my.smeuh.org/al/blog/lost-in-scope">lost in scope</a> article tries some more at finding a solution around
the scoping rules of the <em>python</em> and <em>ruby</em> languages, where the developer can
not easily instruct the language about the scoping rules he wants to be
using in a case by case way, as far as I can see.</p>

<p>First, let's reproduce the problem by using a single variable that we bind
in all the closures. Those are called <em>callbacks</em> in the original article, so
I've kept using that name here.</p>

<center>
<p><img src="../../../images/callback.jpg" alt=""></p>
</center>

<pre class="src">
(<span style="color: #7f007f;">defparameter</span> <span style="color: #b8860b;">*callbacks-all-sunday*</span>
    (<span style="color: #7f007f;">loop</span>
       for day in *days*
       collect (<span style="color: #7f007f;">lambda</span> () day))
  <span style="color: #bc8f8f;">"loop binds DAY only once"</span>)
</pre>

<p>In that example, there's only a single variable day that we reuse throughout
the <em>loop</em> construct, so that when the loop ends, we have a list of closures
all refering to the same variable, and this variable, by the end of the
loop, has <code>sunday</code> as its value.</p>

<pre class="src">
CL-USER&gt; (mapcar #'funcall *callbacks-all-sunday*)
(SUNDAY SUNDAY SUNDAY SUNDAY SUNDAY SUNDAY SUNDAY)
</pre>


<h3>Closures, take 2</h3>

<p class="first">Now, the way to have what we want here, that is a list of closures each
having its own variable.</p>

<pre class="src">

(<span style="color: #7f007f;">defparameter</span> <span style="color: #b8860b;">*callbacks*</span>
  (mapcar (<span style="color: #7f007f;">lambda</span> (day)
            <span style="color: #b22222;">;; </span><span style="color: #b22222;">for each day, produce a separate closure
</span>            <span style="color: #b22222;">;; </span><span style="color: #b22222;">around its own lexical variable day
</span>            (<span style="color: #7f007f;">lambda</span> () day))
          *days*)
  <span style="color: #bc8f8f;">"A list of callbacks to return the current day..."</span>)
</pre>

<p>And there we go:</p>

<pre class="src">
CL-USER&gt; (mapcar #'funcall *callbacks*)
(MONDAY TUESDAY WEDNESDAY THURSDAY FRIDAY SATURDAY SUNDAY)
</pre>


<h3>Conclusion</h3>

<p class="first">Scoping rules are very important in any programming language, functional or
not, and must be well understood by programmers. I find that once again,
that topic has received a very deep thinking in <em>Common Lisp</em>, and the
language is giving all the options to its developers.</p>

<center>
<p><img src="../../../images/scope.png" alt=""></p>
</center>

<center>
<p><em>What are your language of choice scoping rules?</em></p>
</center>

<p>I want to stress that in <em>Common Lisp</em> the scope rules are very clearly
defined in the standard documentation of the language. For instance, <em>defun</em>
and <em>let</em> both introduce a lexical binding, <em>defvar</em> and <em>defparameter</em> introduce
a <em>dynamic variable</em>.</p>

<p>Also, as a user of the language you have the ability to <em>declare</em> any variable
as being <em>special</em> in order to introduce yourself a <em>dynamic variable</em>. In <code>C</code> you
can declare some variables as being <em>static</em>, which is something else and
frown with a very different set of problems.</p>
]]></description>
  <author>dim@tapoueh.org (Dimitri Fontaine)</author>
  <pubDate>Wed, 09 Jan 2013 11:07:00 +0100</pubDate>
  <guid isPermaLink="true">http://tapoueh.org/blog/2013/01/09-Lost-in-scope.html</guid>
</item>
<item>
  <title>CL Happy Numbers</title>
  <link>http://tapoueh.org/blog/2012/11/20-CL-Happy-Numbers.html</link>
  <description><![CDATA[<p>A while ago I stumbled upon <a href="http://tapoueh.org/blog/2010/08/30-happy-numbers.html">Happy Numbers</a> as explained in
<a href="http://programmingpraxis.com/2010/07/23/happy-numbers/">programming praxis</a>, and offered an implementation of them in <code>SQL</code> and in
<code>Emacs Lisp</code>. Yeah, I know. Why not, though?</p>

<center>
<p><img src="../../../images/happy-numbers.png" alt=""></p>
</center>

<p>Today I'm back on that topic and as I'm toying with <em>Common Lisp</em> I though it
would be a good excuse to learn me some new tricks. As you can see from the
earlier blog entry, last time I did attack the <em>digits</em> problem quite lightly.
Let's try a better approach now.</p>

<pre class="src">
(<span style="color: #7f007f;">defun</span> <span style="color: #0000ff;">digits</span> (n)
  <span style="color: #bc8f8f;">"return the list of the digits of N"</span>
  (nreverse
   (<span style="color: #7f007f;">loop</span> for x = n then r
      for (r d) = (multiple-value-list (truncate x 10))
      collect d
      until (zerop r))))
</pre>

<p>As you can see I wanted to use that facility I like very much, the <code>for
x = n then r</code> way to handle first loop iteration differently from the
next ones. But I've been hinted on <code>#lisp</code> that there's a much better way to
write same code:</p>

<pre class="src">
(<span style="color: #7f007f;">defun</span> <span style="color: #0000ff;">integer-digits</span> (integer)
  <span style="color: #bc8f8f;">"stassats version"</span>
  (nreverse
   (<span style="color: #7f007f;">loop</span> with remainder
      do (setf (values integer remainder) (truncate integer 10))
      collect remainder
      until (zerop integer))))
</pre>

<p>That code runs about twice as fast as the previous one and is easier to
reason about. It's using <code>setf</code> and the form <a href="http://www.lispworks.com/documentation/lw51/CLHS/Body/f_values.htm">setf values</a>, something nice to
discover as it seems to be quite powerful. Let's see how to use it, even if
it's really simple:</p>

<pre class="src">
CL-USER&gt; (integer-digits 12304501)
(1 2 3 0 4 5 0 1)
</pre>

<p>Let's move on to solving the <em>Happy Numbers</em> problem though:</p>

<pre class="src">
(<span style="color: #7f007f;">defun</span> <span style="color: #0000ff;">sum-of-squares-of-digits</span> (integer)
  (<span style="color: #7f007f;">loop</span> with remainder
     do (setf (values integer remainder) (truncate integer 10))
     sum (* remainder remainder)
     until (zerop integer)))

(<span style="color: #7f007f;">defun</span> <span style="color: #0000ff;">happy?</span> (n <span style="color: #228b22;">&amp;optional</span> seen)
  <span style="color: #bc8f8f;">"return true when n is a happy number"</span>
  (<span style="color: #7f007f;">let*</span> ((happiness (sum-of-squares-of-digits n)))
    (<span style="color: #7f007f;">cond</span> ((eq 1 happiness)      t)
          ((memq happiness seen) nil)
          (t
           (happy? happiness (push happiness seen))))))

(<span style="color: #7f007f;">defun</span> <span style="color: #0000ff;">find-happy-numbers</span> (limit)
  <span style="color: #bc8f8f;">"find all happy numbers from 1 to limit"</span>
  (<span style="color: #7f007f;">loop</span> for n from 1 to limit when (happy? n) collect n))
</pre>

<p>And here's how it goes:</p>

<pre class="src">
CL-USER&gt; (find-happy-numbers 100)
(1 7 10 13 19 23 28 31 32 44 49 68 70 79 82 86 91 94 97 100)

CL-USER&gt; (time (length (find-happy-numbers 1000000)))
(LENGTH (FIND-HAPPY-NUMBERS 1000000))
took 1,621,413 microseconds (1.621413 seconds) to run.
       116,474 microseconds (0.116474 seconds, 7.18%) of which was spent in GC.
During that period, and with 4 available CPU cores,
     1,431,332 microseconds (1.431332 seconds) were spent in user mode
       145,941 microseconds (0.145941 seconds) were spent in system mode
 185,438,208 bytes of memory allocated.
 1 minor page faults, 0 major page faults, 0 swaps.
143071
</pre>

<p>Of course that code is much faster than the one I wrote before both in <code>SQL</code>
and <em>Emacs Lisp</em>, the reason being that instead of writing the number into a
<em>string</em> with <code>(format t &quot;~d&quot; number)</code> then <a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_subseq.htm">subseq</a> to get them one after the
other, we're now using <a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_floorc.htm">truncate</a>.</p>

<p>Happy hacking!</p>

<h3>Update</h3>

<p class="first">It turns out that to solve math related problem, some maths hindsight is
helping. Who would have believed that? So if you want to easily get some
more performances out of the previous code, just try that solution:</p>

<pre class="src">
(<span style="color: #7f007f;">defvar</span> <span style="color: #b8860b;">*depressed-squares*</span> '(0 4 16 20 37 42 58 89 145)
  <span style="color: #bc8f8f;">"see http://oeis.org/A039943"</span>)

(<span style="color: #7f007f;">defun</span> <span style="color: #0000ff;">undepressed?</span> (n)
  <span style="color: #bc8f8f;">"same as happy?, using a static list of unhappy sums"</span>
  (<span style="color: #7f007f;">cond</span> ((eq 1 n) t)
        ((member n *depressed-squares*) nil)
        (t
         (<span style="color: #7f007f;">let</span> ((h (sum-of-squares-of-digits n)))
           (undepressed? h)))))

(<span style="color: #7f007f;">defun</span> <span style="color: #0000ff;">find-undepressed-numbers</span> (limit)
  <span style="color: #bc8f8f;">"find all happy numbers from 1 to limit"</span>
  (<span style="color: #7f007f;">loop</span> for n from 1 to limit when (undepressed? n) collect n))
</pre>

<p>Time to compare:</p>

<pre class="src">
CL-USER&gt; (time (length (find-happy-numbers 1000000)))
(LENGTH (FIND-HAPPY-NUMBERS 1000000))
took 1,938,048 microseconds (1.938048 seconds) to run.
       290,902 microseconds (0.290902 seconds, 15.01%) of which was spent in GC.
During that period, and with 4 available CPU cores,
     1,778,021 microseconds (1.778021 seconds) were spent in user mode
       140,862 microseconds (0.140862 seconds) were spent in system mode
 185,438,208 bytes of memory allocated.
 3,320 minor page faults, 0 major page faults, 0 swaps.
143071

CL-USER&gt; (time (length (find-undepressed-numbers 1000000)))
(LENGTH (FIND-UNDEPRESSED-NUMBERS 1000000))
took 1,036,847 microseconds (1.036847 seconds) to run.
         5,372 microseconds (0.005372 seconds, 0.52%) of which was spent in GC.
During that period, and with 4 available CPU cores,
     1,018,708 microseconds (1.018708 seconds) were spent in user mode
        16,982 microseconds (0.016982 seconds) were spent in system mode
 2,289,152 bytes of memory allocated.
143071
CL-USER&gt;
</pre>
]]></description>
  <author>dim@tapoueh.org (Dimitri Fontaine)</author>
  <pubDate>Tue, 20 Nov 2012 18:20:00 +0100</pubDate>
  <guid isPermaLink="true">http://tapoueh.org/blog/2012/11/20-CL-Happy-Numbers.html</guid>
</item>
<item>
  <title>Concurrent Hello</title>
  <link>http://tapoueh.org/blog/2012/11/04-Concurrent-Hello.html</link>
  <description><![CDATA[<p>Thanks to <a href="https://twitter.com/mickael/status/265191809100181504">Mickael</a> on <em>twitter</em> I ran into that article about implementing a
very basic <em>Hello World!</em> program as a way to get into a new concurrent
language or facility. The original article, titled
<a href="http://himmele.blogspot.de/2012/11/concurrent-hello-world-in-go-erlang.html">Concurrent Hello World in Go, Erlang and C++</a> is all about getting to know
<a href="http://golang.org/">The Go Programming Language</a> better.</p>

<p>To quote the article:</p>

<blockquote>
<p class="quoted">
The first thing I always do when playing around with a new
software platform is to write a concurrent &quot;Hello World&quot; program. The
program works as follows: One active entity (e.g. thread, Erlang process,
Goroutine) has to print &quot;Hello &quot; and another one &quot;World!\n&quot; with the two
active entities synchronizing with each other so that the output always is
&quot;Hello World!\n&quot;.</p>

</blockquote>

<p>Here's my try in <a href="http://cliki.net/">Common Lisp</a> using <a href="http://lparallel.org/">lparallel</a> and some <em>local nicknames</em>, the
whole <code>23</code> lines of it:</p>

<pre class="src">
(<span style="color: #7f007f;">defun</span> <span style="color: #0000ff;">say-hello</span> (helloq worldq n)
  (<span style="color: #7f007f;">dotimes</span> (i n)
    (format t <span style="color: #bc8f8f;">"Hello "</span>)
    (lq:push-queue <span style="color: #da70d6;">:say-world</span> worldq)
    (lq:pop-queue helloq))
  (lq:push-queue <span style="color: #da70d6;">:quit</span> worldq))

(<span style="color: #7f007f;">defun</span> <span style="color: #0000ff;">say-world</span> (helloq worldq)
  (<span style="color: #7f007f;">when</span> (eq (lq:pop-queue worldq) <span style="color: #da70d6;">:say-world</span>)
    (format t <span style="color: #bc8f8f;">"World!~%"</span>)
    (lq:push-queue <span style="color: #da70d6;">:say-hello</span> helloq)
    (say-world helloq worldq)))

(<span style="color: #7f007f;">defun</span> <span style="color: #0000ff;">hello-world</span> (n)
  (<span style="color: #7f007f;">let*</span> ((lp:*kernel*  (lp:make-kernel 2)) <span style="color: #b22222;">; </span><span style="color: #b22222;">a new one each time, as we end it
</span>         (channel      (lp:make-channel))
         (helloq       (lq:make-queue))
         (worldq       (lq:make-queue)))
    (lp:submit-task channel #'say-world helloq worldq)
    (lp:submit-task channel #'say-hello helloq worldq n)
    (lp:receive-result channel)
    (lp:receive-result channel)
    (lp:end-kernel)))
</pre>

<p>If you want to play locally with that code, I've been updating it to a
<em>github</em> project named <a href="https://github.com/dimitri/go-hello-world">go-hello-world</a>, even if it's coded in <em>CL</em>. See the
<code>package.lisp</code> in there for how I did enable the <em>local nicknames</em> <code>lp</code> and <code>lq</code> for
the <em>lparallel</em> packages.</p>

<h3>Beware of the REPL</h3>

<p class="first">In a previous version of this very article, I said that sometimes I get an
extra line feed in the output and I didn't understand why. Some great Common
Lisp folks did hint me about that: it's the <em>REPL</em> output that get
intermingled with the program output, and that's because the <code>hello-world</code>
main function was returning before the thing is over.</p>

<p>I've added a <code>receive-result</code> call in it per worker so that it waits until the
end of the program before returning to the <em>REPL</em>, and that indeed fixes it. A
way to assert that is using the <code>time</code> macro, which was always intermingled
with the output before. It's fixed now:</p>

<pre class="src">
CL-USER&gt; (time (go-hello-world:hello-world 1000))
Hello World!
...
Hello World!
(GO-HELLO-WORLD:HELLO-WORLD 1000)
took 27,886 microseconds (0.027886 seconds) to run.
      1,593 microseconds (0.001593 seconds, 5.71%) of which was spent in GC.
During that period, and with 4 available CPU cores,
     23,246 microseconds (0.023246 seconds) were spent in user mode
     14,427 microseconds (0.014427 seconds) were spent in system mode
 4,272 bytes of memory allocated.
 10 minor page faults, 0 major page faults, 0 swaps.
(#&lt;PROCESS lparallel kernel shutdown manager(62) [Reset] #x30200109F65D&gt; ...)
CL-USER&gt;
</pre>


<h3>Conclusion</h3>

<p class="first">While <em>Go</em> language seems to bring very interesting things on the table, such
as better compilation units and tools, I still think that the concurrency
primitives at the core of it are easy to find in other places. Which is a
good thing, as it means we know they work.</p>

<p>That also means that we don't need to accept <em>Go</em> syntax as the only way to
properly solve that <em>concurrency</em> problem, I much prefer doing so with <em>Common
Lisp</em> (lack of?) syntax myself.</p>


<h3>Update</h3>

<p class="first">A previous version of this article was finished and published too quickly,
and the conclusion was made from a buggy version of the program. It's all
fixed now. Thanks a lot to people who contributed comments so that I could
fix it, and thanks again to <em>James M. Lawrence</em> for <a href="http://lparallel.org/">lparallel</a>!</p>
]]></description>
  <author>dim@tapoueh.org (Dimitri Fontaine)</author>
  <pubDate>Sun, 04 Nov 2012 23:04:00 +0100</pubDate>
  <guid isPermaLink="true">http://tapoueh.org/blog/2012/11/04-Concurrent-Hello.html</guid>
</item>
<item>
  <title>Fast and stupid?</title>
  <link>http://tapoueh.org/blog/2012/08/20-performance-the-easiest-way.html</link>
  <description><![CDATA[<p>I stumbled onto an interesting article about performance when using python,
called <a href="http://jiaaro.com/python-performance-the-easyish-way">Python performance the easy(ish) way</a>, where the author tries to get
the bet available performances out of the dumbiest possible python code,
trying to solve a very simple and stupid problem.</p>

<p>With so many <em>smart</em> qualifiers you can only guess that I did love the
challenge. The idea is to write the simplest code possible and see how
smarter you need to be when you need perfs. Let's have a try!</p>

<h3>local python results</h3>

<p class="first">Here's the code I did use to benchmark the python solution:</p>

<pre class="src">
<span style="color: #7f007f;">def</span> <span style="color: #0000ff;">sumrange</span>(arg):
    <span style="color: #7f007f;">return</span> <span style="color: #da70d6;">sum</span>(<span style="color: #da70d6;">xrange</span>(arg))

<span style="color: #7f007f;">def</span> <span style="color: #0000ff;">sumrange2</span>(arg):
    <span style="color: #b8860b;">x</span> = <span style="color: #b8860b;">i</span> = 0
    <span style="color: #7f007f;">while</span> i &lt; arg:
        <span style="color: #b8860b;">x</span> += i
        <span style="color: #b8860b;">i</span> += 1
    <span style="color: #7f007f;">return</span> x


<span style="color: #7f007f;">import</span> ctypes
<span style="color: #b8860b;">ct_sumrange</span> = ctypes.CDLL(<span style="color: #bc8f8f;">'/Users/dim/dev/CL/jiaroo/sumrange.so'</span>)

<span style="color: #7f007f;">def</span> <span style="color: #0000ff;">sumrange_ctypes</span>(arg):
    <span style="color: #7f007f;">return</span> ct_sumrange.sumrange(arg)

<span style="color: #7f007f;">if</span> <span style="color: #da70d6;">__name__</span> == <span style="color: #bc8f8f;">"__main__"</span>:
    <span style="color: #7f007f;">import</span> timeit
    t1 = timeit.Timer(<span style="color: #bc8f8f;">'import jiaroo; jiaroo.sumrange(10**10)'</span>)
    t2 = timeit.Timer(<span style="color: #bc8f8f;">'import jiaroo; jiaroo.sumrange2(10**10)'</span>)
    ct = timeit.Timer(<span style="color: #bc8f8f;">'import jiaroo; jiaroo.sumrange_ctypes(10**10)'</span>)

    <span style="color: #7f007f;">print</span> <span style="color: #bc8f8f;">'timing python sumrange(10**10)'</span>
    <span style="color: #7f007f;">print</span> <span style="color: #bc8f8f;">'xrange: %5fs'</span> % t1.timeit(1)
    <span style="color: #7f007f;">print</span> <span style="color: #bc8f8f;">'while:  %5fs'</span> % t2.timeit(1)
    <span style="color: #7f007f;">print</span> <span style="color: #bc8f8f;">'ctypes: %5fs'</span> % ct.timeit(1)
</pre>

<p>Oh. And the C code too, sorry about that.</p>

<pre class="src">
<span style="color: #da70d6;">#include</span> <span style="color: #bc8f8f;">&lt;stdio.h&gt;</span>

<span style="color: #228b22;">int</span> <span style="color: #0000ff;">sumrange</span>(<span style="color: #228b22;">int</span> <span style="color: #b8860b;">arg</span>)
{
    <span style="color: #228b22;">int</span> <span style="color: #b8860b;">i</span>, <span style="color: #b8860b;">x</span>;
    x = 0;

    <span style="color: #7f007f;">for</span> (i = 0; i &lt; arg; i++) {
        x = x + i;
    }
    <span style="color: #7f007f;">return</span> x;
}
</pre>

<p>And here's how I did compile it. The author of the inspiring article
insisted on stupid optimisation targets, I did follow him:</p>

<pre class="src">
gcc -shared -Wl,-install_name,sumrange.so -o sumrange.so -fPIC sumrange.c -O0
</pre>

<p>And here's the result I did get out of it:</p>

<pre class="src">
python jiaroo.py
timing python sumrange(10**10)
<span style="color: #da70d6;">xrange</span>: 927.039917s
<span style="color: #7f007f;">while</span>:  2377.291237s
ctypes: 5.297124s
</pre>

<p>Let's be fair, with <code>-O2</code> we get much better results:</p>

<pre class="src">
timing python sumrange(10**10)
ctypes: 1.065684s
</pre>


<h3>Common Lisp to the rescue</h3>

<p class="first">So let's have a try in Common Lisp, will you ask me, right?</p>

<p>Here's the code I did use, you can see three different tries:</p>

<pre class="src">
<span style="color: #b22222;">;;;; </span><span style="color: #b22222;">jiaroo.lisp
</span><span style="color: #b22222;">;;;</span><span style="color: #b22222;">
</span><span style="color: #b22222;">;;; </span><span style="color: #b22222;">See http://jiaaro.com/python-performance-the-easyish-way
</span><span style="color: #b22222;">;;;</span><span style="color: #b22222;">
</span><span style="color: #b22222;">;;; </span><span style="color: #b22222;">The goal here is to find out if CL needs to resort to C for very simple
</span><span style="color: #b22222;">;;; </span><span style="color: #b22222;">optimisation tricks like python apparently needs too, unless using pypy
</span><span style="color: #b22222;">;;; </span><span style="color: #b22222;">(to some extend).
</span>
(<span style="color: #7f007f;">in-package</span> #<span style="color: #da70d6;">:jiaroo</span>)

<span style="color: #b22222;">;;; </span><span style="color: #b22222;">"jiaroo" goes here. Hacks and glory await!
</span>
(<span style="color: #7f007f;">defun</span> <span style="color: #0000ff;">sumrange-loop</span> (max)
  <span style="color: #bc8f8f;">"return the sum of numbers from 1 to MAX"</span>
  (<span style="color: #7f007f;">let</span> ((sum 0))
    (<span style="color: #7f007f;">declare</span> (type (and unsigned-byte fixnum) max sum)
             (optimize speed))
    (<span style="color: #7f007f;">loop</span> for i fixnum from 1 to max do (incf sum i))))

(<span style="color: #7f007f;">defun</span> <span style="color: #0000ff;">sumrange-dotimes</span> (max)
  <span style="color: #bc8f8f;">"return the sum of numbers from 1 to MAX"</span>
  (<span style="color: #7f007f;">let</span> ((sum 0))
    (<span style="color: #7f007f;">declare</span> (type (and unsigned-byte fixnum) max sum)
             (optimize speed))
    (<span style="color: #7f007f;">dotimes</span> (i max sum)
      (incf sum i))))

(<span style="color: #7f007f;">defun</span> <span style="color: #0000ff;">pk-sumrange</span> (max)
  (<span style="color: #7f007f;">declare</span> (type (and unsigned-byte fixnum) max)
           (optimize speed))
  (<span style="color: #7f007f;">let</span> ((sum 0))
    (<span style="color: #7f007f;">declare</span> (type (and fixnum unsigned-byte) sum))
    (<span style="color: #7f007f;">dotimes</span> (i max sum)
      (setf sum (logand (+ sum i) most-positive-fixnum)))))

(<span style="color: #7f007f;">defmacro</span> <span style="color: #0000ff;">timing</span> (<span style="color: #228b22;">&amp;body</span> forms)
  <span style="color: #bc8f8f;">"return both how much real time was spend in body and its result"</span>
  (<span style="color: #7f007f;">let</span> ((start (gensym))
        (end (gensym))
        (result (gensym)))
    `(<span style="color: #7f007f;">let*</span> ((,start (get-internal-real-time))
            (,result (<span style="color: #7f007f;">progn</span> ,@forms))
            (,end (get-internal-real-time)))
       (values ,result (/ (- ,end ,start) internal-time-units-per-second)))))

(<span style="color: #7f007f;">defun</span> <span style="color: #0000ff;">bench-sumrange</span> (power)
  <span style="color: #bc8f8f;">"print execution time of both the previous functions"</span>
  (<span style="color: #7f007f;">let*</span> ((max (expt 10 power))
         (lp-time (<span style="color: #7f007f;">multiple-value-bind</span> (r s) (timing (sumrange-loop max)) s))
         (dt-time (<span style="color: #7f007f;">multiple-value-bind</span> (r s) (timing (sumrange-dotimes max)) s))
         (pk-time (<span style="color: #7f007f;">multiple-value-bind</span> (r s) (timing (pk-sumrange max)) s)))
    (format t <span style="color: #bc8f8f;">"timing common lisp sumrange 10**~d~%"</span> power)
    (format t <span style="color: #bc8f8f;">"loop:       ~2,3fs ~%"</span> lp-time)
    (format t <span style="color: #bc8f8f;">"dotimes:    ~2,3fs ~%"</span> dt-time)
    (format t <span style="color: #bc8f8f;">"pk dotimes: ~2,3fs ~%"</span> pk-time)))
</pre>

<p>And here's the results:</p>

<pre class="src">
CL-USER&gt; (bench-sumrange 10)
timing common lisp sumrange 10**10
loop:       11.213s
dotimes:    7.642s
pk dotimes: 22.185s
NIL
</pre>


<h3>Discussion</h3>

<p class="first">So python is very slow. C is pretty fast. And Common Lisp just in the
middle. Honnestly I expected better performances from my beloved Common Lisp
here, but I didn't try very hard, by using <a href="http://ccl.clozure.com/">Clozure Common Lisp</a> which is not
the quicker Common Lisp implementation around. For this very benchmark, if
you're seeking speed use either <a href="http://sbcl.org/">Steel Bank Common Lisp</a> or <a href="http://www.clisp.org/">CLISP</a> which is
known to have a pretty fast bignums implementation (which you don't need in
64 bits in that game).</p>

<p>On the other hand, I think that having to go write a C plugin and deal with
how to compile and deploy it in the middle of a python script is something
to avoid. When using Common Lisp you don't need to resort to that for the
<em>runtime</em> to get down from python <em>xrange</em> implementation at <code>927.039917s</code> down to
the <em>dotimes</em> implementation taking <code>7.642s</code>. That's about <code>121</code> times faster.</p>

<p>So while <code>C</code> is even better, and while I would like a Common Lisp guru to show
me how to get a better speed here, I still very much appreciate the solution
here.</p>

<p>Let's see the winning source code in <em>python</em> and <em>common lisp</em> to compare the
programmer side of things: how hard was it really to get <code>121</code> times faster?</p>

<pre class="src">
<span style="color: #7f007f;">def</span> <span style="color: #0000ff;">sumrange</span>(arg):
    <span style="color: #7f007f;">return</span> <span style="color: #da70d6;">sum</span>(<span style="color: #da70d6;">xrange</span>(arg))
</pre>

<pre class="src">
(<span style="color: #7f007f;">defun</span> <span style="color: #0000ff;">sumrange-dotimes</span> (max)
  <span style="color: #bc8f8f;">"return the sum of numbers from 1 to MAX"</span>
  (<span style="color: #7f007f;">let</span> ((sum 0))
    (<span style="color: #7f007f;">declare</span> (type (and unsigned-byte fixnum) max sum)
             (optimize speed))
    (<span style="color: #7f007f;">dotimes</span> (i max sum)
      (incf sum i))))
</pre>

<p>That's about it. Yes we can see some <em>manual</em> optimisation directives here,
which are optimisation <em>extra complexity</em>. Not to the same level as bringing a
compiled artifact that you need to build and deploy, though. Remember that
you will need to know the full path where to find the <code>sumrange.so</code> file on
the production system, in the optimised <em>python</em> case, so that's what we are
comparing against.</p>

<p>Here's what happens without the optimisation, and with a smaller target:</p>

<pre class="src">
CL-USER&gt; (time (jiaroo:sumrange-dotimes (expt 10 9)))
(JIAROO:SUMRANGE-DOTIMES (EXPT 10 9))
took 722,592 microseconds (0.722592 seconds) to run.
During that period, and with 2 available CPU cores,
     714,709 microseconds (0.714709 seconds) were spent in user mode
       1,183 microseconds (0.001183 seconds) were spent in system mode
499999999500000000

CL-USER&gt; (time (<span style="color: #7f007f;">let</span> ((sum 0)) (<span style="color: #7f007f;">dotimes</span> (i (expt 10 9) sum) (incf sum i))))
(<span style="color: #7f007f;">LET</span> ((SUM 0)) (<span style="color: #7f007f;">DOTIMES</span> (I (EXPT 10 9) SUM) (INCF SUM I)))
took 2,174,767 microseconds (2.174767 seconds) to run.
During that period, and with 2 available CPU cores,
     2,156,549 microseconds (2.156549 seconds) were spent in user mode
        10,225 microseconds (0.010225 seconds) were spent in system mode
499999999500000000
</pre>

<p>We get a <code>3</code> times speed-up from those 2 lines of lisp optimisation
directives, which is pretty good. And it's exponential as I didn't have the
patience to actually wait until the non optimised <code>10^10</code> run finished, I
killed it.</p>


<h3>Conclusion</h3>

<p class="first">That's a case here where I don't know how to reach <code>C</code> level of performances
with Common Lisp, which could just be because I don't know yet how to do.</p>

<p>Still, getting a <code>121</code> times speedup when compared to the pure <em>python</em> version
of the code is pretty good and encourages me to continue diving into Common
Lisp.</p>
]]></description>
  <author>dim@tapoueh.org (Dimitri Fontaine)</author>
  <pubDate>Wed, 22 Aug 2012 16:05:00 +0200</pubDate>
  <guid isPermaLink="true">http://tapoueh.org/blog/2012/08/20-performance-the-easiest-way.html</guid>
</item>
<item>
  <title>Solving Every Sudoku Puzzle</title>
  <link>http://tapoueh.org/blog/2012/07/10-solving-sudoku.html</link>
  <description><![CDATA[<p><a href="http://norvig.com/">Peter Norvig</a> published a while ago a very nice article titled
<a href="http://norvig.com/sudoku.html">Solving Every Sudoku Puzzle</a> wherein he presents a programmatic approach to
solving that puzzle game.</p>

<center>
<p><a class="image-link" href="http://en.wikipedia.org/wiki/Sudoku">
<img src="../../../images/sudoku.png"></a></p>
</center>

<p>The article is very well written and makes it easy to think that coming up
with the code for such a solver is a very easy task, you apply some basic
problem search principles and there you are. Which is partly true, in fact.
Also, he uses <code>python</code>, and that means that a lot of trivial programming
activities are not a concern anymore, such as memory management.</p>

<p>As I've been teaching myself <a href="http://www.cliki.net/Common%20Lisp">Common Lisp</a> for some weeks now I though I would
like to read a lisp version of his code, and the article even has a section
titled <em>Translations</em>. Unfortunately, no lisp version is available there. One
might argue that <a href="http://clojure.org/">Clojure</a> is a decent enough lisp, but my current quest is
all about <em>Common Lisp</em> really. So I had to write one myself.</p>

<pre class="src">
CL-USER&gt; (sudoku:print-puzzle
          (sudoku:solve-grid
<span style="color: #bc8f8f;">"5300700006001950000980000608000600034008030017000200060600002800004190050000800</span><span style="color: #ffff00; background-color: #ff0000; font-weight: bold;">79"))</span>
5 3 4 | 6 7 8 | 9 1 2
6 7 2 | 1 9 5 | 3 4 8
1 9 8 | 3 4 2 | 5 6 7
------+-------+------
8 5 9 | 7 6 1 | 4 2 3
4 2 6 | 8 5 3 | 7 9 1
7 1 3 | 9 2 4 | 8 5 6
------+-------+------
9 6 1 | 5 3 7 | 2 8 4
2 8 7 | 4 1 9 | 6 3 5
3 4 5 | 2 8 6 | 1 7 9
took 1,974 microseconds (0.001974 seconds) to run.
During that period, and with 2 available CPU cores,
     1,894 microseconds (0.001894 seconds) were spent in user mode
        88 microseconds (0.000088 seconds) were spent in system mode
 174,320 bytes of memory allocated.
#&lt;SUDOKU::PUZZLE #x3020023BB9FD&gt;
</pre>

<h3>Comments on the python version</h3>

<p class="first">Norvig's article is very well written, I think. By that I mean that by
reading it you're confident that you've understood the problem and how the
solution is articulated, so you almost think you don't need to really try to
understand the code, it's just an illustration of the text.</p>

<p>Well, not so much. When you want to port the exact same algorithm you have
to understand exactly what the code is doing so that you're not implementing
something else. All the more when, as I did, you want to use some other data
structure.</p>

<p>My goal was not to rewrite the code as-is, but to try and come up with
<em>idiomatic</em> lisp code implementing Norvig's solution. So rather than using
<em>strings</em> and <em>dictionaries</em> (in lisp, they still call them a <a href="http://www.lispworks.com/documentation/lw50/CLHS/Body/f_mk_has.htm">hash table</a>) I've
been using more natural data structures.</p>

<p>The <em>python</em> code is really uneasy to follow, full of functional programming
veteran tricks. I mean avoiding <em>exceptions</em> and simply returning <code>False</code>
whenever there's a problem, and using functions such as <code>all</code> and <code>some</code> to
manage that. It's certainly working, it's not making the code any easier to
read.</p>

<p>To summarize, that code looks like it's been written by someone smart who
didn't want to spend more than a couple of hours on it, and did take all
known trustworthy shortcuts he could to achieve that goal. Quality and
readability certainly weren't the key motive. I've been quite deceived after
reading a very good article.</p>


<h3>Comments on the common lisp version</h3>

<p class="first">Keep in mind that I'm just a <em>Common Lisp</em> newbie. I've been told some good
pieces of advice by knowledgeable people though, so with some luck my
implementation is somewhat <em>lispy</em> enough.</p>

<p>So we start by defining some data structures and low-level functions to
build up the more complex one, so that it's easier to read and debug. The
<em>sudoku</em> puzzle is then a grid of digits and a grid of possible values in
places where the digits are yet unknown.</p>

<p>The way to represent that 9x9 grid is with using <a href="http://www.lispworks.com/documentation/lw51/CLHS/Body/f_mk_ar.htm">make-array</a>:</p>

<pre class="src">
(make-array '(9 9)
            <span style="color: #da70d6;">:element-type</span> '(integer 0 9)
            <span style="color: #da70d6;">:initial-element</span> 0)
</pre>

<p>Then the possible values. I though about using a <code>bit-vector</code> (and actually I
did implement it that way), then I've been told that the <em>Common Lisp</em> way to
approach that is using <a href="http://psg.com/~dlamkins/sl/chapter18.html">2-complement integer representation</a>, as we have
plenty of functions to operate numbers that way. I wouldn't believe that
would make the code simpler, but in fact it really did, see:</p>

<pre class="src">
CL-USER&gt; #b111111111
511
CL-USER&gt; (logcount #b111111111)
9
CL-USER&gt; (logcount 511)
9
CL-USER&gt; (logbitp 3 #b100100100)
NIL
CL-USER&gt; (logbitp 2 #b100100100)
T
CL-USER&gt; (format nil <span style="color: #bc8f8f;">"~2r"</span> (logxor #b111111111 (ash 1 4)))
<span style="color: #bc8f8f;">"111101111"</span>
CL-USER&gt; (logbitp 4 (logxor #b111111111 (ash 1 4)))
NIL
</pre>

<p>With that in mind, we can write the following code:</p>

<pre class="src">
(<span style="color: #7f007f;">defun</span> <span style="color: #0000ff;">count-remaining-possible-values</span> (possible-values)
  <span style="color: #bc8f8f;">"How many possible values are left in there?"</span>
  <span style="color: #b22222;">;; </span><span style="color: #b22222;">we could raise an empty-values condition if we get 0...
</span>  (logcount possible-values))

(<span style="color: #7f007f;">defun</span> <span style="color: #0000ff;">first-set-value</span> (possible-values)
  <span style="color: #bc8f8f;">"Return the index of the first set value in POSSIBLE-VALUES."</span>
  (+ 1 (floor (log possible-values 2))))

(<span style="color: #7f007f;">defun</span> <span style="color: #0000ff;">only-possible-value-is?</span> (possible-values value)
  <span style="color: #bc8f8f;">"Return a generalized boolean which is true when the only value found in
   POSSIBLE-VALUES is VALUE"</span>
  (and (logbitp (- value 1) possible-values)
       (= 1 (logcount possible-values))))

(<span style="color: #7f007f;">defun</span> <span style="color: #0000ff;">list-all-possible-values</span> (possible-values)
  <span style="color: #bc8f8f;">"Return a list of all possible values to explore"</span>
  (<span style="color: #7f007f;">loop</span> for i from 1 to 9
     when (logbitp (- i 1) possible-values)
     collect i))

(<span style="color: #7f007f;">defun</span> <span style="color: #0000ff;">value-is-set?</span> (possible-values value)
  <span style="color: #bc8f8f;">"Return a generalized boolean which is true when given VALUE is possible
   in POSSIBLE-VALUES"</span>
  (logbitp (- value 1) possible-values))

(<span style="color: #7f007f;">defun</span> <span style="color: #0000ff;">unset-possible-value</span> (possible-values value)
  <span style="color: #bc8f8f;">"return an integer representing POSSIBLE-VALUES with VALUE unset"</span>
  (logxor possible-values (ash 1 (- value 1))))
</pre>

<p>You can see here that I was also under the influence of a recent reading
about <a href="http://gar1t.com/blog/2012/06/10/solving-embarrassingly-obvious-problems-in-erlang/">making it obvious</a>, or so called <a href="http://dieswaytoofast.blogspot.fr/2012/07/erlang-why-so-many-seemingly-identical.html">intentional programming</a>, following
what <a href="http://armstrongonsoftware.blogspot.fr/">Joe Armstrong</a> has to say about it:</p>

<blockquote>
<p class="quoted"><em>Intentional programming is a name I give to a style of programming where
the reader of a program can easily see what the programmer intended by
their code. The intention of the code should be obvious from the names
of the functions involved and not be inferred by analysing the structure
of the code. (Reading the code should) precisely expresses the intention
of the programmerhere no guesswork or program analysis is involved, we
clearly read what was intended.</em></p>
</blockquote>

<p>So there we go with function names such as <code>count-remaining-possible-values</code>,
that will help when reading some more complex code, as in the following, the
meat of the solution:</p>

<pre class="src">
(<span style="color: #7f007f;">defmethod</span> <span style="color: #0000ff;">eliminate</span> ((puzzle puzzle) row col value)
  <span style="color: #bc8f8f;">"Eliminate given VALUE from possible values in cell ROWxCOL of PUZZLE, and
   propagate when needed"</span>
  (<span style="color: #7f007f;">with-slots</span> (grid values) puzzle
    <span style="color: #b22222;">;; </span><span style="color: #b22222;">if already unset, work is already done
</span>    (<span style="color: #7f007f;">when</span> (value-is-set? (aref values row col) value)
      <span style="color: #b22222;">;; </span><span style="color: #b22222;">eliminate the value from the set of possible values
</span>      (<span style="color: #7f007f;">let*</span> ((possible-values
              (unset-possible-value (aref values row col) value)))
        (setf (aref values row col) possible-values)

        <span style="color: #b22222;">;; </span><span style="color: #b22222;">now if we're left with a single possible value
</span>        (<span style="color: #7f007f;">when</span> (= 1 (count-remaining-possible-values possible-values))
          (<span style="color: #7f007f;">let</span> ((found-value (first-set-value possible-values)))
            <span style="color: #b22222;">;; </span><span style="color: #b22222;">update the main grid
</span>            (setf (aref grid row col) found-value)

            <span style="color: #b22222;">;; </span><span style="color: #b22222;">eliminate that value we just found in all peers
</span>            (eliminate-value-in-peers puzzle row col found-value)))

        <span style="color: #b22222;">;; </span><span style="color: #b22222;">now check if any unit has a single possible place for that value
</span>        (<span style="color: #7f007f;">loop</span>
           for (r . c)
           in (list-places-with-single-unit-solution puzzle row col value)
           do (assign puzzle r c value))))))
</pre>

<p>So that lisp code is quite verbose and at 389 lines almost doubles the 201
lines Norvig had. When clarity is part of the goal, that's hard to avoid, I
hope I made a good case that this is not due to lisp being overly verbose by
itself.</p>


<h3>Comments on the development environment</h3>

<p class="first">Or why I even considered <em>Common Lisp</em> as an interesting language for that
kind of exercise, and some more. <em>I'll have to tell about re-sharding data
live with 16 threads and 256 databases, all in CL, someday</em>.</p>

<p>So I've been doing some <em>Emacs Lisp</em> development for a while now, and the part
that makes that so much fun is the instant reward. You write some code in
your editor, type a key chord (usually, that's <code>C-M-x runs the command
eval-defun</code>) and your code is loaded up, ready to be tested. In <em>Emacs Lisp</em>
the test can be simply using your editor and watching the new behavior
taking place, or playing in the <code>M-x ielm</code> console. When the code is not
ready, it crashes, and you're left in the interactive debugger, where you
can use <code>C-x C-e runs the command eval-last-sexp</code> to evaluate any expression
in your source and see its value in the current <em>debug frame</em>.</p>

<p>That way of working is a huge productivity boost, that I've been missing
much when getting back to writing C code for PostgreSQL. I can't <code>C-M-x</code> the
current function and go write some <code>SQL</code> to test it right away, I have to
<em>compile</em> the whole source tree, then <em>install</em> the new binaries, then <em>restart</em>
the test server and then open up a <em>psql</em> console to interact with the new
code. Of course I could just <code>make check</code> and watch the results, but then if I
attach a <em>debugger</em> it complains that the code on-disk is more recent than the
code in the <em>core dump</em>.</p>

<p>What if you want <em>Emacs Lisp</em> integrated facilities and something made for
general programming rather than suited to building a text editor? Don't get
me wrong, you can probably find more production ready code in <em>elisp</em> than in
many other languages, just because Emacs has been there for about 35 years.
Editor targeted production code, though.</p>

<p>This integrated development cycle is all the same when you're using <em>Common
Lisp</em>. The awesome <a href="http://common-lisp.net/project/slime/">Superior Lisp Interaction Mode for Emacs</a> is providing
exactly that experience. Just run <code>M-x slime</code> and then as you define your code
you can <code>C-M-x</code> the function at point, see the compilation errors and warnings
if any in the associated <em>REPL</em>, and just try your code. I tend to mostly play
in the command line, it's possible to just use <code>C-x C-e</code> while typing too.</p>


<h3>Performances</h3>

<p class="first">Of course we do care! After all the original article came with a quite
detailed performance analysis with graphs and all. I won't be reproducing
that, sorry. I'll just show you what penalty you get for using an older
language specification, much more dynamic and with more features than
python, and with a great, scratch that, awesome development environment.</p>

<p>Oh wait, that's the other way round, no penalty, it's actually so much
faster!</p>

<h4>Python version perfs</h4>

<p class="first">The results I got on my desktop machine are about twice as fast as in the
original article, I guess newer machines and newer python have something to
say for that:</p>

<pre class="src">
  dim ~/dev/CL/sudoku python sudoku.dim.py
  All tests pass.
  Solved 50 of 50 easy puzzles (avg 0.01 secs (151 Hz), max 0.01 secs).
  Solved 95 of 95 hard puzzles (avg 0.02 secs (42 Hz), max 0.12 secs).
  Solved 11 of 11 hardest puzzles (avg 0.01 secs (115 Hz), max 0.01 secs).
</pre>

<p>That makes an average of <code>(50*151 + 95*42 + 11*115) / (50+95+11) =
82Hz</code>.</p>

<p>That seems pretty good, let's continue.</p>

<p>As you can see I've cut away the <em>random puzzle</em> part, that's because I was
too lazy to implement that part, which didn't seem all that interesting to
me. If you think that's a problem and need solving, I accept patches.</p>


<h4>Common lisp version perfs</h4>

<p class="first">When using <a href="http://sbcl.org/">SBCL</a> on the same machine, what I got was:</p>

<pre class="src">
  (sudoku:solve-example-grids)
  Solved 50 of 50 easy puzzles (avg .0021 sec (471.7 Hz), max 0.015 secs).
  Solved 95 of 95 hard puzzles (avg .0022 sec (446.0 Hz), max 0.008 secs).
  Solved 11 of 11 hardest puzzles (avg .0018 sec (550.0 Hz), max 0.003 secs).
</pre>

<p>With the same way to compute the average, we now have <code>461.6Hz</code>.</p>

<p>Now, that's between 3 times and more than <strong>10 times faster</strong> than the python
version (taken collection per collection), for a comparable effort, a much
better development environment, and the same all dynamic no explicit
compiling approach.</p>



<h3>Conclusion</h3>

<p class="first">I guess I'm fond of <em>Common Lisp</em>, which I already saw coming (so did you,
right?), and now I have some public article and code to share about why :)</p>

<p>The code is hosted at <a href="https://github.com/dimitri/sudoku">https://github.com/dimitri/sudoku</a> if you're
interested, with the necessary files to reproduce, some docs, etc.</p>

<p>Also, apart from using <em>integers</em> as <em>bitfields</em>, which I did more for being
lispy than for performances, I did very little effort for optimizing the
code. It's quite naive in this respect, yet allow me an average of <code>461.6Hz</code>
rather than <code>82Hz</code>, that's <strong><em>5.6 times faster</em></strong> average.</p>

<p>So yes, I will continue to invest some precious time in <em>Common Lisp</em> as a
very good interactive scripting language, and maybe more than that.</p>
]]></description>
  <author>dim@tapoueh.org (Dimitri Fontaine)</author>
  <pubDate>Tue, 10 Jul 2012 20:37:00 +0200</pubDate>
  <guid isPermaLink="true">http://tapoueh.org/blog/2012/07/10-solving-sudoku.html</guid>
</item>
  </channel>
</rss>
